// Generated by Haxe 4.0.0-rc.3
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = true;
EReg.prototype = {
	match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,matched: function(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw new js__$Boot_HaxeError("EReg::matched");
		}
	}
};
var FormatterVersion = function() { };
FormatterVersion.__name__ = true;
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var json2object_reader_BaseParser = function(errors,putils,errorType) {
	this.errors = errors;
	this.putils = putils;
	this.errorType = errorType;
};
json2object_reader_BaseParser.__name__ = true;
json2object_reader_BaseParser.prototype = {
	fromJson: function(jsonString,filename) {
		if(filename == null) {
			filename = "";
		}
		this.putils = new json2object_PositionUtils(jsonString);
		this.errors = [];
		try {
			var json = new hxjsonast_Parser(jsonString,filename).parseRec();
			this.loadJson(json);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(((e1) instanceof hxjsonast_Error)) {
				var e2 = e1;
				this.errors.push(json2object_Error.ParserError(e2.message,this.putils.convertPosition(e2.pos)));
			} else {
				throw e;
			}
		}
		return this.value;
	}
	,loadJson: function(json,variable) {
		if(variable == null) {
			variable = "";
		}
		var pos = this.putils.convertPosition(json.pos);
		var _g = json.value;
		switch(_g._hx_index) {
		case 0:
			var s = _g.s;
			this.loadJsonString(s,pos,variable);
			break;
		case 1:
			var n = _g.s;
			this.loadJsonNumber(n,pos,variable);
			break;
		case 2:
			var o = _g.fields;
			this.loadJsonObject(o,pos,variable);
			break;
		case 3:
			var a = _g.values;
			this.loadJsonArray(a,pos,variable);
			break;
		case 4:
			var b = _g.b;
			this.loadJsonBool(b,pos,variable);
			break;
		case 5:
			this.loadJsonNull(pos,variable);
			break;
		}
		return this.value;
	}
	,loadJsonNull: function(pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonString: function(s,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadString: function(s,pos,variable,validValues,defaultValue) {
		if(validValues.indexOf(s) != -1) {
			return s;
		}
		this.onIncorrectType(pos,variable);
		return defaultValue;
	}
	,loadJsonNumber: function(f,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonUInt: function(f,pos,variable,value) {
		var uint = 0;
		f = StringTools.trim(f);
		var neg = f.charAt(0) == "-";
		if(neg) {
			f = HxOverrides.substr(f,1,null);
		}
		var hex = StringTools.startsWith(f,"0x");
		if(hex) {
			f = HxOverrides.substr(f,2,null);
		}
		var base = hex ? 16 : 10;
		var pow = 1;
		var i = f.length - 1;
		while(i >= 0) {
			var cur = hex ? Std.parseInt("0x" + f.charAt(i)) : Std.parseInt(f.charAt(i));
			if(cur == null) {
				this.onIncorrectType(pos,variable);
				return value;
			}
			uint = uint + pow * cur;
			pow *= base;
			--i;
		}
		return uint;
	}
	,loadJsonInt: function(f,pos,variable,value) {
		if(Std.parseInt(f) != null && Std.parseInt(f) == parseFloat(f)) {
			return Std.parseInt(f);
		}
		this.onIncorrectType(pos,variable);
		return value;
	}
	,loadJsonFloat: function(f,pos,variable,value) {
		if(Std.parseInt(f) != null) {
			return parseFloat(f);
		}
		this.onIncorrectType(pos,variable);
		return value;
	}
	,loadJsonBool: function(b,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonArray: function(a,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadJsonArrayValue: function(a,loadJsonFn,variable) {
		var _g = [];
		var _g1 = 0;
		while(_g1 < a.length) {
			var j = a[_g1];
			++_g1;
			var tmp;
			try {
				tmp = loadJsonFn(j,variable);
			} catch( _ ) {
				haxe_CallStack.lastException = _;
				var _1 = ((_) instanceof js__$Boot_HaxeError) ? _.val : _;
				if(typeof(_1) == "string") {
					var _2 = _1;
					continue;
				} else {
					throw _;
				}
			}
			_g.push(tmp);
		}
		return _g;
	}
	,loadJsonObject: function(o,pos,variable) {
		this.onIncorrectType(pos,variable);
	}
	,loadObjectField: function(loadJsonFn,field,name,assigned,defaultValue) {
		try {
			var ret = loadJsonFn(field.value,field.name);
			this.mapSet(assigned,name,true);
			return ret;
		} catch( _ ) {
			haxe_CallStack.lastException = _;
			var _1 = ((_) instanceof js__$Boot_HaxeError) ? _.val : _;
		}
		return defaultValue;
	}
	,loadObjectFieldReflect: function(loadJsonFn,field,name,assigned) {
		try {
			this.value[name] = loadJsonFn(field.value,field.name);
			this.mapSet(assigned,name,true);
		} catch( _ ) {
			haxe_CallStack.lastException = _;
			var _1 = ((_) instanceof js__$Boot_HaxeError) ? _.val : _;
		}
	}
	,objectSetupAssign: function(assigned,keys,values) {
		var _g = 0;
		var _g1 = keys.length;
		while(_g < _g1) {
			var i = _g++;
			this.mapSet(assigned,keys[i],values[i]);
		}
	}
	,objectErrors: function(assigned,pos) {
		var lastPos = this.putils.convertPosition(new hxjsonast_Position(pos.file,pos.max - 1,pos.max - 1));
		var s = assigned.keys();
		while(s.hasNext()) {
			var s1 = s.next();
			if(!(__map_reserved[s1] != null ? assigned.getReserved(s1) : assigned.h[s1])) {
				this.errors.push(json2object_Error.UninitializedVariable(s1,lastPos));
			}
		}
	}
	,onIncorrectType: function(pos,variable) {
		this.parsingThrow();
	}
	,parsingThrow: function() {
		if(this.errorType != 0) {
			throw new js__$Boot_HaxeError("json2object: parsing throw");
		}
	}
	,objectThrow: function(pos,variable) {
		if(this.errorType == 2) {
			throw new js__$Boot_HaxeError("json2object: parsing throw");
		} else if(this.errorType == 1) {
			this.errors.push(json2object_Error.UninitializedVariable(variable,pos));
		}
	}
	,mapSet: function(map,key,value) {
		if(__map_reserved[key] != null) {
			map.setReserved(key,value);
		} else {
			map.h[key] = value;
		}
	}
};
var JsonParser_$1 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$1.__name__ = true;
JsonParser_$1.__super__ = json2object_reader_BaseParser;
JsonParser_$1.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?wrapping : Null<formatter.config.WrapConfig>, ?whitespace : Null<formatter.config.WhitespaceConfig>, ?sameLine : Null<formatter.config.SameLineConfig>, ?lineEnds : Null<formatter.config.LineEndConfig>, ?indentation : Null<formatter.config.IndentationConfig>, ?excludes : Null<Array<String>>, ?emptyLines : Null<formatter.config.EmptyLinesConfig>, ?disableFormatting : Null<Bool> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["disableFormatting","emptyLines","excludes","indentation","lineEnds","sameLine","whitespace","wrapping"],[true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "disableFormatting":
				this.value.disableFormatting = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"disableFormatting",assigned,this.value.disableFormatting);
				break;
			case "emptyLines":
				this.value.emptyLines = this.loadObjectField(($_=new JsonParser_$4(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyLines",assigned,this.value.emptyLines);
				break;
			case "excludes":
				this.value.excludes = this.loadObjectField(($_=new JsonParser_$66(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"excludes",assigned,this.value.excludes);
				break;
			case "indentation":
				this.value.indentation = this.loadObjectField(($_=new JsonParser_$33(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentation",assigned,this.value.indentation);
				break;
			case "lineEnds":
				this.value.lineEnds = this.loadObjectField(($_=new JsonParser_$36(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineEnds",assigned,this.value.lineEnds);
				break;
			case "sameLine":
				this.value.sameLine = this.loadObjectField(($_=new JsonParser_$39(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sameLine",assigned,this.value.sameLine);
				break;
			case "whitespace":
				this.value.whitespace = this.loadObjectField(($_=new JsonParser_$42(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whitespace",assigned,this.value.whitespace);
				break;
			case "wrapping":
				this.value.wrapping = this.loadObjectField(($_=new JsonParser_$60(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"wrapping",assigned,this.value.wrapping);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { disableFormatting : false, emptyLines : new JsonParser_$4([],this.putils,0).getAuto(), excludes : ["\\.haxelib","\\.git","node_modules"], indentation : new JsonParser_$33([],this.putils,0).getAuto(), lineEnds : new JsonParser_$36([],this.putils,0).getAuto(), sameLine : new JsonParser_$39([],this.putils,0).getAuto(), whitespace : new JsonParser_$42([],this.putils,0).getAuto(), wrapping : new JsonParser_$60([],this.putils,0).getAuto()};
	}
});
var JsonParser_$110 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$110.__name__ = true;
JsonParser_$110.__super__ = json2object_reader_BaseParser;
JsonParser_$110.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "beforeLast";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingLocation",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["beforeLast","afterLast"],"beforeLast");
	}
	,getAuto: function() {
		return new JsonParser_$110([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$112 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$112.__name__ = true;
JsonParser_$112.__super__ = json2object_reader_BaseParser;
JsonParser_$112.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
	,getAuto: function() {
		return new JsonParser_$112([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$114 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$114.__name__ = true;
JsonParser_$114.__super__ = json2object_reader_BaseParser;
JsonParser_$114.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapRule>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$116(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,getAuto: function() {
		return new JsonParser_$114([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$116 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$116.__name__ = true;
JsonParser_$116.__super__ = json2object_reader_BaseParser;
JsonParser_$116.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ type : formatter.config.WrappingType, ?location : Null<formatter.config.WrappingLocation>, conditions : Array<formatter.config.WrapCondition>, ?additionalIndent : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["additionalIndent","conditions","location","type"],[true,false,true,false]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "additionalIndent":
				this.value.additionalIndent = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"additionalIndent",assigned,this.value.additionalIndent);
				break;
			case "conditions":
				this.value.conditions = this.loadObjectField(($_=new JsonParser_$117(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditions",assigned,this.value.conditions);
				break;
			case "location":
				this.value.location = this.loadObjectField(($_=new JsonParser_$110(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"location",assigned,this.value.location);
				break;
			case "type":
				this.value.type = this.loadObjectField(($_=new JsonParser_$118(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"type",assigned,this.value.type);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { additionalIndent : 0, conditions : new JsonParser_$117([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), location : "afterLast", type : new JsonParser_$118([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)))};
	}
});
var JsonParser_$117 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$117.__name__ = true;
JsonParser_$117.__super__ = json2object_reader_BaseParser;
JsonParser_$117.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<formatter.config.WrapCondition>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$120(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,getAuto: function() {
		return new JsonParser_$117([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$118 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$118.__name__ = true;
JsonParser_$118.__super__ = json2object_reader_BaseParser;
JsonParser_$118.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "onePerLine";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrappingType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["onePerLine","onePerLineAfterFirst","equalNumber","fillLine","fillLineWithLeadingBreak","noWrap","keep"],"onePerLine");
	}
	,getAuto: function() {
		return new JsonParser_$118([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$12 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$12.__name__ = true;
JsonParser_$12.__super__ = json2object_reader_BaseParser;
JsonParser_$12.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?beforeError : Null<Int>, ?beforeEnd : Null<Int>, ?beforeElse : Null<Int>, ?afterIf : Null<Int>, ?afterError : Null<Int>, ?afterElse : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterElse","afterError","afterIf","beforeElse","beforeEnd","beforeError"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterElse":
				this.value.afterElse = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterElse",assigned,this.value.afterElse);
				break;
			case "afterError":
				this.value.afterError = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterError",assigned,this.value.afterError);
				break;
			case "afterIf":
				this.value.afterIf = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterIf",assigned,this.value.afterIf);
				break;
			case "beforeElse":
				this.value.beforeElse = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeElse",assigned,this.value.beforeElse);
				break;
			case "beforeEnd":
				this.value.beforeEnd = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeEnd",assigned,this.value.beforeEnd);
				break;
			case "beforeError":
				this.value.beforeError = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeError",assigned,this.value.beforeError);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterElse : 0, afterError : 0, afterIf : 0, beforeElse : 0, beforeEnd : 0, beforeError : 0};
	}
});
var JsonParser_$120 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$120.__name__ = true;
JsonParser_$120.__super__ = json2object_reader_BaseParser;
JsonParser_$120.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?value : Null<Int>, cond : formatter.config.WrapConditionType }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["cond","value"],[false,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "cond":
				this.value.cond = this.loadObjectField(($_=new JsonParser_$121(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"cond",assigned,this.value.cond);
				break;
			case "value":
				this.value.value = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"value",assigned,this.value.value);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { cond : new JsonParser_$121([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1))), value : 1};
	}
});
var JsonParser_$121 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$121.__name__ = true;
JsonParser_$121.__super__ = json2object_reader_BaseParser;
JsonParser_$121.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "itemCount >= n";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WrapConditionType",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["itemCount >= n","itemCount <= n","anyItemLength >= n","anyItemLength <= n","totalItemLength >= n","totalItemLength <= n","lineLength >= n","lineLength <= n","hasMultilineItems"],"itemCount >= n");
	}
	,getAuto: function() {
		return new JsonParser_$121([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$123 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$123.__name__ = true;
JsonParser_$123.__super__ = json2object_reader_BaseParser;
JsonParser_$123.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.WhitespacePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","noneBefore","onlyBefore","after","onlyAfter","noneAfter","around"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$123([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$15 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$15.__name__ = true;
JsonParser_$15.__super__ = json2object_reader_BaseParser;
JsonParser_$15.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterVars : 1, beginType : 0, betweenFunctions : 1, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
});
var JsonParser_$153 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$153.__name__ = true;
JsonParser_$153.__super__ = json2object_reader_BaseParser;
JsonParser_$153.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "same";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SameLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["same","next","keep"],"same");
	}
	,getAuto: function() {
		return new JsonParser_$153([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$156 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$156.__name__ = true;
JsonParser_$156.__super__ = json2object_reader_BaseParser;
JsonParser_$156.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["emptyCurly","leftCurly","rightCurly"],[true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$162(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$164(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$170(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { emptyCurly : "noBreak", leftCurly : "after", rightCurly : "both"};
	}
});
var JsonParser_$160 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$160.__name__ = true;
JsonParser_$160.__super__ = json2object_reader_BaseParser;
JsonParser_$160.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CaseColonLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$160([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$162 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$162.__name__ = true;
JsonParser_$162.__super__ = json2object_reader_BaseParser;
JsonParser_$162.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "noBreak";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.EmptyCurlyPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noBreak","break"],"noBreak");
	}
	,getAuto: function() {
		return new JsonParser_$162([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$164 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$164.__name__ = true;
JsonParser_$164.__super__ = json2object_reader_BaseParser;
JsonParser_$164.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LeftCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","before","both"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$164([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$166 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$166.__name__ = true;
JsonParser_$166.__super__ = json2object_reader_BaseParser;
JsonParser_$166.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.AtLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after","afterLast","forceAfterLast"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$166([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$170 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$170.__name__ = true;
JsonParser_$170.__super__ = json2object_reader_BaseParser;
JsonParser_$170.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.RightCurlyLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","before","after","both"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$170([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$172 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$172.__name__ = true;
JsonParser_$172.__super__ = json2object_reader_BaseParser;
JsonParser_$172.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "none";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.SharpLineEndPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["none","after"],"none");
	}
	,getAuto: function() {
		return new JsonParser_$172([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$176 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$176.__name__ = true;
JsonParser_$176.__super__ = json2object_reader_BaseParser;
JsonParser_$176.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = s;
	}
	,getAuto: function() {
		return new JsonParser_$176([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$178 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$178.__name__ = true;
JsonParser_$178.__super__ = json2object_reader_BaseParser;
JsonParser_$178.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "fixedZero";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ConditionalIndentationPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["fixedZero","aligned","alignedIncrease","alignedDecrease"],"fixedZero");
	}
	,getAuto: function() {
		return new JsonParser_$178([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$18 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$18.__name__ = true;
JsonParser_$18.__super__ = json2object_reader_BaseParser;
JsonParser_$18.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenFields : Null<Int>, ?beginType : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beginType","betweenFields","endType","existingBetweenFields"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFields":
				this.value.betweenFields = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFields",assigned,this.value.betweenFields);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { beginType : 0, betweenFields : 0, endType : 0, existingBetweenFields : "keep"};
	}
});
var JsonParser_$180 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$180.__name__ = true;
JsonParser_$180.__super__ = json2object_reader_BaseParser;
JsonParser_$180.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "all";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.BetweenImportsEmptyLinesLevel",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["all","firstLevelPackage","secondLevelPackage","thirdLevelPackage","fourthLevelPackage","fifthLevelPackage","fullPackage"],"all");
	}
	,getAuto: function() {
		return new JsonParser_$180([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$182 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$182.__name__ = true;
JsonParser_$182.__super__ = json2object_reader_BaseParser;
JsonParser_$182.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.KeepEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","remove"],"keep");
	}
	,getAuto: function() {
		return new JsonParser_$182([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$186 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$186.__name__ = true;
JsonParser_$186.__super__ = json2object_reader_BaseParser;
JsonParser_$186.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "ignore";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.CommentEmptyLinesPolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["ignore","none","one"],"ignore");
	}
	,getAuto: function() {
		return new JsonParser_$186([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$202 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$202.__name__ = true;
JsonParser_$202.__super__ = json2object_reader_BaseParser;
JsonParser_$202.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "keep";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.LineCommentEmptyLinePolicy",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["keep","one","none"],"keep");
	}
	,getAuto: function() {
		return new JsonParser_$202([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$21 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$21.__name__ = true;
JsonParser_$21.__super__ = json2object_reader_BaseParser;
JsonParser_$21.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterVars","beginType","betweenFunctions","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterVars : 0, beginType : 0, betweenFunctions : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
});
var JsonParser_$24 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$24.__name__ = true;
JsonParser_$24.__super__ = json2object_reader_BaseParser;
JsonParser_$24.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?betweenImportsLevel : Null<formatter.config.BetweenImportsEmptyLinesLevel>, ?betweenImports : Null<Int>, ?beforeUsing : Null<Int>, ?beforeType : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["beforeType","beforeUsing","betweenImports","betweenImportsLevel"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "beforeType":
				this.value.beforeType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeType",assigned,this.value.beforeType);
				break;
			case "beforeUsing":
				this.value.beforeUsing = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeUsing",assigned,this.value.beforeUsing);
				break;
			case "betweenImports":
				this.value.betweenImports = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImports",assigned,this.value.betweenImports);
				break;
			case "betweenImportsLevel":
				this.value.betweenImportsLevel = this.loadObjectField(($_=new JsonParser_$180(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenImportsLevel",assigned,this.value.betweenImportsLevel);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { beforeType : 1, beforeUsing : 1, betweenImports : 0, betweenImportsLevel : "all"};
	}
});
var JsonParser_$33 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$33.__name__ = true;
JsonParser_$33.__super__ = json2object_reader_BaseParser;
JsonParser_$33.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?trailingWhitespace : Null<Bool>, ?tabWidth : Null<Int>, ?indentObjectLiteral : Null<Bool>, ?indentComplexValueExpressions : Null<Bool>, ?indentCaseLabels : Null<Bool>, ?conditionalPolicy : Null<formatter.config.ConditionalIndentationPolicy>, ?character : Null<String> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["character","conditionalPolicy","indentCaseLabels","indentComplexValueExpressions","indentObjectLiteral","tabWidth","trailingWhitespace"],[true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "character":
				this.value.character = this.loadObjectField(($_=new JsonParser_$176(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"character",assigned,this.value.character);
				break;
			case "conditionalPolicy":
				this.value.conditionalPolicy = this.loadObjectField(($_=new JsonParser_$178(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalPolicy",assigned,this.value.conditionalPolicy);
				break;
			case "indentCaseLabels":
				this.value.indentCaseLabels = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentCaseLabels",assigned,this.value.indentCaseLabels);
				break;
			case "indentComplexValueExpressions":
				this.value.indentComplexValueExpressions = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentComplexValueExpressions",assigned,this.value.indentComplexValueExpressions);
				break;
			case "indentObjectLiteral":
				this.value.indentObjectLiteral = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"indentObjectLiteral",assigned,this.value.indentObjectLiteral);
				break;
			case "tabWidth":
				this.value.tabWidth = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tabWidth",assigned,this.value.tabWidth);
				break;
			case "trailingWhitespace":
				this.value.trailingWhitespace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"trailingWhitespace",assigned,this.value.trailingWhitespace);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { character : "tab", conditionalPolicy : "aligned", indentCaseLabels : true, indentComplexValueExpressions : false, indentObjectLiteral : true, tabWidth : 4, trailingWhitespace : false};
	}
});
var JsonParser_$36 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$36.__name__ = true;
JsonParser_$36.__super__ = json2object_reader_BaseParser;
JsonParser_$36.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefCurly : Null<formatter.config.CurlyLineEndPolicy>, ?sharp : Null<formatter.config.SharpLineEndPolicy>, ?rightCurly : Null<formatter.config.RightCurlyLineEndPolicy>, ?objectLiteralCurly : Null<formatter.config.CurlyLineEndPolicy>, ?metadataVar : Null<formatter.config.AtLineEndPolicy>, ?metadataType : Null<formatter.config.AtLineEndPolicy>, ?metadataOther : Null<formatter.config.AtLineEndPolicy>, ?metadataFunction : Null<formatter.config.AtLineEndPolicy>, ?leftCurly : Null<formatter.config.LeftCurlyLineEndPolicy>, ?emptyCurly : Null<formatter.config.EmptyCurlyPolicy>, ?caseColon : Null<formatter.config.CaseColonLineEndPolicy>, ?blockCurly : Null<formatter.config.CurlyLineEndPolicy>, ?anonTypeCurly : Null<formatter.config.CurlyLineEndPolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonTypeCurly","blockCurly","caseColon","emptyCurly","leftCurly","metadataFunction","metadataOther","metadataType","metadataVar","objectLiteralCurly","rightCurly","sharp","typedefCurly"],[true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonTypeCurly":
				this.value.anonTypeCurly = this.loadObjectField(($_=new JsonParser_$156(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeCurly",assigned,this.value.anonTypeCurly);
				break;
			case "blockCurly":
				this.value.blockCurly = this.loadObjectField(($_=new JsonParser_$156(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockCurly",assigned,this.value.blockCurly);
				break;
			case "caseColon":
				this.value.caseColon = this.loadObjectField(($_=new JsonParser_$160(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColon",assigned,this.value.caseColon);
				break;
			case "emptyCurly":
				this.value.emptyCurly = this.loadObjectField(($_=new JsonParser_$162(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"emptyCurly",assigned,this.value.emptyCurly);
				break;
			case "leftCurly":
				this.value.leftCurly = this.loadObjectField(($_=new JsonParser_$164(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"leftCurly",assigned,this.value.leftCurly);
				break;
			case "metadataFunction":
				this.value.metadataFunction = this.loadObjectField(($_=new JsonParser_$166(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataFunction",assigned,this.value.metadataFunction);
				break;
			case "metadataOther":
				this.value.metadataOther = this.loadObjectField(($_=new JsonParser_$166(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataOther",assigned,this.value.metadataOther);
				break;
			case "metadataType":
				this.value.metadataType = this.loadObjectField(($_=new JsonParser_$166(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataType",assigned,this.value.metadataType);
				break;
			case "metadataVar":
				this.value.metadataVar = this.loadObjectField(($_=new JsonParser_$166(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataVar",assigned,this.value.metadataVar);
				break;
			case "objectLiteralCurly":
				this.value.objectLiteralCurly = this.loadObjectField(($_=new JsonParser_$156(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralCurly",assigned,this.value.objectLiteralCurly);
				break;
			case "rightCurly":
				this.value.rightCurly = this.loadObjectField(($_=new JsonParser_$170(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rightCurly",assigned,this.value.rightCurly);
				break;
			case "sharp":
				this.value.sharp = this.loadObjectField(($_=new JsonParser_$172(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"sharp",assigned,this.value.sharp);
				break;
			case "typedefCurly":
				this.value.typedefCurly = this.loadObjectField(($_=new JsonParser_$156(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefCurly",assigned,this.value.typedefCurly);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonTypeCurly : null, blockCurly : null, caseColon : "after", emptyCurly : "noBreak", leftCurly : "after", metadataFunction : "none", metadataOther : "none", metadataType : "none", metadataVar : "none", objectLiteralCurly : null, rightCurly : "both", sharp : "after", typedefCurly : null};
	}
});
var JsonParser_$39 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$39.__name__ = true;
JsonParser_$39.__super__ = json2object_reader_BaseParser;
JsonParser_$39.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whileBody : Null<formatter.config.SameLinePolicy>, ?untypedBody : Null<formatter.config.SameLinePolicy>, ?tryCatch : Null<formatter.config.SameLinePolicy>, ?tryBody : Null<formatter.config.SameLinePolicy>, ?returnBodySingleLine : Null<formatter.config.SameLinePolicy>, ?returnBody : Null<formatter.config.SameLinePolicy>, ?ifElse : Null<formatter.config.SameLinePolicy>, ?ifBody : Null<formatter.config.SameLinePolicy>, ?functionBody : Null<formatter.config.SameLinePolicy>, ?forBody : Null<formatter.config.SameLinePolicy>, ?expressionTry : Null<formatter.config.SameLinePolicy>, ?expressionIfWithBlocks : Null<Bool>, ?expressionIf : Null<formatter.config.SameLinePolicy>, ?expressionCase : Null<formatter.config.SameLinePolicy>, ?elseIf : Null<formatter.config.SameLinePolicy>, ?elseBody : Null<formatter.config.SameLinePolicy>, ?doWhileBody : Null<formatter.config.SameLinePolicy>, ?doWhile : Null<formatter.config.SameLinePolicy>, ?comprehensionFor : Null<formatter.config.SameLinePolicy>, ?catchBody : Null<formatter.config.SameLinePolicy>, ?caseBody : Null<formatter.config.SameLinePolicy>, ?anonFunctionBody : Null<formatter.config.SameLinePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionBody","caseBody","catchBody","comprehensionFor","doWhile","doWhileBody","elseBody","elseIf","expressionCase","expressionIf","expressionIfWithBlocks","expressionTry","forBody","functionBody","ifBody","ifElse","returnBody","returnBodySingleLine","tryBody","tryCatch","untypedBody","whileBody"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionBody":
				this.value.anonFunctionBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionBody",assigned,this.value.anonFunctionBody);
				break;
			case "caseBody":
				this.value.caseBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseBody",assigned,this.value.caseBody);
				break;
			case "catchBody":
				this.value.catchBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchBody",assigned,this.value.catchBody);
				break;
			case "comprehensionFor":
				this.value.comprehensionFor = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"comprehensionFor",assigned,this.value.comprehensionFor);
				break;
			case "doWhile":
				this.value.doWhile = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhile",assigned,this.value.doWhile);
				break;
			case "doWhileBody":
				this.value.doWhileBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doWhileBody",assigned,this.value.doWhileBody);
				break;
			case "elseBody":
				this.value.elseBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseBody",assigned,this.value.elseBody);
				break;
			case "elseIf":
				this.value.elseIf = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"elseIf",assigned,this.value.elseIf);
				break;
			case "expressionCase":
				this.value.expressionCase = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionCase",assigned,this.value.expressionCase);
				break;
			case "expressionIf":
				this.value.expressionIf = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIf",assigned,this.value.expressionIf);
				break;
			case "expressionIfWithBlocks":
				this.value.expressionIfWithBlocks = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionIfWithBlocks",assigned,this.value.expressionIfWithBlocks);
				break;
			case "expressionTry":
				this.value.expressionTry = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionTry",assigned,this.value.expressionTry);
				break;
			case "forBody":
				this.value.forBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forBody",assigned,this.value.forBody);
				break;
			case "functionBody":
				this.value.functionBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionBody",assigned,this.value.functionBody);
				break;
			case "ifBody":
				this.value.ifBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifBody",assigned,this.value.ifBody);
				break;
			case "ifElse":
				this.value.ifElse = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifElse",assigned,this.value.ifElse);
				break;
			case "returnBody":
				this.value.returnBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBody",assigned,this.value.returnBody);
				break;
			case "returnBodySingleLine":
				this.value.returnBodySingleLine = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"returnBodySingleLine",assigned,this.value.returnBodySingleLine);
				break;
			case "tryBody":
				this.value.tryBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryBody",assigned,this.value.tryBody);
				break;
			case "tryCatch":
				this.value.tryCatch = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryCatch",assigned,this.value.tryCatch);
				break;
			case "untypedBody":
				this.value.untypedBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"untypedBody",assigned,this.value.untypedBody);
				break;
			case "whileBody":
				this.value.whileBody = this.loadObjectField(($_=new JsonParser_$153(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whileBody",assigned,this.value.whileBody);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionBody : "same", caseBody : "next", catchBody : "next", comprehensionFor : "same", doWhile : "same", doWhileBody : "next", elseBody : "next", elseIf : "same", expressionCase : "keep", expressionIf : "same", expressionIfWithBlocks : false, expressionTry : "same", forBody : "next", functionBody : "next", ifBody : "next", ifElse : "same", returnBody : "same", returnBodySingleLine : "same", tryBody : "next", tryCatch : "same", untypedBody : "same", whileBody : "next"};
	}
});
var JsonParser_$4 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$4.__name__ = true;
JsonParser_$4.__super__ = json2object_reader_BaseParser;
JsonParser_$4.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typedefEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?maxAnywhereInFile : Null<Int>, ?macroClassEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?lineCommentsBetweenTypes : Null<formatter.config.LineCommentEmptyLinePolicy>, ?lineCommentsBetweenFunctions : Null<formatter.config.LineCommentEmptyLinePolicy>, ?interfaceEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?importAndUsing : Null<formatter.config.ImportsEmptyLinesConfig>, ?finalNewline : Null<Bool>, ?externClassEmptyLines : Null<formatter.config.InterfaceFieldsEmptyLinesConfig>, ?enumEmptyLines : Null<formatter.config.TypedefFieldsEmptyLinesConfig>, ?enumAbstractEmptyLines : Null<formatter.config.EnumAbstractFieldsEmptyLinesConfig>, ?conditionalsEmptyLines : Null<formatter.config.ConditionalEmptyLinesConfig>, ?classEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig>, ?betweenTypes : Null<Int>, ?betweenSingleLineTypes : Null<Int>, ?betweenMultilineComments : Null<Int>, ?beforeRightCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?beforePackage : Null<Int>, ?beforeDocCommentEmptyLines : Null<formatter.config.CommentEmptyLinesPolicy>, ?beforeBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterReturn : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterPackage : Null<Int>, ?afterLeftCurly : Null<formatter.config.KeepEmptyLinesPolicy>, ?afterFileHeaderComment : Null<Int>, ?afterFieldsWithDocComments : Null<formatter.config.CommentEmptyLinesPolicy>, ?afterBlocks : Null<formatter.config.KeepEmptyLinesPolicy>, ?abstractEmptyLines : Null<formatter.config.ClassFieldsEmptyLinesConfig> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["abstractEmptyLines","afterBlocks","afterFieldsWithDocComments","afterFileHeaderComment","afterLeftCurly","afterPackage","afterReturn","beforeBlocks","beforeDocCommentEmptyLines","beforePackage","beforeRightCurly","betweenMultilineComments","betweenSingleLineTypes","betweenTypes","classEmptyLines","conditionalsEmptyLines","enumAbstractEmptyLines","enumEmptyLines","externClassEmptyLines","finalNewline","importAndUsing","interfaceEmptyLines","lineCommentsBetweenFunctions","lineCommentsBetweenTypes","macroClassEmptyLines","maxAnywhereInFile","typedefEmptyLines"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "abstractEmptyLines":
				this.value.abstractEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"abstractEmptyLines",assigned,this.value.abstractEmptyLines);
				break;
			case "afterBlocks":
				this.value.afterBlocks = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterBlocks",assigned,this.value.afterBlocks);
				break;
			case "afterFieldsWithDocComments":
				this.value.afterFieldsWithDocComments = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFieldsWithDocComments",assigned,this.value.afterFieldsWithDocComments);
				break;
			case "afterFileHeaderComment":
				this.value.afterFileHeaderComment = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterFileHeaderComment",assigned,this.value.afterFileHeaderComment);
				break;
			case "afterLeftCurly":
				this.value.afterLeftCurly = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterLeftCurly",assigned,this.value.afterLeftCurly);
				break;
			case "afterPackage":
				this.value.afterPackage = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPackage",assigned,this.value.afterPackage);
				break;
			case "afterReturn":
				this.value.afterReturn = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterReturn",assigned,this.value.afterReturn);
				break;
			case "beforeBlocks":
				this.value.beforeBlocks = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeBlocks",assigned,this.value.beforeBlocks);
				break;
			case "beforeDocCommentEmptyLines":
				this.value.beforeDocCommentEmptyLines = this.loadObjectField(($_=new JsonParser_$186(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeDocCommentEmptyLines",assigned,this.value.beforeDocCommentEmptyLines);
				break;
			case "beforePackage":
				this.value.beforePackage = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforePackage",assigned,this.value.beforePackage);
				break;
			case "beforeRightCurly":
				this.value.beforeRightCurly = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beforeRightCurly",assigned,this.value.beforeRightCurly);
				break;
			case "betweenMultilineComments":
				this.value.betweenMultilineComments = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenMultilineComments",assigned,this.value.betweenMultilineComments);
				break;
			case "betweenSingleLineTypes":
				this.value.betweenSingleLineTypes = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenSingleLineTypes",assigned,this.value.betweenSingleLineTypes);
				break;
			case "betweenTypes":
				this.value.betweenTypes = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenTypes",assigned,this.value.betweenTypes);
				break;
			case "classEmptyLines":
				this.value.classEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"classEmptyLines",assigned,this.value.classEmptyLines);
				break;
			case "conditionalsEmptyLines":
				this.value.conditionalsEmptyLines = this.loadObjectField(($_=new JsonParser_$12(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionalsEmptyLines",assigned,this.value.conditionalsEmptyLines);
				break;
			case "enumAbstractEmptyLines":
				this.value.enumAbstractEmptyLines = this.loadObjectField(($_=new JsonParser_$15(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumAbstractEmptyLines",assigned,this.value.enumAbstractEmptyLines);
				break;
			case "enumEmptyLines":
				this.value.enumEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"enumEmptyLines",assigned,this.value.enumEmptyLines);
				break;
			case "externClassEmptyLines":
				this.value.externClassEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"externClassEmptyLines",assigned,this.value.externClassEmptyLines);
				break;
			case "finalNewline":
				this.value.finalNewline = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"finalNewline",assigned,this.value.finalNewline);
				break;
			case "importAndUsing":
				this.value.importAndUsing = this.loadObjectField(($_=new JsonParser_$24(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"importAndUsing",assigned,this.value.importAndUsing);
				break;
			case "interfaceEmptyLines":
				this.value.interfaceEmptyLines = this.loadObjectField(($_=new JsonParser_$21(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"interfaceEmptyLines",assigned,this.value.interfaceEmptyLines);
				break;
			case "lineCommentsBetweenFunctions":
				this.value.lineCommentsBetweenFunctions = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenFunctions",assigned,this.value.lineCommentsBetweenFunctions);
				break;
			case "lineCommentsBetweenTypes":
				this.value.lineCommentsBetweenTypes = this.loadObjectField(($_=new JsonParser_$202(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"lineCommentsBetweenTypes",assigned,this.value.lineCommentsBetweenTypes);
				break;
			case "macroClassEmptyLines":
				this.value.macroClassEmptyLines = this.loadObjectField(($_=new JsonParser_$7(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"macroClassEmptyLines",assigned,this.value.macroClassEmptyLines);
				break;
			case "maxAnywhereInFile":
				this.value.maxAnywhereInFile = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxAnywhereInFile",assigned,this.value.maxAnywhereInFile);
				break;
			case "typedefEmptyLines":
				this.value.typedefEmptyLines = this.loadObjectField(($_=new JsonParser_$18(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefEmptyLines",assigned,this.value.typedefEmptyLines);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { abstractEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), afterBlocks : "remove", afterFieldsWithDocComments : "one", afterFileHeaderComment : 1, afterLeftCurly : "remove", afterPackage : 1, afterReturn : "remove", beforeBlocks : "remove", beforeDocCommentEmptyLines : "one", beforePackage : 0, beforeRightCurly : "remove", betweenMultilineComments : 0, betweenSingleLineTypes : 0, betweenTypes : 1, classEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), conditionalsEmptyLines : new JsonParser_$12([],this.putils,0).getAuto(), enumAbstractEmptyLines : new JsonParser_$15([],this.putils,0).getAuto(), enumEmptyLines : new JsonParser_$18([],this.putils,0).getAuto(), externClassEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), finalNewline : true, importAndUsing : new JsonParser_$24([],this.putils,0).getAuto(), interfaceEmptyLines : new JsonParser_$21([],this.putils,0).getAuto(), lineCommentsBetweenFunctions : "keep", lineCommentsBetweenTypes : "keep", macroClassEmptyLines : new JsonParser_$7([],this.putils,0).getAuto(), maxAnywhereInFile : 1, typedefEmptyLines : new JsonParser_$18([],this.putils,0).getAuto()};
	}
});
var JsonParser_$42 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$42.__name__ = true;
JsonParser_$42.__super__ = json2object_reader_BaseParser;
JsonParser_$42.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?whilePolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamOpenPolicy : Null<formatter.config.WhitespacePolicy>, ?typeParamClosePolicy : Null<formatter.config.WhitespacePolicy>, ?typeHintColonPolicy : Null<formatter.config.WhitespacePolicy>, ?typeExtensionPolicy : Null<formatter.config.WhitespacePolicy>, ?typeCheckColonPolicy : Null<formatter.config.WhitespacePolicy>, ?tryPolicy : Null<formatter.config.WhitespacePolicy>, ?ternaryPolicy : Null<formatter.config.WhitespacePolicy>, ?switchPolicy : Null<formatter.config.WhitespacePolicy>, ?semicolonPolicy : Null<formatter.config.WhitespacePolicy>, ?parenConfig : Null<formatter.config.ParenWhitespaceConfig>, ?openingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?objectFieldColonPolicy : Null<formatter.config.WhitespacePolicy>, ?intervalPolicy : Null<formatter.config.WhitespacePolicy>, ?ifPolicy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe4Policy : Null<formatter.config.WhitespacePolicy>, ?functionTypeHaxe3Policy : Null<formatter.config.WhitespacePolicy>, ?formatStringInterpolation : Null<Bool>, ?forPolicy : Null<formatter.config.WhitespacePolicy>, ?dotPolicy : Null<formatter.config.WhitespacePolicy>, ?doPolicy : Null<formatter.config.WhitespacePolicy>, ?compressSuccessiveParenthesis : Null<Bool>, ?commaPolicy : Null<formatter.config.WhitespacePolicy>, ?colonPolicy : Null<formatter.config.WhitespacePolicy>, ?closingBracketPolicy : Null<formatter.config.WhitespacePolicy>, ?catchPolicy : Null<formatter.config.WhitespacePolicy>, ?caseColonPolicy : Null<formatter.config.WhitespacePolicy>, ?bracesConfig : Null<formatter.config.BracesWhitespaceConfig>, ?binopPolicy : Null<formatter.config.WhitespacePolicy>, ?arrowFunctionsPolicy : Null<formatter.config.WhitespacePolicy>, ?addLineCommentSpace : Null<Bool> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["addLineCommentSpace","arrowFunctionsPolicy","binopPolicy","bracesConfig","caseColonPolicy","catchPolicy","closingBracketPolicy","colonPolicy","commaPolicy","compressSuccessiveParenthesis","doPolicy","dotPolicy","forPolicy","formatStringInterpolation","functionTypeHaxe3Policy","functionTypeHaxe4Policy","ifPolicy","intervalPolicy","objectFieldColonPolicy","openingBracketPolicy","parenConfig","semicolonPolicy","switchPolicy","ternaryPolicy","tryPolicy","typeCheckColonPolicy","typeExtensionPolicy","typeHintColonPolicy","typeParamClosePolicy","typeParamOpenPolicy","whilePolicy"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "addLineCommentSpace":
				this.value.addLineCommentSpace = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"addLineCommentSpace",assigned,this.value.addLineCommentSpace);
				break;
			case "arrowFunctionsPolicy":
				this.value.arrowFunctionsPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrowFunctionsPolicy",assigned,this.value.arrowFunctionsPolicy);
				break;
			case "binopPolicy":
				this.value.binopPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"binopPolicy",assigned,this.value.binopPolicy);
				break;
			case "bracesConfig":
				this.value.bracesConfig = this.loadObjectField(($_=new JsonParser_$45(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"bracesConfig",assigned,this.value.bracesConfig);
				break;
			case "caseColonPolicy":
				this.value.caseColonPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"caseColonPolicy",assigned,this.value.caseColonPolicy);
				break;
			case "catchPolicy":
				this.value.catchPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"catchPolicy",assigned,this.value.catchPolicy);
				break;
			case "closingBracketPolicy":
				this.value.closingBracketPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingBracketPolicy",assigned,this.value.closingBracketPolicy);
				break;
			case "colonPolicy":
				this.value.colonPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"colonPolicy",assigned,this.value.colonPolicy);
				break;
			case "commaPolicy":
				this.value.commaPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"commaPolicy",assigned,this.value.commaPolicy);
				break;
			case "compressSuccessiveParenthesis":
				this.value.compressSuccessiveParenthesis = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"compressSuccessiveParenthesis",assigned,this.value.compressSuccessiveParenthesis);
				break;
			case "doPolicy":
				this.value.doPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"doPolicy",assigned,this.value.doPolicy);
				break;
			case "dotPolicy":
				this.value.dotPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"dotPolicy",assigned,this.value.dotPolicy);
				break;
			case "forPolicy":
				this.value.forPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forPolicy",assigned,this.value.forPolicy);
				break;
			case "formatStringInterpolation":
				this.value.formatStringInterpolation = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"formatStringInterpolation",assigned,this.value.formatStringInterpolation);
				break;
			case "functionTypeHaxe3Policy":
				this.value.functionTypeHaxe3Policy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe3Policy",assigned,this.value.functionTypeHaxe3Policy);
				break;
			case "functionTypeHaxe4Policy":
				this.value.functionTypeHaxe4Policy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionTypeHaxe4Policy",assigned,this.value.functionTypeHaxe4Policy);
				break;
			case "ifPolicy":
				this.value.ifPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ifPolicy",assigned,this.value.ifPolicy);
				break;
			case "intervalPolicy":
				this.value.intervalPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"intervalPolicy",assigned,this.value.intervalPolicy);
				break;
			case "objectFieldColonPolicy":
				this.value.objectFieldColonPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectFieldColonPolicy",assigned,this.value.objectFieldColonPolicy);
				break;
			case "openingBracketPolicy":
				this.value.openingBracketPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingBracketPolicy",assigned,this.value.openingBracketPolicy);
				break;
			case "parenConfig":
				this.value.parenConfig = this.loadObjectField(($_=new JsonParser_$48(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"parenConfig",assigned,this.value.parenConfig);
				break;
			case "semicolonPolicy":
				this.value.semicolonPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"semicolonPolicy",assigned,this.value.semicolonPolicy);
				break;
			case "switchPolicy":
				this.value.switchPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"switchPolicy",assigned,this.value.switchPolicy);
				break;
			case "ternaryPolicy":
				this.value.ternaryPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"ternaryPolicy",assigned,this.value.ternaryPolicy);
				break;
			case "tryPolicy":
				this.value.tryPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"tryPolicy",assigned,this.value.tryPolicy);
				break;
			case "typeCheckColonPolicy":
				this.value.typeCheckColonPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeCheckColonPolicy",assigned,this.value.typeCheckColonPolicy);
				break;
			case "typeExtensionPolicy":
				this.value.typeExtensionPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeExtensionPolicy",assigned,this.value.typeExtensionPolicy);
				break;
			case "typeHintColonPolicy":
				this.value.typeHintColonPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeHintColonPolicy",assigned,this.value.typeHintColonPolicy);
				break;
			case "typeParamClosePolicy":
				this.value.typeParamClosePolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamClosePolicy",assigned,this.value.typeParamClosePolicy);
				break;
			case "typeParamOpenPolicy":
				this.value.typeParamOpenPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParamOpenPolicy",assigned,this.value.typeParamOpenPolicy);
				break;
			case "whilePolicy":
				this.value.whilePolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"whilePolicy",assigned,this.value.whilePolicy);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { addLineCommentSpace : true, arrowFunctionsPolicy : "around", binopPolicy : "around", bracesConfig : new JsonParser_$45([],this.putils,0).getAuto(), caseColonPolicy : "onlyAfter", catchPolicy : "after", closingBracketPolicy : "none", colonPolicy : "none", commaPolicy : "onlyAfter", compressSuccessiveParenthesis : true, doPolicy : "after", dotPolicy : "none", forPolicy : "after", formatStringInterpolation : true, functionTypeHaxe3Policy : "none", functionTypeHaxe4Policy : "around", ifPolicy : "after", intervalPolicy : "none", objectFieldColonPolicy : "after", openingBracketPolicy : "noneAfter", parenConfig : new JsonParser_$48([],this.putils,0).getAuto(), semicolonPolicy : "onlyAfter", switchPolicy : "after", ternaryPolicy : "around", tryPolicy : "after", typeCheckColonPolicy : "around", typeExtensionPolicy : "after", typeHintColonPolicy : "none", typeParamClosePolicy : "none", typeParamOpenPolicy : "none", whilePolicy : "after"};
	}
});
var JsonParser_$45 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$45.__name__ = true;
JsonParser_$45.__super__ = json2object_reader_BaseParser;
JsonParser_$45.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?unknownBraces : Null<formatter.config.OpenClosePolicy>, ?typedefBraces : Null<formatter.config.OpenClosePolicy>, ?objectLiteralBraces : Null<formatter.config.OpenClosePolicy>, ?blockBraces : Null<formatter.config.OpenClosePolicy>, ?anonTypeBraces : Null<formatter.config.OpenClosePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonTypeBraces","blockBraces","objectLiteralBraces","typedefBraces","unknownBraces"],[true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonTypeBraces":
				this.value.anonTypeBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonTypeBraces",assigned,this.value.anonTypeBraces);
				break;
			case "blockBraces":
				this.value.blockBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"blockBraces",assigned,this.value.blockBraces);
				break;
			case "objectLiteralBraces":
				this.value.objectLiteralBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteralBraces",assigned,this.value.objectLiteralBraces);
				break;
			case "typedefBraces":
				this.value.typedefBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typedefBraces",assigned,this.value.typedefBraces);
				break;
			case "unknownBraces":
				this.value.unknownBraces = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"unknownBraces",assigned,this.value.unknownBraces);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonTypeBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, blockBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, objectLiteralBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, typedefBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, unknownBraces : { openingPolicy : "before", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}};
	}
});
var JsonParser_$48 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$48.__name__ = true;
JsonParser_$48.__super__ = json2object_reader_BaseParser;
JsonParser_$48.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?metadataParens : Null<formatter.config.OpenClosePolicy>, ?funcParamParens : Null<formatter.config.OpenClosePolicy>, ?forLoopParens : Null<formatter.config.OpenClosePolicy>, ?expressionParens : Null<formatter.config.OpenClosePolicy>, ?conditionParens : Null<formatter.config.OpenClosePolicy>, ?callParens : Null<formatter.config.OpenClosePolicy>, ?anonFuncParamParens : Null<formatter.config.OpenClosePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFuncParamParens","callParens","conditionParens","expressionParens","forLoopParens","funcParamParens","metadataParens"],[true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFuncParamParens":
				this.value.anonFuncParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFuncParamParens",assigned,this.value.anonFuncParamParens);
				break;
			case "callParens":
				this.value.callParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParens",assigned,this.value.callParens);
				break;
			case "conditionParens":
				this.value.conditionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"conditionParens",assigned,this.value.conditionParens);
				break;
			case "expressionParens":
				this.value.expressionParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"expressionParens",assigned,this.value.expressionParens);
				break;
			case "forLoopParens":
				this.value.forLoopParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"forLoopParens",assigned,this.value.forLoopParens);
				break;
			case "funcParamParens":
				this.value.funcParamParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"funcParamParens",assigned,this.value.funcParamParens);
				break;
			case "metadataParens":
				this.value.metadataParens = this.loadObjectField(($_=new JsonParser_$51(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataParens",assigned,this.value.metadataParens);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		var tmp = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp1 = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp2 = new JsonParser_$51([],this.putils,0).getAuto();
		var tmp3 = new JsonParser_$51([],this.putils,0).getAuto();
		return { anonFuncParamParens : tmp, callParens : tmp1, conditionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, expressionParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, forLoopParens : { openingPolicy : "noneAfter", closingPolicy : "onlyAfter", removeInnerWhenEmpty : true}, funcParamParens : tmp2, metadataParens : tmp3};
	}
});
var JsonParser_$51 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$51.__name__ = true;
JsonParser_$51.__super__ = json2object_reader_BaseParser;
JsonParser_$51.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?removeInnerWhenEmpty : Null<Bool>, ?openingPolicy : Null<formatter.config.WhitespacePolicy>, ?closingPolicy : Null<formatter.config.WhitespacePolicy> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["closingPolicy","openingPolicy","removeInnerWhenEmpty"],[true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "closingPolicy":
				this.value.closingPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"closingPolicy",assigned,this.value.closingPolicy);
				break;
			case "openingPolicy":
				this.value.openingPolicy = this.loadObjectField(($_=new JsonParser_$123(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"openingPolicy",assigned,this.value.openingPolicy);
				break;
			case "removeInnerWhenEmpty":
				this.value.removeInnerWhenEmpty = this.loadObjectField(($_=new JsonParser_$62(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"removeInnerWhenEmpty",assigned,this.value.removeInnerWhenEmpty);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { closingPolicy : "onlyAfter", openingPolicy : "none", removeInnerWhenEmpty : true};
	}
});
var JsonParser_$60 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$60.__name__ = true;
JsonParser_$60.__super__ = json2object_reader_BaseParser;
JsonParser_$60.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?typeParameter : Null<formatter.config.WrapRules>, ?opBoolChain : Null<formatter.config.WrapRules>, ?opAddSubChain : Null<formatter.config.WrapRules>, ?objectLiteral : Null<formatter.config.WrapRules>, ?multiVar : Null<formatter.config.WrapRules>, ?methodChain : Null<formatter.config.WrapRules>, ?metadataCallParameter : Null<formatter.config.WrapRules>, ?maxLineLength : Null<Int>, ?implementsExtends : Null<formatter.config.WrapRules>, ?functionSignature : Null<formatter.config.WrapRules>, ?callParameter : Null<formatter.config.WrapRules>, ?arrayWrap : Null<formatter.config.WrapRules>, ?arrayMatrixWrap : Null<formatter.config.ArrayMatrixWrap>, ?anonType : Null<formatter.config.WrapRules>, ?anonFunctionSignature : Null<formatter.config.WrapRules> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["anonFunctionSignature","anonType","arrayMatrixWrap","arrayWrap","callParameter","functionSignature","implementsExtends","maxLineLength","metadataCallParameter","methodChain","multiVar","objectLiteral","opAddSubChain","opBoolChain","typeParameter"],[true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "anonFunctionSignature":
				this.value.anonFunctionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonFunctionSignature",assigned,this.value.anonFunctionSignature);
				break;
			case "anonType":
				this.value.anonType = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"anonType",assigned,this.value.anonType);
				break;
			case "arrayMatrixWrap":
				this.value.arrayMatrixWrap = this.loadObjectField(($_=new JsonParser_$84(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayMatrixWrap",assigned,this.value.arrayMatrixWrap);
				break;
			case "arrayWrap":
				this.value.arrayWrap = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"arrayWrap",assigned,this.value.arrayWrap);
				break;
			case "callParameter":
				this.value.callParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"callParameter",assigned,this.value.callParameter);
				break;
			case "functionSignature":
				this.value.functionSignature = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"functionSignature",assigned,this.value.functionSignature);
				break;
			case "implementsExtends":
				this.value.implementsExtends = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"implementsExtends",assigned,this.value.implementsExtends);
				break;
			case "maxLineLength":
				this.value.maxLineLength = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"maxLineLength",assigned,this.value.maxLineLength);
				break;
			case "metadataCallParameter":
				this.value.metadataCallParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"metadataCallParameter",assigned,this.value.metadataCallParameter);
				break;
			case "methodChain":
				this.value.methodChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"methodChain",assigned,this.value.methodChain);
				break;
			case "multiVar":
				this.value.multiVar = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"multiVar",assigned,this.value.multiVar);
				break;
			case "objectLiteral":
				this.value.objectLiteral = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"objectLiteral",assigned,this.value.objectLiteral);
				break;
			case "opAddSubChain":
				this.value.opAddSubChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opAddSubChain",assigned,this.value.opAddSubChain);
				break;
			case "opBoolChain":
				this.value.opBoolChain = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"opBoolChain",assigned,this.value.opBoolChain);
				break;
			case "typeParameter":
				this.value.typeParameter = this.loadObjectField(($_=new JsonParser_$80(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"typeParameter",assigned,this.value.typeParameter);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { anonFunctionSignature : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine", additionalIndent : 1},{ conditions : [{ cond : "totalItemLength >= n", value : 80}], type : "fillLine", additionalIndent : 1}]}, anonType : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"}]}, arrayMatrixWrap : "matrixWrapWithAlign", arrayWrap : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "hasMultilineItems", value : 1}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength <= n", value : 80}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 10}], type : "fillLineWithLeadingBreak"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"}]}, callParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "anyItemLength >= n", value : 80}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"}]}, functionSignature : { defaultWrap : "fillLine", defaultAdditionalIndent : 1, rules : []}, implementsExtends : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140}], type : "fillLine", additionalIndent : 2},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "fillLine", additionalIndent : 2}]}, maxLineLength : 160, metadataCallParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "totalItemLength >= n", value : 140}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "fillLine"}]}, methodChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount <= n", value : 3}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 80}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30},{ cond : "itemCount >= n", value : 4}], type : "onePerLineAfterFirst"},{ conditions : [{ cond : "itemCount >= n", value : 7}], type : "onePerLineAfterFirst"}]}, multiVar : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength <= n", value : 15}], type : "fillLine"},{ conditions : [{ cond : "lineLength >= n", value : 80}], type : "onePerLineAfterFirst"}]}, objectLiteral : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "itemCount <= n", value : 3}], type : "noWrap"},{ conditions : [{ cond : "anyItemLength >= n", value : 30}], type : "onePerLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 60}], type : "onePerLine"},{ conditions : [{ cond : "itemCount >= n", value : 4}], type : "onePerLine"}]}, opAddSubChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 160},{ cond : "anyItemLength >= n", value : 60}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 160}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"}]}, opBoolChain : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "lineLength >= n", value : 140},{ cond : "anyItemLength >= n", value : 40}], location : "beforeLast", type : "onePerLineAfterFirst"},{ conditions : [{ cond : "lineLength >= n", value : 140}], location : "beforeLast", type : "fillLine"},{ conditions : [{ cond : "itemCount <= n", value : 3}], type : "noWrap"},{ conditions : [{ cond : "totalItemLength <= n", value : 120}], type : "noWrap"},{ conditions : [{ cond : "itemCount >= n", value : 4}], location : "beforeLast", type : "onePerLineAfterFirst"}]}, typeParameter : { defaultWrap : "noWrap", rules : [{ conditions : [{ cond : "anyItemLength >= n", value : 50}], type : "fillLine"},{ conditions : [{ cond : "totalItemLength >= n", value : 70}], type : "fillLine"}]}};
	}
});
var JsonParser_$62 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$62.__name__ = true;
JsonParser_$62.__super__ = json2object_reader_BaseParser;
JsonParser_$62.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Bool",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonBool: function(b,pos,variable) {
		this.value = b;
	}
	,getAuto: function() {
		return new JsonParser_$62([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$66 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$66.__name__ = true;
JsonParser_$66.__super__ = json2object_reader_BaseParser;
JsonParser_$66.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Array<String>",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonArray: function(a,pos,variable) {
		this.value = this.loadJsonArrayValue(a,($_=new JsonParser_$77(this.errors,this.putils,2),$bind($_,$_.loadJson)),variable);
	}
	,getAuto: function() {
		return new JsonParser_$66([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$7 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$7.__name__ = true;
JsonParser_$7.__super__ = json2object_reader_BaseParser;
JsonParser_$7.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?existingBetweenFields : Null<formatter.config.KeepEmptyLinesPolicy>, ?endType : Null<Int>, ?betweenVars : Null<Int>, ?betweenStaticVars : Null<Int>, ?betweenStaticFunctions : Null<Int>, ?betweenFunctions : Null<Int>, ?beginType : Null<Int>, ?afterVars : Null<Int>, ?afterStaticVars : Null<Int>, ?afterStaticFunctions : Null<Int>, ?afterPrivateVars : Null<Int>, ?afterPrivateFunctions : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["afterPrivateFunctions","afterPrivateVars","afterStaticFunctions","afterStaticVars","afterVars","beginType","betweenFunctions","betweenStaticFunctions","betweenStaticVars","betweenVars","endType","existingBetweenFields"],[true,true,true,true,true,true,true,true,true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "afterPrivateFunctions":
				this.value.afterPrivateFunctions = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateFunctions",assigned,this.value.afterPrivateFunctions);
				break;
			case "afterPrivateVars":
				this.value.afterPrivateVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterPrivateVars",assigned,this.value.afterPrivateVars);
				break;
			case "afterStaticFunctions":
				this.value.afterStaticFunctions = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticFunctions",assigned,this.value.afterStaticFunctions);
				break;
			case "afterStaticVars":
				this.value.afterStaticVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterStaticVars",assigned,this.value.afterStaticVars);
				break;
			case "afterVars":
				this.value.afterVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"afterVars",assigned,this.value.afterVars);
				break;
			case "beginType":
				this.value.beginType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"beginType",assigned,this.value.beginType);
				break;
			case "betweenFunctions":
				this.value.betweenFunctions = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenFunctions",assigned,this.value.betweenFunctions);
				break;
			case "betweenStaticFunctions":
				this.value.betweenStaticFunctions = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticFunctions",assigned,this.value.betweenStaticFunctions);
				break;
			case "betweenStaticVars":
				this.value.betweenStaticVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenStaticVars",assigned,this.value.betweenStaticVars);
				break;
			case "betweenVars":
				this.value.betweenVars = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"betweenVars",assigned,this.value.betweenVars);
				break;
			case "endType":
				this.value.endType = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"endType",assigned,this.value.endType);
				break;
			case "existingBetweenFields":
				this.value.existingBetweenFields = this.loadObjectField(($_=new JsonParser_$182(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"existingBetweenFields",assigned,this.value.existingBetweenFields);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { afterPrivateFunctions : 1, afterPrivateVars : 1, afterStaticFunctions : 1, afterStaticVars : 1, afterVars : 1, beginType : 0, betweenFunctions : 1, betweenStaticFunctions : 1, betweenStaticVars : 0, betweenVars : 0, endType : 0, existingBetweenFields : "keep"};
	}
});
var JsonParser_$77 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$77.__name__ = true;
JsonParser_$77.__super__ = json2object_reader_BaseParser;
JsonParser_$77.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"String",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = s;
	}
	,getAuto: function() {
		return new JsonParser_$77([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$80 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$80.__name__ = true;
JsonParser_$80.__super__ = json2object_reader_BaseParser;
JsonParser_$80.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"{ ?rules : Null<Array<formatter.config.WrapRule>>, ?defaultWrap : Null<formatter.config.WrappingType>, ?defaultLocation : Null<formatter.config.WrappingLocation>, ?defaultAdditionalIndent : Null<Int> }",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonObject: function(o,pos,variable) {
		var assigned = new haxe_ds_StringMap();
		this.objectSetupAssign(assigned,["defaultAdditionalIndent","defaultLocation","defaultWrap","rules"],[true,true,true,true]);
		this.value = this.getAuto();
		var _g = 0;
		while(_g < o.length) {
			var field = o[_g];
			++_g;
			switch(field.name) {
			case "defaultAdditionalIndent":
				this.value.defaultAdditionalIndent = this.loadObjectField(($_=new JsonParser_$94(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultAdditionalIndent",assigned,this.value.defaultAdditionalIndent);
				break;
			case "defaultLocation":
				this.value.defaultLocation = this.loadObjectField(($_=new JsonParser_$110(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultLocation",assigned,this.value.defaultLocation);
				break;
			case "defaultWrap":
				this.value.defaultWrap = this.loadObjectField(($_=new JsonParser_$112(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"defaultWrap",assigned,this.value.defaultWrap);
				break;
			case "rules":
				this.value.rules = this.loadObjectField(($_=new JsonParser_$114(this.errors,this.putils,1),$bind($_,$_.loadJson)),field,"rules",assigned,this.value.rules);
				break;
			default:
				this.errors.push(json2object_Error.UnknownVariable(field.name,this.putils.convertPosition(field.namePos)));
			}
		}
		this.objectErrors(assigned,pos);
	}
	,getAuto: function() {
		return { defaultAdditionalIndent : 0, defaultLocation : "afterLast", defaultWrap : "noWrap", rules : []};
	}
});
var JsonParser_$84 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$84.__name__ = true;
JsonParser_$84.__super__ = json2object_reader_BaseParser;
JsonParser_$84.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.value = "noMatrixWrap";
		this.errors.push(json2object_Error.IncorrectType(variable,"formatter.config.ArrayMatrixWrap",pos));
		this.objectThrow(pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonString: function(s,pos,variable) {
		this.value = this.loadString(s,pos,variable,["noMatrixWrap","matrixWrapNoAlign","matrixWrapWithAlign"],"noMatrixWrap");
	}
	,getAuto: function() {
		return new JsonParser_$84([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var JsonParser_$94 = function(errors,putils,errorType) {
	if(errorType == null) {
		errorType = 0;
	}
	json2object_reader_BaseParser.call(this,errors,putils,errorType);
};
JsonParser_$94.__name__ = true;
JsonParser_$94.__super__ = json2object_reader_BaseParser;
JsonParser_$94.prototype = $extend(json2object_reader_BaseParser.prototype,{
	onIncorrectType: function(pos,variable) {
		this.errors.push(json2object_Error.IncorrectType(variable,"Int",pos));
		json2object_reader_BaseParser.prototype.onIncorrectType.call(this,pos,variable);
	}
	,loadJsonNull: function(pos,variable) {
		this.value = null;
	}
	,loadJsonNumber: function(f,pos,variable) {
		this.value = this.loadJsonInt(f,pos,variable,this.value);
	}
	,getAuto: function() {
		return new JsonParser_$94([],this.putils,0).loadJson(new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position("",0,1)));
	}
});
var Lambda = function() { };
Lambda.__name__ = true;
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Math.__name__ = true;
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = true;
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.startsWith = function(s,start) {
	if(s.length >= start.length) {
		return s.lastIndexOf(start,0) == 0;
	} else {
		return false;
	}
};
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return s.indexOf(end,slen - elen) == slen - elen;
	} else {
		return false;
	}
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.lpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	l -= s.length;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	buf_b += s == null ? "null" : "" + s;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeString: function(s,encoding) {
		var b = haxe_io_Bytes.ofString(s,encoding);
		this.writeFullBytes(b,0,b.length);
	}
};
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			haxe_CallStack.lastException = eof;
			var eof1 = ((eof) instanceof js__$Boot_HaxeError) ? eof.val : eof;
			if(((eof1) instanceof haxe_io_Eof)) {
				var eof2 = eof1;
			} else {
				throw eof;
			}
		}
		return len - k;
	}
};
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
_$Sys_FileInput.__name__ = true;
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
});
var Type = function() { };
Type.__name__ = true;
Type.enumEq = function(a,b) {
	if(a == b) {
		return true;
	}
	try {
		var e = a.__enum__;
		if(e == null || e != b.__enum__) {
			return false;
		}
		if(a._hx_index != b._hx_index) {
			return false;
		}
		var enm = $hxEnums[e];
		var ctorName = enm.__constructs__[a._hx_index];
		var params = enm[ctorName].__params__;
		var _g = 0;
		while(_g < params.length) {
			var f = params[_g];
			++_g;
			if(!Type.enumEq(a[f],b[f])) {
				return false;
			}
		}
	} catch( e1 ) {
		haxe_CallStack.lastException = e1;
		var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
		return false;
	}
	return true;
};
var byte__$ByteData_ByteData_$Impl_$ = {};
byte__$ByteData_ByteData_$Impl_$.__name__ = true;
byte__$ByteData_ByteData_$Impl_$.get_length = function(this1) {
	return this1.length;
};
byte__$ByteData_ByteData_$Impl_$.readByte = function(this1,i) {
	return this1.b[i];
};
byte__$ByteData_ByteData_$Impl_$._new = function(data) {
	var this1 = data;
	return this1;
};
byte__$ByteData_ByteData_$Impl_$.ofString = function(s) {
	var this1 = haxe_io_Bytes.ofString(s);
	return this1;
};
byte__$ByteData_ByteData_$Impl_$.ofBytes = function(b) {
	var this1 = b;
	return this1;
};
byte__$ByteData_ByteData_$Impl_$.readString = function(this1,pos,len) {
	return this1.getString(pos,len);
};
var formatter_Cli = function() {
	this.exitCode = 0;
	this.mode = formatter_Mode.Format;
	this.verbose = false;
	var _gthis = this;
	var args = process.argv.slice(2);
	if(process.env["HAXELIB_RUN"] == "1") {
		if(args.length > 0) {
			process.chdir(args.pop());
		}
	}
	var paths = [];
	var help = false;
	var pipemode = false;
	var argHandler_getDoc = function() {
		return "[-s | --source] <path>    : File or directory with .hx files to format (multiple allowed)\n[--stdin]                 : Read code from stdin and print formatted output to stdout (needs _one_ -s <path> for reference in configuration detection)\n[-v]                      : Print additional information\n[--check]                 : Don't format, only check if files are formatted correctly\n[--default-config] <path> : Generate a default hxformat.json to a file and exit\n[--help]                  : Display this list of options";
	};
	var argHandler_parse = function(__args) {
		var __index = 0;
		while(__index < __args.length) {
			var _g = __args[__index++];
			switch(_g) {
			case "--check":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				_gthis.mode = formatter_Mode.Check;
				__index += 0;
				break;
			case "--default-config":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				_gthis.generateDefaultConfig(__args[__index]);
				++__index;
				break;
			case "--help":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				help = true;
				__index += 0;
				break;
			case "--stdin":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				pipemode = true;
				__index += 0;
				break;
			case "--source":case "-s":
				if(__index + 1 > __args.length) {
					if(![false][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 1);
					}
				}
				paths.push(__args[__index]);
				++__index;
				break;
			case "-v":
				if(__index > __args.length) {
					if(![][__args.length - 1]) {
						throw new js__$Boot_HaxeError("Not enough arguments: " + Std.string(__args[__index - 1]) + " expects " + 0);
					}
				}
				_gthis.verbose = true;
				__index += 0;
				break;
			default:
				var arg = _g;
				throw new js__$Boot_HaxeError("Unknown command: " + Std.string(arg));
			}
		}
	};
	var printHelp = function() {
		var version = "1.8.0";
		process.stdout.write(Std.string("Haxe Formatter " + version));
		process.stdout.write("\n");
		var v = argHandler_getDoc();
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
	};
	try {
		argHandler_parse(args);
	} catch( e ) {
		haxe_CallStack.lastException = e;
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		new _$Sys_FileOutput(2).writeString(Std.string(e1) + "\n");
		printHelp();
		process.exit(1);
	}
	if(args.length == 0 || help) {
		printHelp();
		process.exit(0);
	}
	if(pipemode) {
		this.runPipe(paths);
		process.exit(0);
	}
	var startTime = new Date().getTime();
	this.run(paths);
	this.printStats(new Date().getTime() - startTime);
	process.exit(this.exitCode);
};
formatter_Cli.__name__ = true;
formatter_Cli.main = function() {
	new formatter_Cli();
};
formatter_Cli.prototype = {
	printStats: function(duration) {
		var seconds = duration / 1000;
		var action = this.mode == formatter_Mode.Format ? "Formatted" : "Checked";
		process.stdout.write("");
		process.stdout.write("\n");
		var fileNumber;
		if(formatter_FormatStats.successFiles != formatter_FormatStats.totalFiles) {
			fileNumber = "" + formatter_FormatStats.successFiles + "/" + formatter_FormatStats.totalFiles;
		} else {
			fileNumber = "" + formatter_FormatStats.successFiles;
		}
		process.stdout.write(Std.string("" + action + " " + fileNumber + " files in " + seconds + " s."));
		process.stdout.write("\n");
		if(formatter_FormatStats.failedFiles > 0) {
			process.stdout.write(Std.string("Format failed on " + formatter_FormatStats.failedFiles + " files"));
			process.stdout.write("\n");
		}
		if(formatter_FormatStats.disabledFiles > 0) {
			process.stdout.write(Std.string("Number of disabled files: " + formatter_FormatStats.disabledFiles));
			process.stdout.write("\n");
		}
		process.stdout.write("-------------------------");
		process.stdout.write("\n");
		process.stdout.write(Std.string("Input lines:  " + formatter_FormatStats.totalLinesOrig));
		process.stdout.write("\n");
		process.stdout.write(Std.string("Output lines: " + formatter_FormatStats.totalLinesFormatted));
		process.stdout.write("\n");
		process.stdout.write("-------------------------");
		process.stdout.write("\n");
	}
	,generateDefaultConfig: function(path) {
		if(sys_FileSystem.isDirectory(path)) {
			process.stdout.write(Std.string("\"" + path + "\" is a directory, not a file"));
			process.stdout.write("\n");
			process.exit(1);
		}
		var parser = new JsonParser_$1();
		var config = parser.fromJson("{}","default-hxformat.json");
		js_node_Fs.writeFileSync(path,JSON.stringify(config,null,"\t"));
		process.exit(0);
	}
	,run: function(paths) {
		var _g = 0;
		while(_g < paths.length) {
			var path = paths[_g];
			++_g;
			if(!sys_FileSystem.exists(path)) {
				process.stdout.write(Std.string("Skipping '" + path + "' (path does not exist)"));
				process.stdout.write("\n");
				continue;
			}
			if(sys_FileSystem.isDirectory(path)) {
				var _g1 = [];
				var _g11 = 0;
				var _g2 = js_node_Fs.readdirSync(path);
				while(_g11 < _g2.length) {
					var file = _g2[_g11];
					++_g11;
					_g1.push("" + path + "/" + file);
				}
				this.run(_g1);
			} else {
				this.formatFile(path);
			}
		}
	}
	,runPipe: function(paths) {
		var content = null;
		try {
			content = this.readNodeJsBytes(new _$Sys_FileInput(0));
			if(content == null) {
				new _$Sys_FileOutput(2).writeString("Could not read anything from STDIN");
				process.exit(-1);
			}
			if(paths.length != 1) {
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				new _$Sys_FileOutput(2).writeString("Please use exactly one `--source <path>` parameter when calling formatter with `--stdin`");
				process.exit(3);
			}
			if(!sys_FileSystem.exists(paths[0])) {
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				new _$Sys_FileOutput(2).writeString("Could not find \"" + paths[0] + "\"");
				process.exit(3);
			}
			var config = formatter_Formatter.loadConfig(paths[0]);
			var result = formatter_Formatter.format(formatter_FormatterInput.Code(content.toString()),config);
			switch(result._hx_index) {
			case 0:
				var formattedCode = result.formattedCode;
				process.stdout.write(Std.string(formattedCode));
				process.stdout.write("\n");
				process.exit(0);
				break;
			case 1:
				var errorMessage = result.errorMessage;
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				new _$Sys_FileOutput(2).writeString("Format failed: " + errorMessage);
				process.exit(2);
				break;
			case 2:
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
				process.exit(1);
				break;
			}
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(content != null) {
				process.stdout.write(Std.string(content));
				process.stdout.write("\n");
			}
			new _$Sys_FileOutput(2).writeString("Format failed: " + Std.string(e1));
			process.exit(-1);
		}
	}
	,formatFile: function(path) {
		var _gthis = this;
		if(StringTools.endsWith(path,".hx")) {
			var config = formatter_Formatter.loadConfig(path);
			if(this.verbose) {
				this.verboseLogFile(path,config);
			}
			var content = js_node_Fs.readFileSync(path,{ encoding : "utf8"});
			var result = formatter_Formatter.format(formatter_FormatterInput.Code(content),config);
			switch(result._hx_index) {
			case 0:
				var formattedCode = result.formattedCode;
				formatter_FormatStats.totalFiles++;
				formatter_FormatStats.successFiles++;
				switch(this.mode._hx_index) {
				case 0:
					js_node_Fs.writeFileSync(path,formattedCode);
					break;
				case 1:
					if(formattedCode != content.toString()) {
						process.stdout.write(Std.string("Incorrect formatting in " + path));
						process.stdout.write("\n");
						this.exitCode = 1;
					}
					break;
				case 2:
					var secondResult = formatter_Formatter.format(formatter_FormatterInput.Code(formattedCode),config);
					var unstable = function() {
						process.stdout.write(Std.string("Unstable formatting in " + path));
						process.stdout.write("\n");
						_gthis.exitCode = 1;
					};
					switch(secondResult._hx_index) {
					case 0:
						var formattedCode2 = secondResult.formattedCode;
						if(formattedCode != formattedCode2) {
							unstable();
						}
						break;
					case 1:
						var errorMessage = secondResult.errorMessage;
						unstable();
						break;
					default:
					}
					break;
				}
				break;
			case 1:
				var errorMessage1 = result.errorMessage;
				formatter_FormatStats.totalFiles++;
				formatter_FormatStats.failedFiles++;
				new _$Sys_FileOutput(2).writeString("Failed to format " + path + ": " + errorMessage1 + "\n");
				this.exitCode = 1;
				break;
			case 2:
				formatter_FormatStats.totalFiles++;
				formatter_FormatStats.disabledFiles++;
				break;
			}
		}
	}
	,verboseLogFile: function(path,config) {
		if(config != null) {
			if(this.lastConfigFileName == null || this.lastConfigFileName != config.configFileName) {
				if(this.lastConfigFileName != null) {
					process.stdout.write("");
					process.stdout.write("\n");
				}
				this.lastConfigFileName = config.configFileName;
				process.stdout.write(Std.string("Using " + this.lastConfigFileName + ":"));
				process.stdout.write("\n");
			}
		}
		var action = this.mode == formatter_Mode.Format ? "Formatting" : "Checking";
		process.stdout.write(Std.string("" + action + " " + path));
		process.stdout.write("\n");
	}
	,readNodeJsBytes: function(stdIn) {
		var bufsize = 16384;
		var buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
		var total = new haxe_io_BytesBuffer();
		try {
			while(true) {
				var len = stdIn.readBytes(buf,0,bufsize);
				if(len == 0) {
					break;
				}
				total.addBytes(buf,0,len);
			}
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		}
		return total.getBytes();
	}
};
var formatter_Mode = $hxEnums["formatter.Mode"] = { __ename__ : true, __constructs__ : ["Format","Check","CheckStability"]
	,Format: {_hx_index:0,__enum__:"formatter.Mode",toString:$estr}
	,Check: {_hx_index:1,__enum__:"formatter.Mode",toString:$estr}
	,CheckStability: {_hx_index:2,__enum__:"formatter.Mode",toString:$estr}
};
var formatter_FormatStats = function() { };
formatter_FormatStats.__name__ = true;
formatter_FormatStats.reset = function() {
	formatter_FormatStats.totalFiles = 0;
	formatter_FormatStats.successFiles = 0;
	formatter_FormatStats.failedFiles = 0;
	formatter_FormatStats.disabledFiles = 0;
	formatter_FormatStats.totalLinesOrig = 0;
	formatter_FormatStats.totalLinesFormatted = 0;
};
formatter_FormatStats.incSuccess = function() {
	formatter_FormatStats.totalFiles++;
	formatter_FormatStats.successFiles++;
};
formatter_FormatStats.incFailed = function() {
	formatter_FormatStats.totalFiles++;
	formatter_FormatStats.failedFiles++;
};
formatter_FormatStats.incDisabled = function() {
	formatter_FormatStats.totalFiles++;
	formatter_FormatStats.disabledFiles++;
};
formatter_FormatStats.addOrigLines = function(count) {
	formatter_FormatStats.totalLinesOrig += count;
};
formatter_FormatStats.addFormattedLines = function(count) {
	formatter_FormatStats.totalLinesFormatted += count;
};
var formatter_Result = $hxEnums["formatter.Result"] = { __ename__ : true, __constructs__ : ["Success","Failure","Disabled"]
	,Success: ($_=function(formattedCode) { return {_hx_index:0,formattedCode:formattedCode,__enum__:"formatter.Result",toString:$estr}; },$_.__params__ = ["formattedCode"],$_)
	,Failure: ($_=function(errorMessage) { return {_hx_index:1,errorMessage:errorMessage,__enum__:"formatter.Result",toString:$estr}; },$_.__params__ = ["errorMessage"],$_)
	,Disabled: {_hx_index:2,__enum__:"formatter.Result",toString:$estr}
};
var formatter_Formatter = function() { };
formatter_Formatter.__name__ = true;
formatter_Formatter.format = function(input,config,lineSeparator,entryPoint) {
	if(config == null) {
		config = new formatter_config_Config();
	}
	var inputData;
	switch(input._hx_index) {
	case 0:
		var fileName = input.fileName;
		if(!sys_FileSystem.exists(fileName)) {
			process.stdout.write(Std.string("Skipping '" + fileName + "' (path does not exist)"));
			process.stdout.write("\n");
			return formatter_Result.Failure("File \"" + fileName + "\" not found");
		}
		var content = js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Fs.readFileSync(fileName));
		inputData = { fileName : fileName, content : content, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint};
		return formatter_Formatter.formatInputData(inputData);
	case 1:
		var code = input.code;
		var content1 = haxe_io_Bytes.ofString(code);
		inputData = { fileName : "code snippet", content : content1, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint};
		return formatter_Formatter.formatInputData(inputData);
	case 2:
		var code1 = input.code;
		var tokenTree = input.tokenTree;
		var tokenList = input.tokenList;
		inputData = { fileName : "<unknown.hx>", content : code1, tokenList : tokenList, tokenTree : tokenTree, config : config, lineSeparator : lineSeparator, entryPoint : entryPoint};
		return formatter_Formatter.formatInputData(inputData);
	}
};
formatter_Formatter.loadConfig = function(path) {
	var configFileName = formatter_Formatter.determineConfig(path);
	if(configFileName == null) {
		return null;
	}
	var config = new formatter_config_Config();
	config.readConfig(configFileName);
	return config;
};
formatter_Formatter.formatInputData = function(inputData) {
	try {
		var config = inputData.config;
		if(config.disableFormatting) {
			return formatter_Result.Disabled;
		}
		if(config.isExcluded(inputData.fileName)) {
			return formatter_Result.Disabled;
		}
		tokentree_TokenStream.MODE = tokentree_TokenStreamMode.RELAXED;
		var parsedCode = new formatter_codedata_ParsedCode(inputData);
		formatter_FormatStats.totalLinesOrig += parsedCode.lines.length;
		var indenter = new formatter_marker_Indenter(config.indentation);
		indenter.setParsedCode(parsedCode);
		var markTokenText = new formatter_marker_MarkTokenText(config,parsedCode,indenter);
		var markWhitespace = new formatter_marker_MarkWhitespace(config,parsedCode,indenter);
		var markLineEnds = new formatter_marker_MarkLineEnds(config,parsedCode,indenter);
		var markSameLine = new formatter_marker_MarkSameLine(config,parsedCode,indenter);
		var markWrapping = new formatter_marker_wrapping_MarkWrapping(config,parsedCode,indenter);
		var markEmptyLines = new formatter_marker_MarkEmptyLines(config,parsedCode,indenter);
		var markAdditionalIndent = new formatter_marker_MarkAdditionalIndentation(config,parsedCode,indenter);
		markTokenText.run();
		markWhitespace.run();
		markLineEnds.run();
		markSameLine.run();
		markWrapping.run();
		markEmptyLines.run();
		markTokenText.finalRun();
		markAdditionalIndent.run();
		var lines = new formatter_codedata_CodeLines(parsedCode,indenter);
		lines.applyWrapping(config.wrapping);
		markEmptyLines.finalRun(lines);
		var formatted = lines.print(parsedCode.lineSeparator);
		formatter_FormatStats.totalLinesFormatted += formatted.split(parsedCode.lineSeparator).length;
		return formatter_Result.Success(formatted);
	} catch( e ) {
		haxe_CallStack.lastException = e;
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		var callstack = haxe_CallStack.toString(haxe_CallStack.exceptionStack());
		return formatter_Result.Failure(Std.string(e1) + "\n" + callstack + "\n\n");
	}
};
formatter_Formatter.determineConfig = function(fileName) {
	var path = js_node_Path.resolve(fileName);
	if(!sys_FileSystem.isDirectory(path)) {
		path = haxe_io_Path.directory(path);
	}
	while(path.length > 0) {
		var configFile = haxe_io_Path.join([path,"hxformat.json"]);
		if(sys_FileSystem.exists(configFile)) {
			return configFile;
		}
		path = haxe_io_Path.normalize(haxe_io_Path.join([path,".."]));
	}
	return null;
};
var formatter_FormatterInput = $hxEnums["formatter.FormatterInput"] = { __ename__ : true, __constructs__ : ["FileInput","Code","Tokens"]
	,FileInput: ($_=function(fileName) { return {_hx_index:0,fileName:fileName,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["fileName"],$_)
	,Code: ($_=function(code) { return {_hx_index:1,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["code"],$_)
	,Tokens: ($_=function(tokenList,tokenTree,code) { return {_hx_index:2,tokenList:tokenList,tokenTree:tokenTree,code:code,__enum__:"formatter.FormatterInput",toString:$estr}; },$_.__params__ = ["tokenList","tokenTree","code"],$_)
};
var formatter_codedata_CodeLine = function(indent) {
	this.indent = indent;
	this.parts = [];
	this.emptyLinesAfter = 0;
	this.verbatim = false;
};
formatter_codedata_CodeLine.__name__ = true;
formatter_codedata_CodeLine.prototype = {
	addToken: function(tokenInfo,lineSeparator) {
		if(tokenInfo.emptyLinesAfter > this.emptyLinesAfter) {
			this.emptyLinesAfter = tokenInfo.emptyLinesAfter;
		}
		if(this.currentPart == null) {
			this.currentPart = { firstToken : tokenInfo.token, lastToken : tokenInfo.token, text : "", multiLine : false, firstLineLength : -1, lastLineLength : -1};
			this.parts.push(this.currentPart);
		}
		this.currentPart.lastToken = tokenInfo.token;
		if(tokenInfo.spacesBefore > 0) {
			this.currentPart.text += StringTools.lpad(""," ",tokenInfo.spacesBefore);
		}
		if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space && tokenInfo.spacesAfter > 0) {
			this.currentPart.text += tokenInfo.text + StringTools.lpad(""," ",tokenInfo.spacesAfter);
		} else {
			this.currentPart.text += tokenInfo.text;
		}
		if(tokenInfo.wrapAfter) {
			this.currentPart = null;
		}
	}
	,applyWrapping: function(config,parsedCode,indenter) {
		var lineLength = indenter.calcAbsoluteIndent(this.indent);
		var _g = 0;
		var _g1 = this.parts;
		while(_g < _g1.length) {
			var part = _g1[_g];
			++_g;
			this.calcLineLengths(part,parsedCode.lineSeparator);
		}
		var _g2 = 0;
		var _g3 = this.parts.length;
		while(_g2 < _g3) {
			var index = _g2++;
			var part1 = this.parts[index];
			if(part1.multiLine) {
				if(lineLength + part1.firstLineLength > config.maxLineLength) {
					return this.wrappedAt(index,config,parsedCode,indenter);
				}
				lineLength = part1.lastLineLength;
				continue;
			}
			lineLength += part1.text.length;
			if(lineLength > config.maxLineLength) {
				return this.wrappedAt(index,config,parsedCode,indenter);
			}
		}
		return [this];
	}
	,calcLineLengths: function(part,lineSeparator) {
		var lines = part.text.split(lineSeparator);
		part.multiLine = lines.length > 1;
		if(part.multiLine) {
			part.firstLineLength = lines[0].length;
			part.lastLineLength = lines[lines.length - 1].length;
		} else {
			part.firstLineLength = part.text.length;
			part.lastLineLength = -1;
		}
	}
	,wrappedAt: function(index,config,parsedCode,indenter) {
		return this.wrapNormal(config,parsedCode,indenter);
	}
	,wrapNormal: function(config,parsedCode,indenter) {
		if(this.parts.length <= 0) {
			return [this];
		}
		var line = new formatter_codedata_CodeLine(this.indent);
		var part = this.parts.shift();
		line.parts = [part];
		var lineLength = indenter.calcAbsoluteIndent(this.indent) + part.text.length;
		var lines = [line];
		var lastPart = part;
		while(this.parts.length > 0) {
			var p = this.parts.shift();
			var partLength = p.firstLineLength;
			if(!p.multiLine) {
				partLength = StringTools.rtrim(p.text).length;
			}
			if(lineLength + partLength >= config.maxLineLength) {
				parsedCode.tokenList.lineEndAfter(lastPart.lastToken);
				var info = parsedCode.tokenList.getTokenAt(p.firstToken.index);
				var additionalIndent = 0;
				if(info != null) {
					additionalIndent = info.additionalIndent;
				}
				var newIndent = indenter.calcIndent(p.firstToken) + additionalIndent;
				line = new formatter_codedata_CodeLine(newIndent);
				lineLength = indenter.calcAbsoluteIndent(newIndent);
				lines.push(line);
			}
			line.parts.push(p);
			if(p.lastLineLength <= 0) {
				lineLength += p.firstLineLength;
			} else {
				lineLength += p.lastLineLength;
			}
			lastPart = p;
		}
		line.emptyLinesAfter = this.emptyLinesAfter;
		return lines;
	}
	,print: function(indenter,lineSeparator) {
		var line = "";
		var _g = 0;
		var _g1 = this.parts;
		while(_g < _g1.length) {
			var part = _g1[_g];
			++_g;
			line += part.text;
		}
		line = indenter.makeIndentString(this.indent) + StringTools.rtrim(line);
		var _g2 = 0;
		var _g3 = this.emptyLinesAfter;
		while(_g2 < _g3) {
			var index = _g2++;
			line += lineSeparator;
			if(indenter.shouldAddTrailingWhitespace()) {
				line += indenter.makeIndentString(this.indent);
			}
		}
		return line;
	}
};
var formatter_codedata_CodeLines = function(parsedCode,indenter) {
	this.lines = [];
	this.indenter = indenter;
	this.parsedCode = parsedCode;
	this.buildLines();
};
formatter_codedata_CodeLines.__name__ = true;
formatter_codedata_CodeLines.prototype = {
	buildLines: function() {
		var line = null;
		var index = 0;
		while(index < this.parsedCode.tokenList.tokens.length) {
			var tokenInfo = this.parsedCode.tokenList.getTokenAt(index);
			if(tokenInfo == null) {
				++index;
				continue;
			}
			var _g = tokenInfo.token.tok;
			if(_g._hx_index == 7) {
				if(_g.s == " @formatter:off") {
					line = null;
					index = this.skipFormatterOff(index);
					continue;
				}
			}
			if(line == null) {
				line = new formatter_codedata_CodeLine(this.indenter.calcIndent(tokenInfo.token) + tokenInfo.additionalIndent);
				this.lines.push(line);
			}
			line.addToken(tokenInfo,this.parsedCode.lineSeparator);
			if(tokenInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				line = null;
			}
			++index;
		}
	}
	,skipFormatterOff: function(index) {
		var startInfo = this.parsedCode.tokenList.getTokenAt(index++);
		var startLine = this.parsedCode.getLinePos(startInfo.token.pos.min).line;
		while(index < this.parsedCode.tokenList.tokens.length) {
			var tokenInfo = this.parsedCode.tokenList.getTokenAt(index++);
			if(tokenInfo == null) {
				continue;
			}
			var _g = tokenInfo.token.tok;
			if(_g._hx_index == 7) {
				if(_g.s == " @formatter:on") {
					var endLine = this.parsedCode.getLinePos(tokenInfo.token.pos.max).line;
					this.copyVerbatim(startLine,endLine);
					return index;
				}
			}
		}
		var endLine1 = this.parsedCode.lines.length - 1;
		this.copyVerbatim(startLine,endLine1);
		return index;
	}
	,copyVerbatim: function(startLine,endLine) {
		var startOffs = this.parsedCode.linesIdx[startLine].l;
		var endOffs = this.parsedCode.linesIdx[endLine].r;
		var content = this.parsedCode.getString(startOffs,endOffs);
		if(endLine < this.parsedCode.lines.length - 1) {
			content = StringTools.rtrim(content);
		}
		this.lines.push(new formatter_codedata_VerbatimCodeLine(content));
	}
	,applyWrapping: function(config) {
		var wrappedLines = [];
		var _g = 0;
		var _g1 = this.lines;
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			var wrappedCode = line.applyWrapping(config,this.parsedCode,this.indenter);
			wrappedLines = wrappedLines.concat(wrappedCode);
		}
		this.lines = wrappedLines;
	}
	,print: function(lineSeparator) {
		var _gthis = this;
		var prefix = "";
		if(this.parsedCode.tokenList.leadingEmptyLInes > 0) {
			prefix = StringTools.lpad("",lineSeparator,lineSeparator.length * this.parsedCode.tokenList.leadingEmptyLInes);
		}
		return prefix + this.lines.map(function(line) {
			return line.print(_gthis.indenter,lineSeparator);
		}).join(lineSeparator);
	}
};
var formatter_codedata_ParsedCode = function(inputData) {
	this.file = { name : inputData.fileName, content : inputData.content};
	try {
		this.removeBOM();
		if(inputData.lineSeparator == null) {
			this.detectLineSeparator();
		} else {
			this.lineSeparator = inputData.lineSeparator;
		}
		this.makeLines();
		this.makePosIndices();
		if(inputData.tokenList == null) {
			this.makeTokens();
			this.getTokenTree(inputData.entryPoint);
		} else {
			this.tokens = inputData.tokenList;
			this.root = inputData.tokenTree;
			this.makeTokenList();
		}
		this.checkTokens();
	} catch( e ) {
		haxe_CallStack.lastException = e;
		throw new js__$Boot_HaxeError("failed to create parser context: " + Std.string(((e) instanceof js__$Boot_HaxeError) ? e.val : e));
	}
};
formatter_codedata_ParsedCode.__name__ = true;
formatter_codedata_ParsedCode.prototype = {
	checkTokens: function() {
		if(this.tokens.length != this.tokenList.tokens.length) {
			throw new js__$Boot_HaxeError("token count mismatch");
		}
		var skipCount = 0;
		var _g = 0;
		var _g1 = this.tokens.length;
		while(_g < _g1) {
			var index = _g++;
			var info = this.tokenList.tokens[index];
			if(info == null) {
				if(skipCount <= 0) {
					throw new js__$Boot_HaxeError("missing token \"" + Std.string(this.tokens[index]) + "\" [" + index + "] detected!");
				}
				--skipCount;
				continue;
			}
			var token = info.token;
			var _g2 = token.tok;
			switch(_g2._hx_index) {
			case 1:
				var _g3 = _g2.c;
				switch(_g3._hx_index) {
				case 0:
					var v = _g3.v;
					if(StringTools.startsWith(v,"-")) {
						skipCount = 1;
					}
					break;
				case 1:
					var v1 = _g3.f;
					if(StringTools.startsWith(v1,"-")) {
						skipCount = 1;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			case 5:
				var _g11 = _g2.op;
				switch(_g11._hx_index) {
				case 8:
					skipCount = 1;
					break;
				case 17:
					skipCount = 1;
					break;
				case 18:
					skipCount = 2;
					break;
				case 20:
					switch(_g11.op._hx_index) {
					case 17:
						skipCount = 2;
						break;
					case 18:
						skipCount = 3;
						break;
					default:
						skipCount = 0;
					}
					break;
				default:
					skipCount = 0;
				}
				break;
			default:
				skipCount = 0;
			}
		}
	}
	,getTokenTree: function(entryPoint) {
		if(this.tokens == null) {
			return null;
		}
		if(entryPoint == null) {
			entryPoint = tokentree_TokenTreeEntryPoint.TYPE_LEVEL;
		}
		if(this.root == null) {
			var this1 = this.file.content;
			this.root = tokentree_TokenTreeBuilder.buildTokenTree(this.tokens,this1,entryPoint);
			this.makeTokenList();
		}
		return this.root;
	}
	,removeBOM: function() {
		if(this.file.content == null || this.file.content.length <= 2) {
			return;
		}
		if(this.file.content.b[0] == 239 && this.file.content.b[1] == 187 && this.file.content.b[2] == 191) {
			var withBOM = this.file.content;
			this.file.content = withBOM.sub(3,this.file.content.length - 3);
		}
	}
	,makeTokenList: function() {
		this.tokenList = new formatter_codedata_TokenList();
		this.tokenList.buildList(this.root);
	}
	,makePosIndices: function() {
		var code = this.file.content;
		this.linesIdx = [];
		var last = 0;
		var left = false;
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			if(code.b[i] == 10) {
				this.linesIdx.push({ l : last, r : i});
				last = i + 1;
				left = false;
			}
			left = true;
		}
		if(left) {
			this.linesIdx.push({ l : last, r : code.length});
		}
	}
	,getLinePos: function(off) {
		var lowerBound = 0;
		var upperBound = this.linesIdx.length - 1;
		if(this.linesIdx.length <= 0) {
			throw new js__$Boot_HaxeError("Bad offset");
		}
		if(off < 0) {
			throw new js__$Boot_HaxeError("Bad offset");
		}
		if(off > this.linesIdx[upperBound].r) {
			throw new js__$Boot_HaxeError("Bad offset");
		}
		while(true) {
			if(lowerBound > upperBound) {
				throw new js__$Boot_HaxeError("Bad offset");
			}
			var center = lowerBound + Math.floor((upperBound - lowerBound) / 2);
			var matchLeft = this.linesIdx[center].l <= off;
			var matchRight = this.linesIdx[center].r >= off;
			if(matchLeft && matchRight) {
				return { line : center, ofs : off - this.linesIdx[center].l};
			}
			if(matchLeft) {
				lowerBound = center + 1;
				continue;
			}
			if(matchRight) {
				upperBound = center - 1;
				continue;
			}
		}
	}
	,getString: function(off,off2) {
		var code = this.file.content;
		var len = off2 - off;
		if(off >= code.length || off + len > code.length) {
			return "";
		}
		return code.sub(off,off2 - off).toString();
	}
	,isOriginalNewlineBefore: function(token) {
		if(token == null) {
			return false;
		}
		var prev = this.tokenList.getPreviousToken(token);
		if(prev == null) {
			return false;
		}
		return !this.isOriginalSameLine(prev.token,token);
	}
	,isOriginalSameLine: function(first,second) {
		var startLine = this.getLinePos(first.pos.min).line;
		var endLine = this.getLinePos(second.pos.min).line;
		return startLine == endLine;
	}
	,linesBetweenOriginal: function(first,second) {
		var startLine = this.getLinePos(first.pos.min).line;
		var endLine = this.getLinePos(second.pos.min).line;
		return endLine - startLine;
	}
	,detectLineSeparator: function() {
		var codeBytes = this.file.content;
		var code = codeBytes.toString();
		var _g = 0;
		var _g1 = code.length;
		while(_g < _g1) {
			var i = _g++;
			var char = code.charAt(i);
			if(char == "\r" || char == "\n") {
				this.lineSeparator = char;
				if(char == "\r" && i + 1 < code.length) {
					char = code.charAt(i + 1);
					if(char == "\n") {
						this.lineSeparator += char;
					}
				}
				return;
			}
		}
		this.lineSeparator = "\n";
	}
	,makeLines: function() {
		var code = this.file.content;
		var textCode = code.toString();
		this.lines = textCode.split(this.lineSeparator);
		this.emptyLines = [];
		var _g = 0;
		var _g1 = this.lines.length;
		while(_g < _g1) {
			var index = _g++;
			var line = this.lines[index];
			if(new EReg("^\\s*$","").match(line)) {
				this.emptyLines.push(index);
			}
		}
	}
	,makeTokens: function() {
		try {
			this.tokens = [];
			this.root = null;
			var this1 = this.file.content;
			var lexer = new haxeparser_HaxeLexer(this1,this.file.name);
			var t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				this.tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( e ) {
			haxe_CallStack.lastException = e;
			throw new js__$Boot_HaxeError("failed to make tokens " + Std.string(((e) instanceof js__$Boot_HaxeError) ? e.val : e));
		}
	}
};
var formatter_codedata_TokenList = function() {
	this.tokens = [];
	this.leadingEmptyLInes = 0;
	this.closeTokenCache = new haxe_ds_IntMap();
};
formatter_codedata_TokenList.__name__ = true;
formatter_codedata_TokenList.prototype = {
	buildList: function(token) {
		if(token.children == null) {
			return;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var index = child.index;
			if(index < 0 || child.inserted) {
				continue;
			}
			if(child.index >= this.tokens.length) {
				this.fill(child.index - this.tokens.length);
			}
			this.tokens[index] = { token : child, whitespaceAfter : formatter_codedata_WhitespaceAfterType.None, spacesBefore : 0, spacesAfter : 0, emptyLinesAfter : 0, wrapAfter : false, text : null, additionalIndent : 0};
			this.buildList(child);
		}
	}
	,fill: function(count) {
		while(count-- > 0) this.tokens.push(null);
	}
	,getCloseToken: function(token) {
		if(token == null || token.tok == null) {
			return null;
		}
		if(token.index < 0 || token.index >= this.tokens.length) {
			return null;
		}
		if(this.closeTokenCache.h.hasOwnProperty(token.index)) {
			return this.closeTokenCache.h[token.index];
		}
		var result;
		switch(token.tok._hx_index) {
		case 14:
			result = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.BkClose);
			break;
		case 16:
			result = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.BrClose);
			break;
		case 18:
			result = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.PClose);
			break;
		default:
			return null;
		}
		if(result == null) {
			return null;
		}
		this.closeTokenCache.h[token.index] = result;
		return result;
	}
	,getTokenAt: function(index) {
		if(index < 0 || index >= this.tokens.length) {
			return null;
		}
		return this.tokens[index];
	}
	,getPreviousToken: function(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		var prevToken = null;
		var prevIndex = token.index - 1;
		if(prevIndex >= this.tokens.length) {
			return null;
		}
		while(prevToken == null) {
			prevToken = this.tokens[prevIndex--];
			if(prevIndex < 0) {
				return null;
			}
		}
		return prevToken;
	}
	,getNextToken: function(token) {
		if(token == null || token.index <= 0) {
			return null;
		}
		var nextToken = null;
		var nextIndex = token.index + 1;
		if(nextIndex >= this.tokens.length) {
			return null;
		}
		while(nextToken == null) {
			nextToken = this.tokens[nextIndex++];
			if(nextIndex < 0) {
				return null;
			}
		}
		return nextToken;
	}
	,whitespace: function(token,where) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		var prev = null;
		var prevIndex = token.index - 1;
		while(prev == null) {
			if(prevIndex < 0) {
				break;
			}
			prev = this.tokens[prevIndex--];
		}
		if(prev != null && this.needsLineBreak(prev.token)) {
			prev = null;
		}
		switch(where) {
		case "after":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "around":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "before":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "none":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneAfter":
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "noneBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			break;
		case "onlyAfter":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.None);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.Space);
			break;
		case "onlyBefore":
			this.applyWhitespace(prev,formatter_codedata_WhitespaceAfterType.Space);
			this.applyWhitespace(info,formatter_codedata_WhitespaceAfterType.None);
			break;
		}
	}
	,applyWhitespace: function(info,policy) {
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = policy;
			switch(policy._hx_index) {
			case 0:
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		case 1:
			switch(policy._hx_index) {
			case 0:
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				info.spacesAfter = 0;
				break;
			case 1:
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				info.whitespaceAfter = policy;
				break;
			}
			break;
		case 2:
			switch(policy._hx_index) {
			case 0:
				if(info.spacesAfter > 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
					info.spacesAfter = 0;
				}
				break;
			case 1:
				info.whitespaceAfter = policy;
				this.shouldHaveOneSpaceAfter(info);
				break;
			case 2:
				break;
			}
			break;
		}
	}
	,shouldHaveOneSpaceAfter: function(info) {
		if(info == null) {
			return;
		}
		if(info.spacesAfter <= 0) {
			info.spacesAfter = 1;
		}
	}
	,spacesAfter: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.spacesAfter = count;
		if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.None && count > 0) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
		}
	}
	,spacesBefore: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.spacesBefore = count;
	}
	,lineEndAfter: function(token) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	,lineEndBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 1:
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			break;
		case 2:
			break;
		}
	}
	,needsLineBreak: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		if(_g._hx_index == 7) {
			var _g1 = _g.s;
			return true;
		}
		return false;
	}
	,noLineEndAfter: function(token) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	,noLineEndBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		if(this.needsLineBreak(info.token)) {
			info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Newline;
			return;
		}
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			return;
		case 1:
			break;
		case 2:
			if(info.spacesAfter <= 0) {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
			} else {
				info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				this.shouldHaveOneSpaceAfter(info);
			}
			break;
		}
	}
	,emptyLinesAfter: function(token,count) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,emptyLinesBefore: function(token,count) {
		if(token.index <= 0) {
			this.leadingEmptyLInes = count;
			return;
		}
		var info = this.getPreviousToken(token);
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,emptyLinesAfterSubTree: function(token,count) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return;
		}
		var info = this.tokens[lastToken.index];
		if(info == null) {
			return;
		}
		info.emptyLinesAfter = count;
	}
	,tokenText: function(token,text) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.text = text;
	}
	,wrapAfter: function(token,wrap) {
		if(token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.wrapAfter = wrap;
	}
	,wrapBefore: function(token,wrap) {
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		prev.wrapAfter = wrap;
	}
	,noWrappingBetween: function(tokenStart,tokenEnd,config,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		if(tokenStart == null || tokenEnd == null) {
			return;
		}
		var index = tokenStart.index;
		while(index < tokenEnd.index) {
			var first = index == tokenStart.index;
			var info = this.tokens[index++];
			var next = this.tokens[index];
			if(info == null) {
				continue;
			}
			var _g = info.token.tok;
			switch(_g._hx_index) {
			case 0:
				switch(_g.k._hx_index) {
				case 0:case 40:
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(info.token);
					if(lastChild != null) {
						if(lastChild.index > index) {
							index = lastChild.index;
						}
						continue;
					}
					break;
				default:
				}
				break;
			case 7:
				var _g2 = _g.s;
				continue;
			case 13:
				if(allowCommas) {
					continue;
				}
				break;
			case 14:
				if(!first) {
					var close = this.getCloseToken(info.token);
					if(close != null) {
						index = close.index;
						continue;
					}
				}
				break;
			case 16:
				if(!first) {
					var close1 = this.getCloseToken(info.token);
					if(close1 != null) {
						index = close1.index;
						continue;
					}
				}
				break;
			case 18:
				if(!first) {
					var close2 = this.getCloseToken(info.token);
					if(close2 != null) {
						index = close2.index;
						continue;
					}
				}
				break;
			default:
			}
			info.wrapAfter = false;
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 16:
					switch(config.lineEnds.leftCurly) {
					case "after":case "none":
						break;
					case "before":case "both":
						continue;
					}
					break;
				case 17:
					switch(config.lineEnds.rightCurly) {
					case "after":case "both":
						continue;
					case "before":case "none":
						break;
					}
					break;
				default:
				}
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				if(info.spacesAfter <= 0) {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.None;
				} else {
					info.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
					this.shouldHaveOneSpaceAfter(info);
				}
				break;
			}
		}
	}
	,additionalIndent: function(token,indent) {
		if(indent == null || token == null || token.index < 0) {
			return;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return;
		}
		info.additionalIndent = indent;
	}
	,increaseIndentBetween: function(start,end,depth) {
		if(depth == 0 || start == null || start.index < 0 || end == null || end.index < 0) {
			return;
		}
		var startIndex = start.index;
		if(depth > 0) {
			++startIndex;
		}
		var endIndex = end.index;
		var _g = startIndex;
		var _g1 = endIndex;
		while(_g < _g1) {
			var index = _g++;
			var info = this.tokens[index];
			if(info == null) {
				continue;
			}
			info.additionalIndent += depth;
		}
	}
	,findTokenAtOffset: function(offset) {
		var lastInfo = null;
		var _g = 0;
		var _g1 = this.tokens;
		while(_g < _g1.length) {
			var info = _g1[_g];
			++_g;
			if(info == null) {
				continue;
			}
			if(info.token.pos.min >= offset) {
				return lastInfo;
			}
			lastInfo = info;
		}
		return lastInfo;
	}
	,isSameLine: function(first,second) {
		var startIndex = first.index;
		var endIndex = second.index;
		if(startIndex == endIndex) {
			return true;
		}
		if(startIndex < 0 || endIndex < 0) {
			return false;
		}
		if(startIndex > endIndex) {
			startIndex = second.index;
			endIndex = first.index;
		}
		while(startIndex < endIndex) {
			var currTok = this.tokens[startIndex++];
			if(currTok == null) {
				continue;
			}
			if(currTok.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
		}
		return true;
	}
	,findLowestIndex: function(start) {
		var lowest = start;
		if(!start.hasChildren()) {
			return lowest;
		}
		var _g = 0;
		var _g1 = start.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var token = this.findLowestIndex(child);
			if(token.index < lowest.index) {
				lowest = token;
			}
		}
		return lowest;
	}
	,calcLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var current = this.tokens[token.index];
		if(current == null) {
			return 0;
		}
		var spaceAdd = 0;
		if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
			spaceAdd = 1;
		}
		if(current.text == null) {
			current.text = "" + Std.string(current.token);
		}
		var length = current.text.length + spaceAdd;
		if(token.children == null || token.children.length <= 0) {
			return length;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			length += this.calcLength(child);
		}
		return length;
	}
	,isMultilineToken: function(token) {
		if(token == null || token.index < 0) {
			return false;
		}
		var current = this.tokens[token.index];
		if(current == null) {
			return false;
		}
		if(current.text.indexOf("\r") >= 0 || current.text.indexOf("\n") >= 0) {
			return true;
		}
		return false;
	}
	,calcLengthUntilNewline: function(token,stop) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var endIndex = this.tokens.length - 1;
		if(stop != null) {
			endIndex = stop.index;
		}
		var index = token.index;
		var length = 0;
		while(index <= endIndex) {
			var current = this.tokens[index++];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			if(current.text.indexOf("\r") >= 0) {
				length += current.text.indexOf("\r");
				break;
			}
			if(current.text.indexOf("\n") >= 0) {
				length += current.text.indexOf("\n");
				break;
			}
			length += current.spacesBefore;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				length += current.spacesAfter;
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				break;
			}
		}
		return length;
	}
	,calcLengthBetween: function(tokenStart,tokenEnd) {
		if(tokenStart == null || tokenEnd == null) {
			return 0;
		}
		if(tokenStart.index < 0 || tokenEnd.index < 0) {
			return 0;
		}
		var length = 0;
		var _g = tokenStart.index;
		var _g1 = tokenEnd.index;
		while(_g < _g1) {
			var index = _g++;
			var current = this.tokens[index];
			if(current == null) {
				continue;
			}
			if(current.text == null) {
				current.text = "" + Std.string(current.token);
			}
			length += current.text.length;
			if(current.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Space) {
				++length;
			}
		}
		return length;
	}
	,calcLineLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index - 1;
		while(start >= 0) {
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				start += 2;
				break;
			}
		}
		var length = 0;
		_hx_loop2: while(start < this.tokens.length) {
			var info1 = this.tokens[start++];
			if(info1 == null) {
				continue;
			}
			length += info1.text.length;
			switch(info1.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info1.spacesAfter;
				break;
			case 2:
				break _hx_loop2;
			}
		}
		return length;
	}
	,calcLineLengthBefore: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index - 1;
		var length = 0;
		_hx_loop1: while(start >= 0) {
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
			length += info.text.length;
		}
		return length;
	}
	,calcLineLengthAfter: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var start = token.index + 1;
		var length = 0;
		_hx_loop1: while(start < this.tokens.length) {
			var info = this.tokens[start++];
			if(info == null) {
				continue;
			}
			var tokenLength = info.text.length;
			var linefeed = info.text.lastIndexOf("\r");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			linefeed = info.text.lastIndexOf("\n");
			if(linefeed >= 0) {
				tokenLength -= linefeed;
			}
			length += tokenLength;
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				length += info.spacesAfter;
				break;
			case 2:
				break _hx_loop1;
			}
		}
		return length;
	}
	,calcTokenLength: function(token) {
		if(token == null || token.index < 0) {
			return 0;
		}
		var info = this.tokens[token.index];
		if(info == null) {
			return 0;
		}
		var length = info.text.length;
		switch(info.whitespaceAfter._hx_index) {
		case 0:
			break;
		case 1:
			length += info.spacesAfter;
			break;
		case 2:
			break;
		}
		return length;
	}
	,isNewLineBefore: function(token) {
		var info = this.getPreviousToken(token);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	,isNewLineAfter: function(token) {
		var info = this.getTokenAt(token.index);
		if(info == null) {
			return false;
		}
		return info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline;
	}
	,isSameLineBetween: function(tokenStart,tokenEnd,exclude) {
		if(tokenStart == null || tokenEnd == null) {
			return true;
		}
		var start = tokenStart.index;
		var end = tokenEnd.index;
		if(exclude) {
			++start;
		}
		var _g = start;
		var _g1 = end;
		while(_g < _g1) {
			var index = _g++;
			var info = this.tokens[index];
			if(info == null) {
				continue;
			}
			if(info.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
				return false;
			}
			if(info.text == null) {
				continue;
			}
			if(info.text.indexOf("\r") >= 0 || info.text.indexOf("\n") >= 0) {
				return false;
			}
		}
		return true;
	}
	,findLineStartToken: function(token) {
		if(token == null || token.index < 0) {
			return null;
		}
		var start = token.index - 1;
		while(true) {
			if(start < 0) {
				return this.tokens[0].token;
			}
			var info = this.tokens[start--];
			if(info == null) {
				continue;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				return token;
			}
			token = info.token;
		}
	}
};
var formatter_codedata_VerbatimCodeLine = function(content) {
	formatter_codedata_CodeLine.call(this,0);
	this.content = content;
	this.verbatim = true;
};
formatter_codedata_VerbatimCodeLine.__name__ = true;
formatter_codedata_VerbatimCodeLine.__super__ = formatter_codedata_CodeLine;
formatter_codedata_VerbatimCodeLine.prototype = $extend(formatter_codedata_CodeLine.prototype,{
	applyWrapping: function(config,parsedCode,indenter) {
		return [this];
	}
	,print: function(indenter,lineSeparator) {
		return this.content;
	}
});
var formatter_codedata_WhitespaceAfterType = $hxEnums["formatter.codedata.WhitespaceAfterType"] = { __ename__ : true, __constructs__ : ["None","Space","Newline"]
	,None: {_hx_index:0,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Space: {_hx_index:1,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
	,Newline: {_hx_index:2,__enum__:"formatter.codedata.WhitespaceAfterType",toString:$estr}
};
var formatter_config_Config = function() {
	this.excludes = [];
	this.readConfigFromString("{}","hxformat.json");
};
formatter_config_Config.__name__ = true;
formatter_config_Config.prototype = {
	readConfig: function(fileName) {
		if(!sys_FileSystem.exists(fileName)) {
			return;
		}
		this.readConfigFromString(js_node_Fs.readFileSync(fileName,{ encoding : "utf8"}),fileName);
	}
	,readConfigFromString: function(jsonContent,fileName) {
		var parser = new JsonParser_$1();
		var data = parser.fromJson(jsonContent,fileName);
		this.emptyLines = data.emptyLines;
		this.indentation = data.indentation;
		this.lineEnds = data.lineEnds;
		this.sameLine = data.sameLine;
		this.whitespace = data.whitespace;
		this.wrapping = data.wrapping;
		this.disableFormatting = data.disableFormatting;
		this.excludes = [];
		this.configFileName = fileName;
		var _g = 0;
		var _g1 = data.excludes;
		while(_g < _g1.length) {
			var exclude = _g1[_g];
			++_g;
			this.excludes.push(new EReg(exclude,""));
		}
	}
	,isExcluded: function(fileName) {
		var _g = 0;
		var _g1 = this.excludes;
		while(_g < _g1.length) {
			var exclude = _g1[_g];
			++_g;
			if(exclude.match(fileName)) {
				return true;
			}
		}
		return false;
	}
};
var formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$ = {};
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.__name__ = true;
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove = function(policy,removePolicy) {
	switch(removePolicy) {
	case "after":
		break;
	case "around":
		return "none";
	case "before":
		break;
	case "none":
		return policy;
	case "noneAfter":
		removePolicy = "after";
		break;
	case "noneBefore":
		removePolicy = "before";
		break;
	case "onlyAfter":
		removePolicy = "after";
		break;
	case "onlyBefore":
		removePolicy = "before";
		break;
	}
	switch(policy) {
	case "after":
		if(removePolicy == "after") {
			return "none";
		}
		break;
	case "around":
		if(removePolicy == "before") {
			return "after";
		}
		if(removePolicy == "after") {
			return "before";
		}
		break;
	case "before":
		if(removePolicy == "before") {
			return "none";
		}
		break;
	case "none":
		return "none";
	case "noneAfter":
		return "noneAfter";
	case "noneBefore":
		return "noneBefore";
	case "onlyAfter":
		if(removePolicy == "after") {
			return "none";
		}
		break;
	case "onlyBefore":
		if(removePolicy == "before") {
			return "none";
		}
		break;
	}
	return policy;
};
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add = function(policy,addPolicy) {
	switch(addPolicy) {
	case "after":
		break;
	case "around":
		return "none";
	case "before":
		break;
	case "none":
		return policy;
	case "noneAfter":
		addPolicy = "after";
		break;
	case "noneBefore":
		addPolicy = "before";
		break;
	case "onlyAfter":
		addPolicy = "after";
		break;
	case "onlyBefore":
		addPolicy = "before";
		break;
	}
	switch(policy) {
	case "after":
		if(addPolicy == "before") {
			return "around";
		}
		break;
	case "around":
		break;
	case "before":
		if(addPolicy == "after") {
			return "around";
		}
		break;
	case "none":
		return addPolicy;
	case "noneAfter":
		if(addPolicy == "before") {
			return "onlyBefore";
		}
		if(addPolicy == "after") {
			return "onlyAfter";
		}
		break;
	case "noneBefore":
		if(addPolicy == "before") {
			return "onlyBefore";
		}
		if(addPolicy == "after") {
			return "onlyAfter";
		}
		break;
	case "onlyAfter":
		if(addPolicy == "before") {
			return "around";
		}
		break;
	case "onlyBefore":
		if(addPolicy == "after") {
			return "around";
		}
		break;
	}
	return policy;
};
var formatter_marker_Indenter = function(config) {
	this.config = config;
	if(config.character.toLowerCase() == "tab") {
		config.character = "\t";
	}
};
formatter_marker_Indenter.__name__ = true;
formatter_marker_Indenter.prototype = {
	setParsedCode: function(parsedCode) {
		this.parsedCode = parsedCode;
	}
	,makeIndent: function(token) {
		return this.makeIndentString(this.calcIndent(token));
	}
	,makeIndentString: function(count) {
		return StringTools.lpad("",this.config.character,this.config.character.length * count);
	}
	,calcAbsoluteIndent: function(indent) {
		if(this.config.character == "\t") {
			return indent * this.config.tabWidth;
		}
		return indent * this.config.character.length;
	}
	,calcIndent: function(token) {
		if(token == null) {
			return 0;
		}
		var _g = token.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.s;
			if(this.config.conditionalPolicy == "fixedZero") {
				return 0;
			}
		}
		token = this.findEffectiveParent(token);
		return this.calcFromCandidates(token);
	}
	,shouldAddTrailingWhitespace: function() {
		return this.config.trailingWhitespace;
	}
	,findEffectiveParent: function(token) {
		if(token.tok == null) {
			return token.getFirstChild();
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				var parent = token.parent;
				if(parent.tok == null) {
					return token;
				}
				if(parent.tok._hx_index == 18) {
					if(this.parsedCode.tokenList.isNewLineBefore(token)) {
						return token;
					}
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 3:
				var prev = this.parsedCode.tokenList.getPreviousToken(token);
				if(prev == null) {
					return token;
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return token;
				}
				var parent1 = token.parent;
				if(parent1.tok == null) {
					return token;
				}
				var _g1 = parent1.tok;
				switch(_g1._hx_index) {
				case 0:
					if(_g1.k._hx_index != 4) {
						return token;
					}
					break;
				case 5:
					var _g11 = _g1.op;
					return token;
				default:
				}
				return this.findEffectiveParent(token.parent);
			case 5:
				var parent2 = token.parent;
				if(parent2.tok == null) {
					return token;
				}
				if(parent2 != null && parent2.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDo))) {
					return this.findEffectiveParent(token.parent);
				}
				break;
			case 4:case 21:
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 2:
			switch(_g.s) {
			case "else":case "elseif":case "end":
				return this.findEffectiveParent(token.parent);
			default:
			}
			break;
		case 6:
			var _g4 = _g.s;
			var next = this.parsedCode.tokenList.getNextToken(token);
			if(next == null) {
				return token;
			}
			var _g2 = next.token.tok;
			if(_g2._hx_index == 0) {
				switch(_g2.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next.token);
				case 21:
					return this.findEffectiveParent(next.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 7:
			var _g3 = _g.s;
			var next1 = this.parsedCode.tokenList.getNextToken(token);
			if(next1 == null) {
				return token;
			}
			var _g5 = next1.token.tok;
			if(_g5._hx_index == 0) {
				switch(_g5.k._hx_index) {
				case 4:
					return this.findEffectiveParent(next1.token);
				case 21:
					return this.findEffectiveParent(next1.token);
				default:
					return token;
				}
			} else {
				return token;
			}
			break;
		case 12:
			return this.findEffectiveParent(token.parent);
		case 16:
			var parent3 = token.parent;
			if(parent3.tok == null) {
				return token;
			}
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				return token.parent;
			case 2:
				return token;
			case 3:
				return token;
			case 4:
				break;
			}
			var _g6 = parent3.tok;
			switch(_g6._hx_index) {
			case 0:
				switch(_g6.k._hx_index) {
				case 0:
					return this.findEffectiveParent(parent3);
				case 3:case 4:
					return this.findEffectiveParent(parent3);
				case 5:case 6:case 7:
					return this.findEffectiveParent(parent3);
				case 14:
					return this.findEffectiveParent(parent3);
				case 20:case 21:
					return this.findEffectiveParent(parent3);
				case 22:
					if(parent3.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFunction))) {
						return this.findEffectiveParent(parent3.parent);
					}
					break;
				default:
				}
				break;
			case 1:
				var _g41 = _g6.c;
				if(_g41._hx_index == 3) {
					var _g51 = _g41.s;
					if(parent3.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFunction))) {
						return this.findEffectiveParent(parent3.parent);
					}
				}
				break;
			case 5:
				var _g12 = _g6.op;
				switch(_g12._hx_index) {
				case 4:
					var access = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(parent3)),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access != null) {
						return access;
					}
					break;
				case 20:
					var _g21 = _g12.op;
					var access1 = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(parent3)),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTypedef));
					if(access1 != null) {
						return access1;
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 15:case 17:
			return this.findEffectiveParent(token.parent);
		case 19:
			return this.findEffectiveParent(token.parent);
		default:
		}
		return token;
	}
	,countLineBreaks: function(indentingTokensCandidates,indentComplexValueExpressions) {
		var count = 0;
		var prevToken = null;
		var currentToken = null;
		var mustIndent;
		var lastIndentingToken = null;
		var _g = 0;
		while(_g < indentingTokensCandidates.length) {
			var token = indentingTokensCandidates[_g];
			++_g;
			prevToken = currentToken;
			if(prevToken == null) {
				prevToken = token;
			}
			currentToken = token;
			mustIndent = false;
			var _g1 = prevToken.tok;
			switch(_g1._hx_index) {
			case 0:
				switch(_g1.k._hx_index) {
				case 0:
					if(currentToken.is(haxeparser_TokenDef.POpen) && !this.parsedCode.tokenList.isNewLineAfter(currentToken)) {
						continue;
					}
					break;
				case 3:
					if(prevToken.index == currentToken.index) {
						continue;
					}
					var _g2 = currentToken.tok;
					if(_g2._hx_index == 5) {
						if(_g2.op._hx_index == 4) {
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						} else if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
							var elseTok = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(prevToken,haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse));
							if(elseTok != null) {
								if(this.parsedCode.tokenList.isSameLineBetween(prevToken,elseTok,false)) {
									continue;
								}
								if(indentComplexValueExpressions) {
									mustIndent = true;
								}
							}
							var brOpen = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(prevToken,haxeparser_TokenDef.BrOpen);
							if(brOpen != null) {
								var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
								if(type._hx_index == 0) {
									continue;
								}
							}
						}
					} else if(this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
						var elseTok1 = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(prevToken,haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse));
						if(elseTok1 != null) {
							if(this.parsedCode.tokenList.isSameLineBetween(prevToken,elseTok1,false)) {
								continue;
							}
							if(indentComplexValueExpressions) {
								mustIndent = true;
							}
						}
						var brOpen1 = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(prevToken,haxeparser_TokenDef.BrOpen);
						if(brOpen1 != null) {
							var type1 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen1);
							if(type1._hx_index == 0) {
								continue;
							}
						}
					}
					break;
				case 4:
					continue;
				case 14:
					var _g3 = currentToken.tok;
					switch(_g3._hx_index) {
					case 5:
						var op = _g3.op;
						if(indentComplexValueExpressions) {
							mustIndent = true;
						}
						break;
					case 18:
						var type2 = tokentree_utils_TokenTreeCheckUtils.getPOpenType(currentToken);
						switch(type2._hx_index) {
						case 0:
							break;
						case 1:
							mustIndent = true;
							break;
						case 2:
							break;
						case 3:
							mustIndent = true;
							break;
						case 4:
							break;
						case 5:
							break;
						}
						break;
					default:
					}
					break;
				case 15:case 16:
					if(!this.config.indentCaseLabels) {
						continue;
					}
					break;
				case 21:
					if(currentToken.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTry))) {
						continue;
					}
					break;
				default:
				}
				break;
			case 1:
				var _g21 = _g1.c;
				if(_g21._hx_index == 3) {
					switch(_g21.s) {
					case "from":case "to":
						if(this.isAbstractFromTo(token) && this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							mustIndent = true;
						}
						break;
					default:
					}
				}
				break;
			case 10:
				var _g4 = currentToken.tok;
				switch(_g4._hx_index) {
				case 0:
					switch(_g4.k._hx_index) {
					case 10:case 22:case 28:
						if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							continue;
						}
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 5:
					var _g11 = _g4.op;
					switch(_g11._hx_index) {
					case 4:
						break;
					case 20:
						var _g22 = _g11.op;
						break;
					default:
						if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
							++count;
							continue;
						}
					}
					break;
				case 10:
					if(!(prevToken.pos.min == currentToken.pos.min && this.parsedCode.tokenList.isNewLineBefore(currentToken))) {
						continue;
					}
					break;
				case 16:case 18:
					if(this.parsedCode.tokenList.isSameLine(currentToken,prevToken)) {
						continue;
					}
					mustIndent = true;
					break;
				default:
					if(this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						++count;
						continue;
					}
				}
				break;
			case 11:
				var _g5 = currentToken.tok;
				if(_g5._hx_index == 0) {
					switch(_g5.k._hx_index) {
					case 15:case 16:
						if(lastIndentingToken != null && lastIndentingToken.pos.min == prevToken.pos.min) {
							continue;
						}
						mustIndent = true;
						break;
					default:
					}
				}
				break;
			case 12:
				if(currentToken.is(haxeparser_TokenDef.POpen)) {
					continue;
				}
				break;
			case 16:
				var _g6 = currentToken.tok;
				switch(_g6._hx_index) {
				case 0:
					switch(_g6.k._hx_index) {
					case 0:case 3:case 4:case 5:case 6:case 7:case 10:case 14:case 20:case 21:case 28:
						var type3 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						if(type3._hx_index == 2) {
							var brClose = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose) && !this.config.indentObjectLiteral) {
								continue;
							}
						} else {
							continue;
						}
						break;
					default:
					}
					break;
				case 5:
					var _g12 = _g6.op;
					switch(_g12._hx_index) {
					case 4:
						var type4 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						switch(type4._hx_index) {
						case 1:
							continue;
						case 2:
							var brClose1 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose1 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose1) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					case 20:
						var _g23 = _g12.op;
						var type5 = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(prevToken);
						switch(type5._hx_index) {
						case 1:
							continue;
						case 2:
							var brClose2 = this.parsedCode.tokenList.getCloseToken(prevToken);
							if(brClose2 != null && !this.parsedCode.tokenList.isSameLine(prevToken,brClose2) && !this.config.indentObjectLiteral) {
								continue;
							}
							break;
						default:
						}
						break;
					default:
					}
					break;
				case 14:case 18:
					if(!this.parsedCode.tokenList.isNewLineBefore(prevToken)) {
						continue;
					}
					break;
				default:
				}
				break;
			default:
			}
			if(!mustIndent && this.parsedCode.tokenList.isSameLineBetween(currentToken,prevToken,false)) {
				continue;
			}
			if(!this.isIndentingToken(currentToken)) {
				continue;
			}
			lastIndentingToken = currentToken;
			++count;
		}
		return count;
	}
	,isFieldLevelVar: function(indentingTokensCandidates) {
		var tokens = indentingTokensCandidates.slice();
		tokens.reverse();
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			var _g1 = token.tok;
			switch(_g1._hx_index) {
			case 0:
				switch(_g1.k._hx_index) {
				case 0:
					return false;
				case 2:
					return true;
				case 41:
					break;
				default:
				}
				break;
			case 1:
				var _g3 = _g1.c;
				var tmp = _g3._hx_index == 3;
				break;
			case 5:
				if(_g1.op._hx_index == 4) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,calcFromCandidates: function(token) {
		var indentingTokensCandidates = this.findIndentingCandidates(token);
		if(indentingTokensCandidates.length <= 0) {
			return 0;
		}
		var indentComplexValueExpressions = this.config.indentComplexValueExpressions;
		if(this.isFieldLevelVar(indentingTokensCandidates)) {
			indentComplexValueExpressions = true;
		}
		if(indentComplexValueExpressions) {
			indentingTokensCandidates = this.compressElseIfCandidates(indentingTokensCandidates);
		}
		var count = this.countLineBreaks(indentingTokensCandidates,indentComplexValueExpressions);
		if(this.hasConditional(indentingTokensCandidates)) {
			switch(this.config.conditionalPolicy) {
			case "aligned":
				break;
			case "alignedDecrease":
				--count;
				break;
			case "alignedIncrease":
				break;
			case "fixedZero":
				break;
			}
		}
		return count;
	}
	,hasConditional: function(tokens) {
		var _g = 0;
		while(_g < tokens.length) {
			var token = tokens[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 2) {
				if(_g1.s == "if") {
					return true;
				}
			}
		}
		return false;
	}
	,findIndentingCandidates: function(token) {
		var indentingTokensCandidates = [];
		var lastIndentingToken = null;
		if(token.tok._hx_index == 10) {
			lastIndentingToken = token;
		}
		indentingTokensCandidates.push(token);
		var parent = token;
		while(parent.parent != null && parent.parent.tok != null) {
			parent = parent.parent;
			if(parent.pos.min > token.pos.min) {
				continue;
			}
			if(this.isIndentingToken(parent)) {
				if(lastIndentingToken != null) {
					if(lastIndentingToken.is(haxeparser_TokenDef.Dot) && parent.is(haxeparser_TokenDef.Dot)) {
						continue;
					}
				}
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			} else if(this.parsedCode.tokenList.isNewLineBefore(parent)) {
				indentingTokensCandidates.push(parent);
				lastIndentingToken = parent;
			}
		}
		return indentingTokensCandidates;
	}
	,compressElseIfCandidates: function(indentingTokensCandidates) {
		var compressedCandidates = [];
		var state = formatter_marker_IndentationCompressElseIf.Copy;
		var _g = 0;
		while(_g < indentingTokensCandidates.length) {
			var token = indentingTokensCandidates[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 0) {
				switch(_g1.k._hx_index) {
				case 3:
					switch(state._hx_index) {
					case 0:
						if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse)) != null) {
							state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						}
						break;
					case 1:
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						break;
					case 2:
						continue;
					}
					break;
				case 4:
					if(state == formatter_marker_IndentationCompressElseIf.SeenElse || state == formatter_marker_IndentationCompressElseIf.SkipElseIf) {
						state = formatter_marker_IndentationCompressElseIf.SkipElseIf;
						continue;
					}
					state = formatter_marker_IndentationCompressElseIf.SeenElse;
					break;
				default:
					state = formatter_marker_IndentationCompressElseIf.Copy;
				}
			} else {
				state = formatter_marker_IndentationCompressElseIf.Copy;
			}
			compressedCandidates.push(token);
		}
		return compressedCandidates;
	}
	,isIndentingToken: function(token) {
		if(token == null) {
			return false;
		}
		var _g = token.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				return true;
			case 2:
				return true;
			case 3:case 4:
				return true;
			case 5:
				var parent = token.parent;
				if(parent != null && parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDo))) {
					return false;
				}
				return true;
			case 6:case 7:
				return true;
			case 10:case 28:
				return true;
			case 14:case 15:case 16:
				return true;
			case 20:case 21:case 24:
				return true;
			case 22:
				var _g1 = token.parent.tok;
				if(_g1._hx_index == 0) {
					if(_g1.k._hx_index == 0) {
						return false;
					} else {
						return true;
					}
				} else {
					return true;
				}
				break;
			default:
			}
			break;
		case 1:
			var _g5 = _g.c;
			if(_g5._hx_index == 3) {
				switch(_g5.s) {
				case "from":case "to":
					return this.isAbstractFromTo(token);
				default:
				}
			}
			break;
		case 2:
			if(_g.s == "if") {
				switch(this.config.conditionalPolicy) {
				case "aligned":
					return false;
				case "alignedDecrease":case "alignedIncrease":
					return true;
				case "fixedZero":
					return false;
				}
			}
			break;
		case 5:
			var _g11 = _g.op;
			switch(_g11._hx_index) {
			case 4:
				return true;
			case 9:
				return tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token);
			case 20:
				var _g2 = _g11.op;
				return true;
			default:
			}
			break;
		case 11:
			if(token.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdCase)) || token.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDefault))) {
				return true;
			}
			var info = this.parsedCode.tokenList.getTokenAt(token.index);
			if(info == null) {
				return false;
			}
			switch(info.whitespaceAfter._hx_index) {
			case 0:case 1:
				return false;
			case 2:
				return true;
			}
			break;
		case 12:
			return true;
		case 10:case 14:case 16:case 18:
			return true;
		default:
		}
		return false;
	}
	,isAbstractFromTo: function(token) {
		var parent = token.parent;
		if(parent == null || parent.tok == null) {
			return false;
		}
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
			} else {
				return false;
			}
		} else {
			return false;
		}
		parent = parent.parent;
		if(parent == null || parent.tok == null) {
			return false;
		}
		var _g3 = parent.tok;
		if(_g3._hx_index == 0) {
			if(_g3.k._hx_index == 39) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
};
var formatter_marker_IndentationCompressElseIf = $hxEnums["formatter.marker.IndentationCompressElseIf"] = { __ename__ : true, __constructs__ : ["Copy","SeenElse","SkipElseIf"]
	,Copy: {_hx_index:0,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SeenElse: {_hx_index:1,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
	,SkipElseIf: {_hx_index:2,__enum__:"formatter.marker.IndentationCompressElseIf",toString:$estr}
};
var formatter_marker_MarkerBase = function(config,parsedCode,indenter) {
	this.config = config;
	this.parsedCode = parsedCode;
	this.indenter = indenter;
};
formatter_marker_MarkerBase.__name__ = true;
formatter_marker_MarkerBase.prototype = {
	getCloseToken: function(token) {
		return this.parsedCode.tokenList.getCloseToken(token);
	}
	,getNextToken: function(token) {
		return this.parsedCode.tokenList.getNextToken(token);
	}
	,getPreviousToken: function(token) {
		return this.parsedCode.tokenList.getPreviousToken(token);
	}
	,getTokenInfo: function(token) {
		return this.parsedCode.tokenList.getTokenAt(token.index);
	}
	,getTokenAt: function(index) {
		return this.parsedCode.tokenList.getTokenAt(index);
	}
	,whitespace: function(token,where) {
		this.parsedCode.tokenList.whitespace(token,where);
	}
	,spacesAfter: function(token,count) {
		this.parsedCode.tokenList.spacesAfter(token,count);
	}
	,spacesBefore: function(token,count) {
		this.parsedCode.tokenList.spacesBefore(token,count);
	}
	,lineEndAfter: function(token) {
		this.parsedCode.tokenList.lineEndAfter(token);
	}
	,lineEndBefore: function(token) {
		this.parsedCode.tokenList.lineEndBefore(token);
	}
	,noLineEndAfter: function(token) {
		this.parsedCode.tokenList.noLineEndAfter(token);
	}
	,noLineEndBefore: function(token) {
		this.parsedCode.tokenList.noLineEndBefore(token);
	}
	,emptyLinesAfter: function(token,count) {
		this.parsedCode.tokenList.emptyLinesAfter(token,count);
	}
	,emptyLinesBefore: function(token,count) {
		this.parsedCode.tokenList.emptyLinesBefore(token,count);
	}
	,emptyLinesAfterSubTree: function(token,count) {
		this.parsedCode.tokenList.emptyLinesAfterSubTree(token,count);
	}
	,tokenText: function(token,text) {
		this.parsedCode.tokenList.tokenText(token,text);
	}
	,wrapAfter: function(token,wrap) {
		this.parsedCode.tokenList.wrapAfter(token,wrap);
	}
	,wrapBefore: function(token,wrap) {
		this.parsedCode.tokenList.wrapBefore(token,wrap);
	}
	,noWrappingBetween: function(tokenStart,tokenEnd,allowCommas) {
		if(allowCommas == null) {
			allowCommas = true;
		}
		this.parsedCode.tokenList.noWrappingBetween(tokenStart,tokenEnd,this.config,allowCommas);
	}
	,additionalIndent: function(token,indent) {
		this.parsedCode.tokenList.additionalIndent(token,indent);
	}
	,increaseIndentBetween: function(start,end,depth) {
		this.parsedCode.tokenList.increaseIndentBetween(start,end,depth);
	}
	,findTokenAtOffset: function(offset) {
		return this.parsedCode.tokenList.findTokenAtOffset(offset);
	}
	,isSameLine: function(first,second) {
		return this.parsedCode.tokenList.isSameLine(first,second);
	}
	,calcLength: function(token) {
		return this.parsedCode.tokenList.calcLength(token);
	}
	,isMultilineToken: function(token) {
		return this.parsedCode.tokenList.isMultilineToken(token);
	}
	,calcLengthUntilNewline: function(token,stop) {
		return this.parsedCode.tokenList.calcLengthUntilNewline(token,stop);
	}
	,calcLengthBetween: function(tokenStart,tokenEnd) {
		return this.parsedCode.tokenList.calcLengthBetween(tokenStart,tokenEnd);
	}
	,calcLineLength: function(token) {
		return this.parsedCode.tokenList.calcLineLength(token);
	}
	,calcLineLengthBefore: function(token) {
		return this.parsedCode.tokenList.calcLineLengthBefore(token);
	}
	,calcLineLengthAfter: function(token) {
		return this.parsedCode.tokenList.calcLineLengthAfter(token);
	}
	,calcTokenLength: function(token) {
		return this.parsedCode.tokenList.calcTokenLength(token);
	}
	,isNewLineBefore: function(token) {
		return this.parsedCode.tokenList.isNewLineBefore(token);
	}
	,isNewLineAfter: function(token) {
		return this.parsedCode.tokenList.isNewLineAfter(token);
	}
	,isSameLineBetween: function(tokenStart,tokenEnd,exclude) {
		return this.parsedCode.tokenList.isSameLineBetween(tokenStart,tokenEnd,exclude);
	}
	,findLineStartToken: function(token) {
		return this.parsedCode.tokenList.findLineStartToken(token);
	}
};
var formatter_marker_MarkAdditionalIndentation = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkAdditionalIndentation.__name__ = true;
formatter_marker_MarkAdditionalIndentation.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkAdditionalIndentation.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				if(_g.s == "if") {
					var tmp = _gthis.calcDepthDifferenceLeftCurly(token);
					_gthis.markBlockBreakingConditional(token,tmp);
					var tmp1 = _gthis.calcDepthDifferenceRightCurly(token);
					_gthis.markBlockBreakingConditional(token,tmp1);
				}
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
	}
	,markBlockBreakingConditional: function(token,depthDifference) {
		if(token.children == null) {
			return;
		}
		var start = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Sharp("end"));
		if(start == null) {
			return;
		}
		if(depthDifference == 0) {
			return;
		}
		if(depthDifference < 0) {
			start = token;
		}
		var parent = token.parent;
		var topLevelToken = null;
		while(parent != null && parent.tok != null) {
			topLevelToken = parent;
			parent = parent.parent;
		}
		console.log("src/formatter/marker/MarkAdditionalIndentation.hx:54:",Std.string(token.getPos()) + " -> " + Std.string(topLevelToken) + " " + depthDifference);
		if(topLevelToken == null) {
			return;
		}
		var sibling = topLevelToken.nextSibling;
		while(sibling != null) {
			console.log("src/formatter/marker/MarkAdditionalIndentation.hx:61:",sibling);
			var _g = sibling.tok;
			switch(_g._hx_index) {
			case 2:
				if(_g.s == "if") {
					depthDifference += this.calcDepthDifferenceLeftCurly(sibling) + this.calcDepthDifferenceRightCurly(sibling);
					console.log("src/formatter/marker/MarkAdditionalIndentation.hx:65:",depthDifference);
					sibling = sibling.nextSibling;
				} else {
					sibling = sibling.nextSibling;
				}
				break;
			case 17:
				this.increaseIndentBetween(start,sibling,depthDifference);
				return;
			default:
				sibling = sibling.nextSibling;
			}
		}
		this.increaseIndentBetween(start,tokentree_utils_TokenTreeCheckUtils.getLastToken(topLevelToken),depthDifference);
	}
	,calcDepthDifferenceLeftCurly: function(token) {
		if(token.children == null) {
			return 0;
		}
		var depthIncrease = 0;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var brOpens = child.filterCallback(function(token1,index) {
				var _g2 = token1.tok;
				switch(_g2._hx_index) {
				case 2:
					var _g11 = _g2.s;
					return tokentree_FilterResult.SKIP_SUBTREE;
				case 16:
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				default:
					return tokentree_FilterResult.GO_DEEPER;
				}
			});
			if(brOpens.length <= 0) {
				continue;
			}
			var depth = 0;
			var _g3 = 0;
			while(_g3 < brOpens.length) {
				var brOpen = brOpens[_g3];
				++_g3;
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(brOpen,haxeparser_TokenDef.BrClose) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthIncrease) {
				depthIncrease = depth;
			}
		}
		return depthIncrease;
	}
	,calcDepthDifferenceRightCurly: function(token) {
		if(token.children == null) {
			return 0;
		}
		var depthDecrease = 0;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var brClose = child.filterCallback(function(token1,index) {
				var _g2 = token1.tok;
				switch(_g2._hx_index) {
				case 2:
					if(_g2.s == "if") {
						return tokentree_FilterResult.SKIP_SUBTREE;
					} else {
						return tokentree_FilterResult.GO_DEEPER;
					}
					break;
				case 17:
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				default:
					return tokentree_FilterResult.GO_DEEPER;
				}
			});
			if(brClose.length <= 0) {
				continue;
			}
			var depth = 0;
			var _g3 = 0;
			while(_g3 < brClose.length) {
				var brClose1 = brClose[_g3];
				++_g3;
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(brClose1),haxeparser_TokenDef.BrOpen) != null) {
					continue;
				}
				++depth;
			}
			if(depth > depthDecrease) {
				depthDecrease = depth;
			}
		}
		return -depthDecrease;
	}
});
var formatter_marker_MarkEmptyLines = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkEmptyLines.__name__ = true;
formatter_marker_MarkEmptyLines.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkEmptyLines.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		this.keepExistingEmptyLines();
		var packs = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdPackage)],tokentree_TokenFilterMode.ALL);
		packs.reverse();
		var _g = 0;
		while(_g < packs.length) {
			var pack = packs[_g];
			++_g;
			if(tokentree_utils_TokenTreeCheckUtils.isMetadata(pack)) {
				continue;
			}
			this.emptyLinesBefore(pack,this.config.emptyLines.beforePackage);
			this.emptyLinesAfter(pack,this.config.emptyLines.afterPackage);
		}
		this.betweenTypes();
		this.markImports();
		this.markClassesAndAbstracts();
		this.markMacroClasses();
		this.markInterfaces();
		this.markEnums();
		this.markTypedefs();
		this.markSharp();
		if(this.config.emptyLines.beforeDocCommentEmptyLines != "ignore" || this.config.emptyLines.afterFieldsWithDocComments != "ignore") {
			this.markDocComments();
		}
		this.markMultilineComments();
		this.markFileHeader();
		if(this.config.emptyLines.beforeRightCurly == "remove") {
			this.markRightCurly();
		}
		if(this.config.emptyLines.afterLeftCurly == "remove") {
			this.markLeftCurly();
		}
		if(this.config.emptyLines.afterReturn == "remove") {
			this.markReturn();
		}
		if(this.config.emptyLines.beforeBlocks == "remove" || this.config.emptyLines.afterBlocks == "remove") {
			this.markAroundBlocks();
		}
	}
	,finalRun: function(codeLines) {
		if(codeLines.lines.length <= 0) {
			return;
		}
		var _g = 0;
		var _g1 = codeLines.lines;
		while(_g < _g1.length) {
			var line = _g1[_g];
			++_g;
			if(line.verbatim) {
				continue;
			}
			if(line.emptyLinesAfter > this.config.emptyLines.maxAnywhereInFile) {
				line.emptyLinesAfter = this.config.emptyLines.maxAnywhereInFile;
			}
		}
		var lastLine = codeLines.lines[codeLines.lines.length - 1];
		if(lastLine.verbatim) {
			return;
		}
		lastLine.emptyLinesAfter = this.config.emptyLines.finalNewline ? 1 : 0;
	}
	,markImports: function() {
		var imports = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 0) {
				switch(_g.k._hx_index) {
				case 13:case 35:
					if(tokentree_utils_TokenTreeCheckUtils.isMetadata(token)) {
						return tokentree_FilterResult.SKIP_SUBTREE;
					} else {
						return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
					}
					break;
				default:
					return tokentree_FilterResult.GO_DEEPER;
				}
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		if(imports.length <= 0) {
			return;
		}
		var lastImport = imports[imports.length - 1];
		var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(lastImport);
		var afterImport = this.getNextToken(lastChild);
		if(afterImport != null) {
			var _g1 = afterImport.token.tok;
			if(_g1._hx_index == 2) {
				switch(_g1.s) {
				case "else":case "elseif":
					break;
				case "end":
					this.emptyLinesAfterSubTree(afterImport.token,this.config.emptyLines.importAndUsing.beforeType);
					break;
				default:
					this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
				}
			} else {
				this.emptyLinesAfterSubTree(lastImport,this.config.emptyLines.importAndUsing.beforeType);
			}
		}
		lastImport = null;
		var prevInfo = null;
		var _g2 = 0;
		while(_g2 < imports.length) {
			var token1 = imports[_g2];
			++_g2;
			var newInfo = this.getImportInfo(token1);
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token1);
			var next = this.getNextToken(lastToken);
			if(next != null) {
				var _g3 = next.token.tok;
				if(_g3._hx_index == 2) {
					if(_g3.s == "end") {
						newInfo.token = next.token;
					}
				}
			}
			if(prevInfo == null) {
				prevInfo = newInfo;
				continue;
			}
			if(prevInfo.isImport == newInfo.isImport) {
				switch(this.config.emptyLines.importAndUsing.betweenImportsLevel) {
				case "all":
					this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					break;
				case "fifthLevelPackage":
					if(prevInfo.fifthLevelPackage != newInfo.fifthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "firstLevelPackage":
					if(prevInfo.firstLevelPackage != newInfo.firstLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fourthLevelPackage":
					if(prevInfo.fourthLevelPackage != newInfo.fourthLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "fullPackage":
					if(prevInfo.fullPackage != newInfo.fullPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "secondLevelPackage":
					if(prevInfo.secondLevelPackage != newInfo.secondLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				case "thirdLevelPackage":
					if(prevInfo.thirdLevelPackage != newInfo.thirdLevelPackage) {
						this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.betweenImports);
					}
					break;
				}
			} else {
				this.emptyLinesAfterSubTree(prevInfo.token,this.config.emptyLines.importAndUsing.beforeUsing);
			}
			prevInfo = newInfo;
		}
	}
	,getImportInfo: function(token) {
		var info = { token : token, isImport : false, firstLevelPackage : "", secondLevelPackage : "", thirdLevelPackage : "", fourthLevelPackage : "", fifthLevelPackage : "", fullPackage : "", moduleName : ""};
		var _g = token.tok;
		if(_g._hx_index == 0) {
			switch(_g.k._hx_index) {
			case 13:
				info.isImport = true;
				break;
			case 35:
				info.isImport = false;
				break;
			default:
			}
		}
		var parts = [];
		token = token.getFirstChild();
		while(true) {
			var _g2 = token.tok;
			switch(_g2._hx_index) {
			case 0:
				var _g5 = _g2.k;
				parts.push("" + Std.string(token));
				break;
			case 1:
				var _g3 = _g2.c;
				if(_g3._hx_index == 3) {
					var text = _g3.s;
					parts.push(text);
				}
				break;
			default:
			}
			token = token.getFirstChild();
			if(token == null || !token.is(haxeparser_TokenDef.Dot)) {
				break;
			}
			token = token.getFirstChild();
			if(token == null) {
				break;
			}
		}
		info.moduleName = parts.pop();
		info.fullPackage = parts.join(".");
		if(parts.length > 0) {
			info.firstLevelPackage = parts[0];
		}
		if(parts.length > 1) {
			info.secondLevelPackage = parts.slice(0,2).join(".");
		} else {
			info.secondLevelPackage = info.firstLevelPackage;
		}
		if(parts.length > 2) {
			info.thirdLevelPackage = parts.slice(0,3).join(".");
		} else {
			info.thirdLevelPackage = info.secondLevelPackage;
		}
		if(parts.length > 3) {
			info.fourthLevelPackage = parts.slice(0,4).join(".");
		} else {
			info.fourthLevelPackage = info.thirdLevelPackage;
		}
		if(parts.length > 4) {
			info.fifthLevelPackage = parts.slice(0,5).join(".");
		} else {
			info.fifthLevelPackage = info.fourthLevelPackage;
		}
		return info;
	}
	,markClassesAndAbstracts: function() {
		var classes = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 0) {
				switch(_g.k._hx_index) {
				case 1:case 39:
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				default:
					return tokentree_FilterResult.GO_DEEPER;
				}
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g1 = 0;
		while(_g1 < classes.length) {
			var c = classes[_g1];
			++_g1;
			if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(c)) {
				this.markEnumAbstracts(c);
				continue;
			}
			var typeConfig = null;
			var _g2 = c.tok;
			if(_g2._hx_index == 0) {
				switch(_g2.k._hx_index) {
				case 1:
					typeConfig = this.config.emptyLines.classEmptyLines;
					if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(c),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdExtern)) != null) {
						this.markExternClass(c,this.config.emptyLines.externClassEmptyLines);
						continue;
					}
					break;
				case 39:
					typeConfig = this.config.emptyLines.abstractEmptyLines;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
			var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(c),haxeparser_TokenDef.BrOpen);
			this.markBeginAndEndType(block,typeConfig.beginType,typeConfig.endType);
			var finalTokDef = haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFinal);
			var fields = this.findClassAndAbstractFields(c);
			var prevToken = null;
			var prevTokenType = null;
			var currToken = null;
			var currTokenType = null;
			var _g21 = 0;
			while(_g21 < fields.length) {
				var field = fields[_g21];
				++_g21;
				currToken = field;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.PRIVATE);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,typeConfig);
				prevToken = currToken;
				prevTokenType = currTokenType;
			}
		}
	}
	,markMacroClasses: function() {
		var classes = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 0) {
				if(_g.k._hx_index == 1) {
					if(token.parent == null || token.parent.tok == null) {
						return tokentree_FilterResult.GO_DEEPER;
					}
					var _g1 = token.parent.tok;
					if(_g1._hx_index == 0) {
						if(_g1.k._hx_index == 40) {
							return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
						} else {
							return tokentree_FilterResult.GO_DEEPER;
						}
					} else {
						return tokentree_FilterResult.GO_DEEPER;
					}
				} else {
					return tokentree_FilterResult.GO_DEEPER;
				}
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g2 = 0;
		while(_g2 < classes.length) {
			var c = classes[_g2];
			++_g2;
			var typeConfig = this.config.emptyLines.macroClassEmptyLines;
			var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(c),haxeparser_TokenDef.BrOpen);
			this.markBeginAndEndType(block,typeConfig.beginType,typeConfig.endType);
			var finalTokDef = haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFinal);
			var functions = this.findClassAndAbstractFields(c);
			var prevToken = null;
			var prevTokenType = null;
			var currToken = null;
			var currTokenType = null;
			var _g3 = 0;
			while(_g3 < functions.length) {
				var func = functions[_g3];
				++_g3;
				currToken = func;
				currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.PRIVATE);
				this.markClassFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType,typeConfig);
				prevToken = currToken;
				prevTokenType = currTokenType;
			}
		}
	}
	,findClassAndAbstractFields: function(c) {
		return c.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 0:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				case 41:
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				default:
					return tokentree_FilterResult.GO_DEEPER;
				}
				break;
			case 1:
				var _g2 = _g.c;
				if(_g2._hx_index == 3) {
					if(_g2.s == "final") {
						return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
					} else {
						return tokentree_FilterResult.GO_DEEPER;
					}
				} else {
					return tokentree_FilterResult.GO_DEEPER;
				}
				break;
			case 21:
				return tokentree_FilterResult.SKIP_SUBTREE;
			default:
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
	}
	,markBeginAndEndType: function(brOpen,beginType,endType) {
		if(brOpen == null) {
			return;
		}
		this.emptyLinesAfter(brOpen,beginType);
		var brClose = this.getCloseToken(brOpen);
		if(brClose == null) {
			return;
		}
		this.emptyLinesBefore(brClose,endType);
	}
	,markClassFieldEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		var prevStatic = false;
		var currStatic = false;
		var prevPrivate = false;
		var currPrivate = false;
		switch(prevTokenType._hx_index) {
		case 0:
			var isExtern = prevTokenType.isExtern;
			var isFinal = prevTokenType.isFinal;
			var isOverride = prevTokenType.isOverride;
			var isInline = prevTokenType.isInline;
			var isStatic = prevTokenType.isStatic;
			var visibility = prevTokenType.visibility;
			var name = prevTokenType.name;
			prevVar = false;
			prevStatic = isStatic;
			prevPrivate = visibility == tokentree_utils_TokenFieldVisibility.PRIVATE;
			break;
		case 1:
			var isExtern1 = prevTokenType.isExtern;
			var isFinal1 = prevTokenType.isFinal;
			var isInline1 = prevTokenType.isInline;
			var isStatic1 = prevTokenType.isStatic;
			var visibility1 = prevTokenType.visibility;
			var name1 = prevTokenType.name;
			prevVar = true;
			prevStatic = isStatic1;
			prevPrivate = visibility1 == tokentree_utils_TokenFieldVisibility.PRIVATE;
			break;
		case 2:
			var setter = prevTokenType.setter;
			var getter = prevTokenType.getter;
			var isStatic2 = prevTokenType.isStatic;
			var visibility2 = prevTokenType.visibility;
			var name2 = prevTokenType.name;
			prevVar = true;
			prevStatic = isStatic2;
			prevPrivate = visibility2 == tokentree_utils_TokenFieldVisibility.PRIVATE;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			var isExtern2 = currTokenType.isExtern;
			var isFinal2 = currTokenType.isFinal;
			var isOverride1 = currTokenType.isOverride;
			var isInline2 = currTokenType.isInline;
			var isStatic3 = currTokenType.isStatic;
			var visibility3 = currTokenType.visibility;
			var name3 = currTokenType.name;
			currVar = false;
			currStatic = isStatic3;
			currPrivate = visibility3 == tokentree_utils_TokenFieldVisibility.PRIVATE;
			break;
		case 1:
			var isExtern3 = currTokenType.isExtern;
			var isFinal3 = currTokenType.isFinal;
			var isInline3 = currTokenType.isInline;
			var isStatic4 = currTokenType.isStatic;
			var visibility4 = currTokenType.visibility;
			var name4 = currTokenType.name;
			currVar = true;
			currStatic = isStatic4;
			currPrivate = visibility4 == tokentree_utils_TokenFieldVisibility.PRIVATE;
			break;
		case 2:
			var setter1 = currTokenType.setter;
			var getter1 = currTokenType.getter;
			var isStatic5 = currTokenType.isStatic;
			var visibility5 = currTokenType.visibility;
			var name5 = currTokenType.name;
			currVar = true;
			currStatic = isStatic5;
			currPrivate = visibility5 == tokentree_utils_TokenFieldVisibility.PRIVATE;
			break;
		case 3:
			return;
		}
		if(!currVar) {
			this.markLineCommentsBefore(currToken,this.config.emptyLines.lineCommentsBetweenFunctions);
			this.markLineCommentsAfter(currToken,1);
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticVars);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticVars);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateVars);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			if(prevStatic != currStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterStaticFunctions);
				return;
			}
			if(prevStatic) {
				this.emptyLinesAfterSubTree(prevToken,conf.betweenStaticFunctions);
				return;
			}
			if(prevPrivate != currPrivate) {
				this.emptyLinesAfterSubTree(prevToken,conf.afterPrivateFunctions);
				return;
			}
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	,hasEmptyLinesBetweenFields: function(prevToken,currToken) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prevToken);
		if(lastToken == null) {
			return false;
		}
		var prevLine = this.parsedCode.getLinePos(lastToken.pos.max).line;
		var currLine = this.parsedCode.getLinePos(currToken.pos.min).line;
		var _g = 0;
		var _g1 = this.parsedCode.emptyLines;
		while(_g < _g1.length) {
			var emptyLine = _g1[_g];
			++_g;
			if(prevLine >= emptyLine) {
				continue;
			}
			if(currLine > emptyLine) {
				return true;
			}
			return false;
		}
		return false;
	}
	,markLineCommentsBefore: function(token,policy) {
		if(policy == "none") {
			return;
		}
		if(token.previousSibling == null) {
			return;
		}
		var prev = token.previousSibling;
		while(prev != null) {
			var _g = prev.tok;
			switch(_g._hx_index) {
			case 6:
				var _g2 = _g.s;
				break;
			case 7:
				var _g1 = _g.s;
				var prevInfo = this.getPreviousToken(prev);
				if(prevInfo == null || prevInfo.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					switch(policy) {
					case "keep":
						if(this.parsedCode.linesBetweenOriginal(prev,token) > 1) {
							this.emptyLinesAfter(prev,1);
						}
						break;
					case "none":
						break;
					case "one":
						this.emptyLinesAfter(prev,1);
						break;
					}
				}
				return;
			default:
				return;
			}
			prev = prev.previousSibling;
		}
	}
	,markLineCommentsAfter: function(token,count) {
		if(count <= 0) {
			return;
		}
		if(token.nextSibling == null) {
			return;
		}
		var next = token.nextSibling;
		var _g = next.tok;
		if(_g._hx_index == 7) {
			var _g1 = _g.s;
			if(this.isNewLineBefore(next)) {
				this.emptyLinesBefore(next,count);
			}
		}
	}
	,markExternClass: function(c,conf) {
		var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(c),haxeparser_TokenDef.BrOpen);
		if(block == null) {
			return;
		}
		this.markBeginAndEndType(block,conf.beginType,conf.endType);
		var finalTokDef = haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFinal);
		var fields = block.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFunction),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdVar),finalTokDef],tokentree_TokenFilterMode.FIRST);
		var prevToken = null;
		var prevTokenType = null;
		var currToken = null;
		var currTokenType = null;
		var _g = 0;
		while(_g < fields.length) {
			var field = fields[_g];
			++_g;
			currToken = field;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(field,tokentree_utils_TokenFieldVisibility.PUBLIC);
			this.markInterfaceEmptyLines(prevToken,prevTokenType,currToken,currTokenType,conf);
			prevToken = currToken;
			prevTokenType = currTokenType;
		}
	}
	,markInterfaces: function() {
		var interfaces = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdInterface)],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < interfaces.length) {
			var i = interfaces[_g];
			++_g;
			this.markExternClass(i,this.config.emptyLines.interfaceEmptyLines);
		}
	}
	,markInterfaceEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType,conf) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			var _g17 = prevTokenType.isExtern;
			var _g16 = prevTokenType.isFinal;
			var _g15 = prevTokenType.isOverride;
			var _g14 = prevTokenType.isInline;
			var _g13 = prevTokenType.isStatic;
			var _g12 = prevTokenType.visibility;
			var name = prevTokenType.name;
			prevVar = false;
			break;
		case 1:
			var _g5 = prevTokenType.isExtern;
			var _g4 = prevTokenType.isFinal;
			var _g3 = prevTokenType.isInline;
			var _g2 = prevTokenType.isStatic;
			var _g1 = prevTokenType.visibility;
			var name1 = prevTokenType.name;
			prevVar = true;
			break;
		case 2:
			var _g10 = prevTokenType.setter;
			var _g9 = prevTokenType.getter;
			var _g8 = prevTokenType.isStatic;
			var _g7 = prevTokenType.visibility;
			var name2 = prevTokenType.name;
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			var _g35 = currTokenType.isExtern;
			var _g34 = currTokenType.isFinal;
			var _g33 = currTokenType.isOverride;
			var _g32 = currTokenType.isInline;
			var _g31 = currTokenType.isStatic;
			var _g30 = currTokenType.visibility;
			var name3 = currTokenType.name;
			currVar = false;
			break;
		case 1:
			var _g23 = currTokenType.isExtern;
			var _g22 = currTokenType.isFinal;
			var _g21 = currTokenType.isInline;
			var _g20 = currTokenType.isStatic;
			var _g19 = currTokenType.visibility;
			var name4 = currTokenType.name;
			currVar = true;
			break;
		case 2:
			var _g28 = currTokenType.setter;
			var _g27 = currTokenType.getter;
			var _g26 = currTokenType.isStatic;
			var _g25 = currTokenType.visibility;
			var name5 = currTokenType.name;
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(conf.existingBetweenFields == "keep") {
			if(this.hasEmptyLinesBetweenFields(prevToken,currToken)) {
				this.emptyLinesAfterSubTree(prevToken,1);
				return;
			}
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,conf.betweenFunctions);
			return;
		}
	}
	,markEnumAbstracts: function(token) {
		var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token),haxeparser_TokenDef.BrOpen);
		this.markBeginAndEndType(block,this.config.emptyLines.enumAbstractEmptyLines.beginType,this.config.emptyLines.enumAbstractEmptyLines.endType);
		var functions = token.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFunction),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdVar)],tokentree_TokenFilterMode.FIRST);
		var prevToken = null;
		var prevTokenType = null;
		var currToken = null;
		var currTokenType = null;
		var _g = 0;
		while(_g < functions.length) {
			var func = functions[_g];
			++_g;
			currToken = func;
			currTokenType = tokentree_utils_FieldUtils.getFieldType(func,tokentree_utils_TokenFieldVisibility.PUBLIC);
			this.markEnumAbstractFieldEmptyLines(prevToken,prevTokenType,currToken,currTokenType);
			prevToken = currToken;
			prevTokenType = currTokenType;
		}
	}
	,markEnumAbstractFieldEmptyLines: function(prevToken,prevTokenType,currToken,currTokenType) {
		if(prevToken == null) {
			return;
		}
		var prevVar = false;
		var currVar = false;
		switch(prevTokenType._hx_index) {
		case 0:
			var isExtern = prevTokenType.isExtern;
			var isFinal = prevTokenType.isFinal;
			var isOverride = prevTokenType.isOverride;
			var isInline = prevTokenType.isInline;
			var isStatic = prevTokenType.isStatic;
			var visibility = prevTokenType.visibility;
			var name = prevTokenType.name;
			prevVar = false;
			break;
		case 1:
			var isExtern1 = prevTokenType.isExtern;
			var isFinal1 = prevTokenType.isFinal;
			var isInline1 = prevTokenType.isInline;
			var isStatic1 = prevTokenType.isStatic;
			var visibility1 = prevTokenType.visibility;
			var name1 = prevTokenType.name;
			prevVar = true;
			break;
		case 2:
			var setter = prevTokenType.setter;
			var getter = prevTokenType.getter;
			var isStatic2 = prevTokenType.isStatic;
			var visibility2 = prevTokenType.visibility;
			var name2 = prevTokenType.name;
			prevVar = true;
			break;
		case 3:
			return;
		}
		switch(currTokenType._hx_index) {
		case 0:
			var isExtern2 = currTokenType.isExtern;
			var isFinal2 = currTokenType.isFinal;
			var isOverride1 = currTokenType.isOverride;
			var isInline2 = currTokenType.isInline;
			var isStatic3 = currTokenType.isStatic;
			var visibility3 = currTokenType.visibility;
			var name3 = currTokenType.name;
			currVar = false;
			break;
		case 1:
			var isExtern3 = currTokenType.isExtern;
			var isFinal3 = currTokenType.isFinal;
			var isInline3 = currTokenType.isInline;
			var isStatic4 = currTokenType.isStatic;
			var visibility4 = currTokenType.visibility;
			var name4 = currTokenType.name;
			currVar = true;
			break;
		case 2:
			var setter1 = currTokenType.setter;
			var getter1 = currTokenType.getter;
			var isStatic5 = currTokenType.isStatic;
			var visibility5 = currTokenType.visibility;
			var name5 = currTokenType.name;
			currVar = true;
			break;
		case 3:
			return;
		}
		prevToken = this.skipSharpFields(prevToken);
		if(prevToken == null) {
			return;
		}
		if(prevVar != currVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.afterVars);
			return;
		}
		if(prevVar) {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenVars);
			return;
		} else {
			this.emptyLinesAfterSubTree(prevToken,this.config.emptyLines.enumAbstractEmptyLines.betweenFunctions);
			return;
		}
	}
	,markEnums: function() {
		var enums = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdEnum)],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < enums.length) {
			var e = enums[_g];
			++_g;
			if(e.parent.tok != null) {
				var _g1 = e.parent.tok;
				switch(_g1._hx_index) {
				case 1:
					var _g11 = _g1.c;
					continue;
				case 11:case 21:
					continue;
				default:
				}
			}
			var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(e),haxeparser_TokenDef.BrOpen);
			if(block == null) {
				continue;
			}
			this.markEnumFields(block,this.config.emptyLines.enumEmptyLines);
		}
	}
	,markEnumFields: function(block,config) {
		this.markBeginAndEndType(block,config.beginType,config.endType);
		if(block.children == null || block.children.length <= 0) {
			return;
		}
		var prevToken = null;
		var _g = 0;
		var _g1 = block.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 6:
				var _g21 = _g2.s;
				continue;
			case 7:
				var _g11 = _g2.s;
				continue;
			case 17:
				return;
			default:
			}
			if(prevToken == null) {
				prevToken = child;
				continue;
			}
			if(config.existingBetweenFields == "keep") {
				if(this.hasEmptyLinesBetweenFields(prevToken,child)) {
					this.emptyLinesAfterSubTree(prevToken,1);
					return;
				}
			}
			this.emptyLinesAfterSubTree(prevToken,config.betweenFields);
			prevToken = child;
		}
	}
	,markTypedefs: function() {
		var typedefs = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTypedef)],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < typedefs.length) {
			var t = typedefs[_g];
			++_g;
			var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(t),haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign)),haxeparser_TokenDef.BrOpen);
			if(block == null) {
				continue;
			}
			this.markEnumFields(block,this.config.emptyLines.typedefEmptyLines);
		}
	}
	,skipSharpFields: function(prevToken) {
		var next = prevToken.nextSibling;
		if(next == null) {
			next = prevToken.parent;
			var _g = next.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.s;
				next = next.nextSibling;
			} else {
				return prevToken;
			}
		}
		var _g2 = next.tok;
		if(_g2._hx_index == 2) {
			switch(_g2.s) {
			case "end":
				return next;
			case "if":
				return prevToken;
			default:
				return null;
			}
		}
		return prevToken;
	}
	,betweenTypes: function() {
		if(this.config.emptyLines.betweenTypes <= 0 && this.config.emptyLines.betweenSingleLineTypes <= 0) {
			return;
		}
		var types = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 0:
				switch(_g.k._hx_index) {
				case 0:case 2:
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				case 1:case 26:case 27:case 31:case 39:
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				case 41:
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				default:
					return tokentree_FilterResult.GO_DEEPER;
				}
				break;
			case 1:
				var _g2 = _g.c;
				if(_g2._hx_index == 3) {
					if(_g2.s == "final") {
						return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
					} else {
						return tokentree_FilterResult.GO_DEEPER;
					}
				} else {
					return tokentree_FilterResult.GO_DEEPER;
				}
				break;
			default:
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		if(types.length <= 1) {
			return;
		}
		var prevTypeInfo = null;
		var _g1 = 0;
		while(_g1 < types.length) {
			var type = types[_g1];
			++_g1;
			var newTypeInfo = this.getTypeInfo(type);
			this.markLineCommentsBefore(type,this.config.emptyLines.lineCommentsBetweenTypes);
			this.markLineCommentsAfter(type,1);
			if(prevTypeInfo == null) {
				prevTypeInfo = newTypeInfo;
				continue;
			}
			var next = this.getNextToken(prevTypeInfo.lastToken);
			if(next != null) {
				var _g3 = next.token.tok;
				if(_g3._hx_index == 2) {
					switch(_g3.s) {
					case "else":case "elseif":
						prevTypeInfo = newTypeInfo;
						continue;
					default:
					}
				}
			}
			var emptyLines = this.config.emptyLines.betweenTypes;
			if(prevTypeInfo.oneLine && newTypeInfo.oneLine) {
				emptyLines = this.config.emptyLines.betweenSingleLineTypes;
			}
			this.emptyLinesAfterSubTree(prevTypeInfo.lastToken,emptyLines);
			this.markLineCommentsAfter(prevTypeInfo.typeToken,1);
			prevTypeInfo = newTypeInfo;
		}
	}
	,getTypeInfo: function(token) {
		var info = { lastToken : tokentree_utils_TokenTreeCheckUtils.getLastToken(token), typeToken : token, oneLine : false};
		var start = this.parsedCode.tokenList.findLowestIndex(token);
		if(this.isSameLine(start,info.lastToken)) {
			info.oneLine = true;
		}
		while(true) {
			var next = this.getNextToken(info.lastToken);
			if(next == null) {
				break;
			}
			var _g = next.token.tok;
			if(_g._hx_index == 2) {
				if(_g.s == "end") {
					info.lastToken = next.token;
				} else {
					break;
				}
			} else {
				break;
			}
		}
		return info;
	}
	,markLeftCurly: function() {
		var brOpens = this.parsedCode.root.filter([haxeparser_TokenDef.BrOpen],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < brOpens.length) {
			var br = brOpens[_g];
			++_g;
			this.emptyLinesAfter(br,0);
		}
	}
	,markRightCurly: function() {
		var brCloses = this.parsedCode.root.filter([haxeparser_TokenDef.BrClose],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < brCloses.length) {
			var br = brCloses[_g];
			++_g;
			this.emptyLinesBefore(br,0);
		}
	}
	,markReturn: function() {
		var returns = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdReturn)],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < returns.length) {
			var ret = returns[_g];
			++_g;
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(ret);
			if(lastChild == null) {
				continue;
			}
			var next = this.getNextToken(lastChild);
			if(next == null) {
				continue;
			}
			if(next.token.tok._hx_index == 17) {
				this.emptyLinesAfterSubTree(ret,0);
			}
		}
	}
	,markSharp: function() {
		var sharps = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 2) {
				var _g1 = _g.s;
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g2 = 0;
		while(_g2 < sharps.length) {
			var sharp = sharps[_g2];
			++_g2;
			var prev = this.getPreviousToken(sharp);
			if(prev != null && prev.whitespaceAfter != formatter_codedata_WhitespaceAfterType.Newline) {
				continue;
			}
			var _g3 = sharp.tok;
			if(_g3._hx_index == 2) {
				switch(_g3.s) {
				case "else":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfter(sharp,this.config.emptyLines.conditionalsEmptyLines.afterElse);
					break;
				case "elseif":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeElse);
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				case "end":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeEnd);
					break;
				case "error":
					this.emptyLinesBefore(sharp,this.config.emptyLines.conditionalsEmptyLines.beforeError);
					this.emptyLinesAfterSubTree(sharp,this.config.emptyLines.conditionalsEmptyLines.afterError);
					break;
				case "if":
					this.emptyLinesAfterSubTree(sharp.getFirstChild(),this.config.emptyLines.conditionalsEmptyLines.afterIf);
					break;
				default:
				}
			}
		}
	}
	,markDocComments: function() {
		var comments = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 6) {
				var text = _g.s;
				if(StringTools.startsWith(text,"*")) {
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				} else {
					return tokentree_FilterResult.GO_DEEPER;
				}
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g1 = 0;
		while(_g1 < comments.length) {
			var comment = comments[_g1];
			++_g1;
			var effectiveToken = null;
			effectiveToken = comment;
			if(comment.previousSibling != null) {
				if(comment.parent != null && comment.parent.tok != null) {
					var _g2 = comment.parent.tok;
					if(_g2._hx_index == 2) {
						var _g11 = _g2.s;
						if(comment.parent.getFirstChild() == comment.previousSibling) {
							effectiveToken = comment.parent;
						}
					}
				}
			} else if(comment.parent == null || comment.parent.tok == null) {
				continue;
			}
			if(comment.nextSibling == null) {
				continue;
			}
			var next = comment.nextSibling;
			var found = true;
			while(next != null) {
				var _g3 = next.tok;
				switch(_g3._hx_index) {
				case 0:
					switch(_g3.k._hx_index) {
					case 0:
						break;
					case 1:
						break;
					case 2:
						break;
					case 26:
						break;
					case 27:
						break;
					case 31:
						break;
					case 39:
						break;
					case 41:
						break;
					default:
						found = false;
					}
					break;
				case 1:
					var _g31 = _g3.c;
					if(_g31._hx_index == 3) {
						var _g4 = _g31.s;
					} else {
						found = false;
					}
					break;
				case 2:
					var _g12 = _g3.s;
					next = null;
					break;
				case 7:
					var _g5 = _g3.s;
					next = next.nextSibling;
					continue;
				default:
					found = false;
				}
				break;
			}
			if(!found) {
				continue;
			}
			switch(this.config.emptyLines.beforeDocCommentEmptyLines) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesBefore(effectiveToken,0);
				break;
			case "one":
				this.emptyLinesBefore(effectiveToken,1);
				break;
			}
			if(next == null) {
				continue;
			}
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(next);
			var nextInfo = this.getNextToken(lastToken);
			if(nextInfo == null) {
				continue;
			}
			var _g13 = nextInfo.token.tok;
			if(_g13._hx_index == 2) {
				switch(_g13.s) {
				case "end":
					lastToken = nextInfo.token;
					break;
				case "error":
					break;
				case "if":
					break;
				default:
					continue;
				}
			}
			switch(this.config.emptyLines.afterFieldsWithDocComments) {
			case "ignore":
				break;
			case "none":
				this.emptyLinesAfter(lastToken,0);
				break;
			case "one":
				this.emptyLinesAfter(lastToken,1);
				break;
			}
		}
	}
	,markMultilineComments: function() {
		var comments = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 6) {
				var text = _g.s;
				return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g1 = 0;
		while(_g1 < comments.length) {
			var comment = comments[_g1];
			++_g1;
			var sibling = comment.nextSibling;
			if(sibling == null) {
				continue;
			}
			if(!this.isNewLineAfter(comment)) {
				continue;
			}
			var _g2 = sibling.tok;
			if(_g2._hx_index == 6) {
				var s = _g2.s;
				this.emptyLinesAfter(comment,this.config.emptyLines.betweenMultilineComments);
			} else {
				continue;
			}
		}
	}
	,markAroundBlocks: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 0) {
				switch(_g.k._hx_index) {
				case 0:
					break;
				case 3:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.previousSibling(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse)));
					if(block != null) {
						_gthis.removeEmptyLinesAroundBlock(block,"keep",_gthis.config.emptyLines.afterBlocks);
					}
					break;
				case 4:
					var tmp = token.getFirstChild();
					_gthis.removeEmptyLinesAroundBlock(tmp,_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 5:
					if(token.parent == null || !token.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDo))) {
						_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					}
					break;
				case 6:
					var tmp1 = token.getFirstChild();
					_gthis.removeEmptyLinesAroundBlock(tmp1,_gthis.config.emptyLines.beforeBlocks,"keep");
					var block1 = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.previousSibling(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(block1,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 7:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 15:case 16:
					var block2 = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.DblDot));
					_gthis.removeEmptyLinesAroundBlock(block2,_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				case 20:
					var tmp2 = token.getFirstChild();
					_gthis.removeEmptyLinesAroundBlock(tmp2,_gthis.config.emptyLines.beforeBlocks,"keep");
					var block3 = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.previousSibling(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastChild(token));
					_gthis.removeEmptyLinesAroundBlock(block3,"keep",_gthis.config.emptyLines.afterBlocks);
					break;
				case 21:
					_gthis.removeEmptyLinesAroundBlock(token.children[1],_gthis.config.emptyLines.beforeBlocks,"keep");
					break;
				default:
				}
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
	}
	,removeEmptyLinesAroundBlock: function(block,before,after) {
		if(block == null) {
			return;
		}
		if(before == "remove") {
			var prev = this.getPreviousToken(block);
			if(prev != null) {
				this.emptyLinesAfter(prev.token,0);
			}
		}
		if(after == "remove") {
			this.emptyLinesAfterSubTree(block,0);
		}
	}
	,keepExistingEmptyLines: function() {
		var funcs = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFunction)],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < funcs.length) {
			var func = funcs[_g];
			++_g;
			var block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(func),haxeparser_TokenDef.BrOpen);
			if(block == null) {
				block = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(func),haxeparser_TokenDef.BrOpen);
			}
			if(block == null) {
				continue;
			}
			var fullPos = block.getPos();
			var startLine = this.parsedCode.getLinePos(fullPos.min).line;
			var endLine = this.parsedCode.getLinePos(fullPos.max).line;
			var _g1 = 0;
			var _g11 = this.parsedCode.emptyLines;
			while(_g1 < _g11.length) {
				var emptyLine = _g11[_g1];
				++_g1;
				if(startLine >= emptyLine || endLine <= emptyLine) {
					continue;
				}
				var idx = this.parsedCode.linesIdx[emptyLine];
				var tokenInf = this.findTokenAtOffset(idx.l);
				if(tokenInf == null) {
					continue;
				}
				if(tokentree_utils_TokenTreeCheckUtils.isMetadata(tokenInf.token)) {
					continue;
				}
				tokenInf.emptyLinesAfter++;
			}
		}
	}
	,markFileHeader: function() {
		var info = this.getTokenAt(0);
		var info2 = this.getTokenAt(1);
		var packagesAndImports = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdPackage),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdImport),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdUsing)],tokentree_TokenFilterMode.ALL);
		if(info == null) {
			return;
		}
		var _g = info.token.tok;
		if(_g._hx_index == 6) {
			var s = _g.s;
			if(packagesAndImports.length == 0) {
				var _g1 = info2.token.tok;
				if(_g1._hx_index == 6) {
					var s1 = _g1.s;
				} else {
					return;
				}
			}
			info.emptyLinesAfter = this.config.emptyLines.afterFileHeaderComment;
		}
	}
});
var formatter_marker_MarkLineEnds = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkLineEnds.__name__ = true;
formatter_marker_MarkLineEnds.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkLineEnds.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var semicolonTokens = this.parsedCode.root.filter([haxeparser_TokenDef.Semicolon],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < semicolonTokens.length) {
			var token = semicolonTokens[_g];
			++_g;
			this.lineEndAfter(token);
		}
		this.markBrOpenClose();
		this.markAt();
		this.markDblDot();
		this.markSharp();
		this.markComments();
		this.markStructureExtension();
	}
	,markComments: function() {
		var commentTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				var _g2 = _g.s;
				return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
			case 7:
				var _g1 = _g.s;
				return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
			default:
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g3 = 0;
		while(_g3 < commentTokens.length) {
			var token1 = commentTokens[_g3];
			++_g3;
			var _g4 = token1.tok;
			switch(_g4._hx_index) {
			case 6:
				var _g21 = _g4.s;
				var prev = this.getPreviousToken(token1);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(token1,prev.token)) {
						if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
							this.lineEndAfter(token1);
						}
						this.noLineEndBefore(token1);
					}
				}
				var commentLine = this.parsedCode.getLinePos(token1.pos.min);
				var prefix = this.parsedCode.getString(this.parsedCode.linesIdx[commentLine.line].l,token1.pos.min);
				commentLine = this.parsedCode.getLinePos(token1.pos.max);
				var postfix = this.parsedCode.getString(token1.pos.max,this.parsedCode.linesIdx[commentLine.line].r);
				if(new EReg("^\\s*$","").match(prefix) && new EReg("^\\s*$","").match(postfix)) {
					this.lineEndAfter(token1);
					continue;
				}
				break;
			case 7:
				var _g11 = _g4.s;
				var prev1 = this.getPreviousToken(token1);
				if(prev1 != null) {
					if(this.parsedCode.isOriginalSameLine(token1,prev1.token)) {
						this.noLineEndBefore(token1);
					}
				}
				this.lineEndAfter(token1);
				break;
			default:
			}
		}
	}
	,markBrOpenClose: function() {
		var brTokens = this.parsedCode.root.filterCallback(function(token,index) {
			if(token.tok._hx_index == 16) {
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
		var _g = 0;
		while(_g < brTokens.length) {
			var brOpen = brTokens[_g];
			++_g;
			var curlyPolicy = this.detectCurlyPolicy(brOpen);
			var brClose = this.getCloseToken(brOpen);
			if(brClose == null) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
				continue;
			}
			var prev = this.getPreviousToken(brOpen);
			if(prev != null) {
				var _g1 = prev.token.tok;
				if(_g1._hx_index == 3) {
					var name = _g1.s;
					if(this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
						this.noLineEndAfter(brOpen);
						this.noLineEndBefore(brClose);
						this.whitespace(brOpen,"none");
						this.whitespace(brClose,"noneBefore");
						var next = this.getNextToken(brClose);
						if(next != null) {
							if(next.token.tok._hx_index == 11) {
								this.whitespace(brClose,"after");
							}
						}
						continue;
					}
					if(name.length <= 1) {
						this.whitespace(brOpen,"noneBefore");
					}
				}
			}
			var next1 = this.getNextToken(brOpen);
			var isEmpty = false;
			if(next1 != null && next1.token.is(haxeparser_TokenDef.BrClose) && curlyPolicy.emptyCurly == "noBreak") {
				isEmpty = true;
			}
			if(!isEmpty) {
				switch(curlyPolicy.leftCurly) {
				case "after":
					this.lineEndAfter(brOpen);
					break;
				case "before":
					this.beforeLeftCurly(brOpen);
					break;
				case "both":
					this.beforeLeftCurly(brOpen);
					this.lineEndAfter(brOpen);
					break;
				case "none":
					break;
				}
			}
			var preventBefore = isEmpty;
			var preventAfter = false;
			next1 = this.getNextToken(brClose);
			if(next1 != null) {
				if(next1.token.tok._hx_index == 11) {
					preventAfter = true;
				}
			}
			switch(curlyPolicy.rightCurly) {
			case "after":
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "before":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				break;
			case "both":
				if(!preventBefore) {
					this.beforeRightCurly(brClose);
				}
				if(!preventAfter) {
					this.afterRightCurly(brClose);
				}
				break;
			case "none":
				break;
			}
		}
	}
	,detectCurlyPolicy: function(brOpen) {
		var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(brOpen);
		var curlyPolicy = { leftCurly : this.config.lineEnds.leftCurly, rightCurly : this.config.lineEnds.rightCurly, emptyCurly : this.config.lineEnds.emptyCurly};
		switch(type._hx_index) {
		case 0:
			if(this.config.lineEnds.blockCurly != null) {
				return this.config.lineEnds.blockCurly;
			}
			break;
		case 1:
			if(this.config.lineEnds.typedefCurly != null) {
				return this.config.lineEnds.typedefCurly;
			}
			break;
		case 2:
			if(this.config.lineEnds.objectLiteralCurly != null) {
				return this.config.lineEnds.objectLiteralCurly;
			}
			break;
		case 3:
			if(this.config.lineEnds.anonTypeCurly != null) {
				return this.config.lineEnds.anonTypeCurly;
			}
			break;
		case 4:
			break;
		}
		return curlyPolicy;
	}
	,beforeLeftCurly: function(token) {
		this.lineEndBefore(token);
	}
	,beforeRightCurly: function(token) {
		this.lineEndBefore(token);
	}
	,afterRightCurly: function(token) {
		var next = token.index + 1;
		if(this.parsedCode.tokenList.tokens.length <= next) {
			this.lineEndAfter(token);
			return;
		}
		var nextToken = this.getTokenAt(next);
		if(nextToken == null) {
			this.lineEndAfter(token);
			return;
		}
		var _g = nextToken.token.tok;
		switch(_g._hx_index) {
		case 5:
			switch(_g.op._hx_index) {
			case 4:
				break;
			case 7:
				break;
			default:
				this.lineEndAfter(token);
			}
			break;
		case 9:
			break;
		case 10:
			break;
		case 12:
			break;
		case 13:
			break;
		case 16:
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(nextToken.token);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				this.lineEndAfter(token);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			break;
		case 19:
			break;
		default:
			this.lineEndAfter(token);
		}
	}
	,markAt: function() {
		var atTokens = this.parsedCode.root.filter([haxeparser_TokenDef.At],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < atTokens.length) {
			var token = atTokens[_g];
			++_g;
			var metadataPolicy = this.determineMetadataPolicy(token);
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			if(metadataPolicy == "after") {
				this.lineEndAfter(lastChild);
				continue;
			}
			if(token.previousSibling != null && token.previousSibling.is(haxeparser_TokenDef.At)) {
				continue;
			}
			var next = token.nextSibling;
			var metadata = [token];
			while(next != null && next.is(haxeparser_TokenDef.At)) {
				metadata.push(next);
				next = next.nextSibling;
			}
			var _g1 = 0;
			while(_g1 < metadata.length) {
				var meta = metadata[_g1];
				++_g1;
				lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(meta);
				if(lastChild == null) {
					continue;
				}
				switch(metadataPolicy) {
				case "after":
					this.lineEndAfter(lastChild);
					break;
				case "afterLast":
					var next1 = this.getNextToken(lastChild);
					if(next1 != null && !this.parsedCode.isOriginalSameLine(lastChild,next1.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				case "forceAfterLast":
					this.whitespace(lastChild,"after");
					break;
				case "none":
					var next2 = this.getNextToken(lastChild);
					if(next2 != null && !this.parsedCode.isOriginalSameLine(lastChild,next2.token)) {
						this.lineEndAfter(lastChild);
						continue;
					}
					this.whitespace(lastChild,"after");
					break;
				}
			}
			if(metadataPolicy == "afterLast" || metadataPolicy == "forceAfterLast") {
				this.lineEndAfter(lastChild);
			}
		}
	}
	,determineMetadataPolicy: function(token) {
		if(token == null) {
			return this.config.lineEnds.metadataOther;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == null) {
			return this.config.lineEnds.metadataType;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				return this.config.lineEnds.metadataFunction;
			case 22:
				if(parent.parent == null || parent.parent.tok == null) {
					return this.config.lineEnds.metadataOther;
				}
				var _g1 = parent.parent.tok;
				if(_g1._hx_index == 0) {
					switch(_g1.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
				break;
			default:
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 1:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
				if(parent.parent == null || parent.parent.tok == null) {
					return this.config.lineEnds.metadataOther;
				}
				var _g4 = parent.parent.tok;
				if(_g4._hx_index == 0) {
					switch(_g4.k._hx_index) {
					case 0:
						return this.config.lineEnds.metadataFunction;
					case 2:
						return this.config.lineEnds.metadataVar;
					case 1:case 26:case 27:case 31:case 39:
						return this.config.lineEnds.metadataType;
					default:
						return this.config.lineEnds.metadataOther;
					}
				} else {
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		case 2:
			var _g11 = _g.s;
			return "after";
		case 3:
			var _g5 = _g.s;
			if(parent.parent == null || parent.parent.tok == null) {
				return this.config.lineEnds.metadataOther;
			}
			var _g6 = parent.parent.tok;
			if(_g6._hx_index == 0) {
				switch(_g6.k._hx_index) {
				case 0:
					return this.config.lineEnds.metadataFunction;
				case 2:
					return this.config.lineEnds.metadataVar;
				case 1:case 26:case 27:case 31:case 39:
					return this.config.lineEnds.metadataType;
				default:
					return this.config.lineEnds.metadataOther;
				}
			} else {
				return this.config.lineEnds.metadataOther;
			}
			break;
		default:
			return this.config.lineEnds.metadataOther;
		}
	}
	,markDblDot: function() {
		var dblDotTokens = this.parsedCode.root.filter([haxeparser_TokenDef.DblDot],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < dblDotTokens.length) {
			var token = dblDotTokens[_g];
			++_g;
			if(!token.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdCase)) && !token.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDefault))) {
				continue;
			}
			if(this.config.lineEnds.caseColon != "none") {
				this.lineEndAfter(token);
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastChild == null) {
				continue;
			}
			this.lineEndAfter(lastChild);
		}
	}
	,markSharp: function() {
		var sharpTokens = this.parsedCode.root.filter([haxeparser_TokenDef.Sharp("if"),haxeparser_TokenDef.Sharp("else"),haxeparser_TokenDef.Sharp("elseif"),haxeparser_TokenDef.Sharp("end"),haxeparser_TokenDef.Sharp("error")],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < sharpTokens.length) {
			var token = sharpTokens[_g];
			++_g;
			var _g1 = token.tok;
			if(_g1._hx_index == 2) {
				switch(_g1.s) {
				case "else":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(token);
					break;
				case "end":
					if(this.isInlineSharp(token)) {
						this.noLineEndBefore(token);
					} else {
						this.lineEndBefore(token);
					}
					var next = this.getNextToken(token);
					if(next != null) {
						switch(next.token.tok._hx_index) {
						case 9:case 13:
							continue;
						default:
						}
					}
					if(!this.isOnlyWhitespaceAfterToken(token,true)) {
						continue;
					}
					this.lineEndAfter(token);
					break;
				case "error":
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild == null) {
						lastChild = token;
					}
					this.lineEndAfter(lastChild);
					break;
				case "elseif":case "if":
					var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild1 == null) {
						continue;
					}
					if(this.config.lineEnds.sharp == "none") {
						this.whitespace(lastChild1,"after");
						continue;
					}
					if(this.isInlineSharp(token)) {
						if(token.is(haxeparser_TokenDef.Sharp("if")) && this.isOnlyWhitespaceBeforeToken(token)) {
							continue;
						}
						this.noLineEndBefore(token);
						continue;
					}
					this.lineEndBefore(token);
					this.lineEndAfter(lastChild1);
					break;
				default:
					this.lineEndAfter(token);
				}
			} else {
				this.lineEndAfter(token);
			}
		}
	}
	,isInlineSharp: function(token) {
		var _g = token.tok;
		if(_g._hx_index == 2) {
			switch(_g.s) {
			case "else":
				return this.isInlineSharp(token.parent);
			case "elseif":
				return this.isInlineSharp(token.parent);
			case "end":
				return this.isInlineSharp(token.parent);
			case "if":
				var sharpEnd = token.getLastChild();
				if(sharpEnd == null) {
					return false;
				}
				var _g1 = sharpEnd.tok;
				switch(_g1._hx_index) {
				case 2:
					if(_g1.s == "end") {
						if(this.parsedCode.linesBetweenOriginal(token,sharpEnd) > 5) {
							return false;
						}
					} else {
						return false;
					}
					break;
				case 9:case 13:
					sharpEnd = sharpEnd.previousSibling;
					if(sharpEnd == null) {
						return false;
					}
					if(!sharpEnd.is(haxeparser_TokenDef.Sharp("end"))) {
						return false;
					}
					break;
				default:
					return false;
				}
				if(!this.isOnlyWhitespaceAfterToken(sharpEnd,true)) {
					return true;
				}
				if(!this.isOnlyWhitespaceBeforeToken(token)) {
					return true;
				}
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return !this.isOnlyWhitespaceBeforeToken(token);
				}
				if(prev.whitespaceAfter == formatter_codedata_WhitespaceAfterType.Newline) {
					return false;
				}
				var _g2 = prev.token.tok;
				switch(_g2._hx_index) {
				case 6:
					var _g4 = _g2.s;
					return false;
				case 7:
					var _g3 = _g2.s;
					return false;
				case 9:
					return false;
				case 17:
					return false;
				case 19:
					if(this.parsedCode.isOriginalSameLine(prev.token,token)) {
						return true;
					}
					return false;
				default:
					return true;
				}
				break;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,isOnlyWhitespaceBeforeToken: function(token) {
		var tokenLine = this.parsedCode.getLinePos(token.pos.min);
		var prefix = this.parsedCode.getString(this.parsedCode.linesIdx[tokenLine.line].l,token.pos.min);
		return new EReg("^\\s*$","").match(prefix);
	}
	,isOnlyWhitespaceAfterToken: function(token,allowLineComments) {
		var tokenLine = this.parsedCode.getLinePos(token.pos.max);
		var prefix = this.parsedCode.getString(token.pos.max,this.parsedCode.linesIdx[tokenLine.line].r);
		if(allowLineComments) {
			return new EReg("^\\s*(|//.*)$","").match(prefix);
		} else {
			return new EReg("^\\s*$","").match(prefix);
		}
	}
	,findTypedefBrOpen: function(token) {
		var assign = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token)),haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
		if(assign == null) {
			return null;
		}
		return tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(assign,haxeparser_TokenDef.BrOpen);
	}
	,markStructureExtension: function() {
		var typedefTokens = this.parsedCode.root.filter([haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTypedef)],tokentree_TokenFilterMode.ALL);
		var _g = 0;
		while(_g < typedefTokens.length) {
			var token = typedefTokens[_g];
			++_g;
			this.markAfterTypedef(token);
			var brOpen = this.findTypedefBrOpen(token);
			if(brOpen == null) {
				continue;
			}
			if(brOpen.children == null || brOpen.children.length <= 0) {
				continue;
			}
			var assignParent = brOpen.parent;
			if(assignParent.children.length > 1) {
				var _g1 = 0;
				var _g11 = assignParent.children;
				while(_g1 < _g11.length) {
					var child = _g11[_g1];
					++_g1;
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
					if(lastChild == null) {
						continue;
					}
					var next = this.getNextToken(lastChild);
					if(next == null) {
						continue;
					}
					if(lastChild.is(haxeparser_TokenDef.BrClose)) {
						var _g2 = next.token.tok;
						switch(_g2._hx_index) {
						case 5:
							if(_g2.op._hx_index == 11) {
								this.noLineEndAfter(lastChild);
								continue;
							}
							break;
						case 9:
							this.whitespace(lastChild,"noneAfter");
							continue;
						case 12:
							this.whitespace(lastChild,"none");
							continue;
						default:
						}
					}
					if(next.token.is(haxeparser_TokenDef.BrOpen)) {
						continue;
					}
					this.lineEndAfter(lastChild);
				}
			}
			var _g3 = 0;
			var _g12 = brOpen.children;
			while(_g3 < _g12.length) {
				var child1 = _g12[_g3];
				++_g3;
				var _g4 = child1.tok;
				switch(_g4._hx_index) {
				case 1:
					var _g21 = _g4.c;
					if(_g21._hx_index == 3) {
						var _g31 = _g21.s;
						var lastChild1 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child1);
						if(lastChild1 == null) {
							continue;
						}
						this.lineEndAfter(lastChild1);
					}
					break;
				case 5:
					if(_g4.op._hx_index == 7) {
						var lastChild2 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child1);
						if(lastChild2 == null) {
							continue;
						}
						this.lineEndAfter(lastChild2);
					}
					break;
				case 17:
					var next1 = this.getNextToken(child1);
					if(next1 == null) {
						continue;
					}
					if(next1.token.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd))) {
						this.noLineEndAfter(child1);
					}
					if(next1.token.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt))) {
						this.whitespace(child1,"noneAfter");
					}
					break;
				case 20:
					var lastChild3 = tokentree_utils_TokenTreeCheckUtils.getLastToken(child1);
					if(lastChild3 == null) {
						continue;
					}
					this.lineEndAfter(lastChild3);
					break;
				default:
				}
			}
		}
	}
	,markAfterTypedef: function(token) {
		var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastChild == null) {
			return;
		}
		var next = this.getNextToken(lastChild);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 7:
				var _g1 = _g.s;
				if(!this.parsedCode.isOriginalNewlineBefore(next.token)) {
					return;
				}
				break;
			case 9:
				this.whitespace(lastChild,"noneAfter");
				return;
			default:
			}
		}
		this.lineEndAfter(lastChild);
	}
});
var formatter_marker_MarkSameLine = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkSameLine.__name__ = true;
formatter_marker_MarkSameLine.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkSameLine.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.markDollarSameLine();
		this.parsedCode.root.filterCallback(function(token,index) {
			if(token.parent != null && token.parent.is(haxeparser_TokenDef.At)) {
				return tokentree_FilterResult.GO_DEEPER;
			}
			var _g = token.tok;
			if(_g._hx_index == 0) {
				switch(_g.k._hx_index) {
				case 0:
					_gthis.markFunction(token);
					break;
				case 3:
					_gthis.markIf(token);
					break;
				case 4:
					_gthis.markElse(token);
					break;
				case 5:
					if(token.parent != null && token.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDo))) {
						return tokentree_FilterResult.GO_DEEPER;
					}
					_gthis.markWhile(token);
					break;
				case 6:
					_gthis.markDoWhile(token);
					break;
				case 7:
					_gthis.markFor(token);
					break;
				case 10:
					_gthis.markReturn(token);
					break;
				case 15:
					_gthis.markCase(token);
					break;
				case 16:
					_gthis.markCase(token);
					break;
				case 20:
					_gthis.markTry(token);
					break;
				case 21:
					_gthis.markCatch(token);
					break;
				case 28:
					_gthis.markUntyped(token);
					break;
				case 40:
					_gthis.markMacro(token);
					break;
				default:
				}
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
	}
	,isExpression: function(token) {
		if(token == null) {
			return false;
		}
		var parent = token.parent;
		if(parent.tok == null) {
			return false;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 4:
				return this.shouldElseBeSameLine(parent);
			case 5:case 7:
				if(parent.parent.is(haxeparser_TokenDef.BkOpen)) {
					return true;
				}
				break;
			case 10:
				return true;
			case 28:
				return this.isExpression(parent);
			default:
			}
			break;
		case 5:
			var _g1 = _g.op;
			return true;
		case 11:
			return this.isReturnExpression(parent);
		case 12:
			return true;
		case 18:
			var pos = parent.getPos();
			if(pos.min < token.pos.min && pos.max > token.pos.max) {
				return true;
			}
			break;
		default:
		}
		return false;
	}
	,isReturnExpression: function(token) {
		var parent = token;
		while(parent.parent.tok != null) {
			parent = parent.parent;
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 0:
				switch(_g.k._hx_index) {
				case 0:
					return false;
				case 10:
					return true;
				default:
				}
				break;
			case 5:
				var _g1 = _g.op;
				return true;
			case 11:
				return true;
			case 12:
				return true;
			case 14:
				return false;
			case 16:
				var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
				switch(type._hx_index) {
				case 0:
					break;
				case 1:
					break;
				case 2:
					return true;
				case 3:
					break;
				case 4:
					break;
				}
				break;
			case 18:
				return true;
			default:
			}
		}
		return false;
	}
	,shouldIfBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdIf))) {
			return false;
		}
		var body = this.getBodyAfterCondition(token);
		if(body == null) {
			return false;
		}
		if(!this.parsedCode.isOriginalSameLine(token,body)) {
			return false;
		}
		return this.isExpression(token);
	}
	,shouldElseBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse))) {
			return false;
		}
		return this.shouldIfBeSameLine(token.parent);
	}
	,shouldTryBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTry))) {
			return false;
		}
		return this.isExpression(token);
	}
	,shouldCatchBeSameLine: function(token) {
		if(token == null) {
			return false;
		}
		if(!token.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdCatch))) {
			return false;
		}
		return this.shouldTryBeSameLine(token.parent);
	}
	,markIf: function(token) {
		if(this.shouldIfBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBodyAfterPOpen(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				return;
			case "next":
				break;
			case "same":
				this.markBodyAfterPOpen(token,"same",this.config.sameLine.expressionIfWithBlocks);
				return;
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.ifBody,false);
		var prev = this.getPreviousToken(token);
		if(prev != null && prev.token.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse))) {
			this.applySameLinePolicy(token,this.config.sameLine.elseIf);
		}
	}
	,markElse: function(token) {
		if(this.shouldElseBeSameLine(token)) {
			switch(this.config.sameLine.expressionIf) {
			case "keep":
				this.markBody(token,"keep",this.config.sameLine.expressionIfWithBlocks);
				if(this.parsedCode.isOriginalNewlineBefore(token)) {
					this.lineEndBefore(token);
				}
				var prev = this.getPreviousToken(token);
				if(prev == null) {
					return;
				}
				if(prev.token.is(haxeparser_TokenDef.BrClose)) {
					this.applySameLinePolicyChained(token,"keep","keep");
				}
				return;
			case "next":
				break;
			case "same":
				this.markBody(token,"same",this.config.sameLine.expressionIfWithBlocks);
				var prev1 = this.getPreviousToken(token);
				if(prev1 == null) {
					return;
				}
				if(prev1.token.is(haxeparser_TokenDef.BrClose)) {
					this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,this.config.sameLine.ifElse);
				}
				return;
			}
		}
		this.markBody(token,this.config.sameLine.elseBody,false);
		var policy = this.config.sameLine.ifElse;
		var prev2 = this.getPreviousToken(token);
		if(prev2 != null) {
			if(prev2.token.tok._hx_index == 17) {
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(prev2.token),haxeparser_TokenDef.BrOpen)),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdIf)) == null) {
					switch(policy) {
					case "keep":
						break;
					case "next":
						break;
					case "same":
						policy = "next";
						break;
					}
				}
			}
		}
		this.applySameLinePolicyChained(token,this.config.sameLine.ifBody,policy);
	}
	,markTry: function(token) {
		if(this.shouldTryBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBody(token,"same",false);
			return;
		}
		this.markBody(token,this.config.sameLine.tryBody,false);
	}
	,markCatch: function(token) {
		if(this.shouldCatchBeSameLine(token) && this.config.sameLine.expressionTry == "same") {
			this.markBodyAfterPOpen(token,"same",false);
			this.applySameLinePolicy(token,this.config.sameLine.tryCatch);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.catchBody,false);
		this.applySameLinePolicyChained(token,this.config.sameLine.tryBody,this.config.sameLine.tryCatch);
	}
	,markCase: function(token) {
		if(token == null) {
			return;
		}
		var dblDot = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.DblDot);
		if(dblDot == null) {
			return;
		}
		if(this.isReturnExpression(token)) {
			this.markExpressionCase(token,dblDot);
			return;
		}
		if(dblDot.children == null || dblDot.children.length > 1) {
			return;
		}
		switch(this.config.sameLine.caseBody) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		var first = dblDot.getFirstChild();
		var last = tokentree_utils_TokenTreeCheckUtils.getLastToken(first);
		if(this.parsedCode.linesBetweenOriginal(first,last) > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	,markExpressionCase: function(token,dblDot) {
		if(dblDot.children == null) {
			return;
		}
		switch(this.config.sameLine.expressionCase) {
		case "keep":
			if(!this.parsedCode.isOriginalSameLine(dblDot,dblDot.getFirstChild())) {
				return;
			}
			break;
		case "next":
			return;
		case "same":
			break;
		}
		if(dblDot.children.length == 2) {
			var second = dblDot.children[1];
			var _g1 = second.tok;
			if(_g1._hx_index == 7) {
				var _g2 = _g1.s;
				var prev = this.getPreviousToken(second);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(dblDot,prev.token)) {
						return;
					}
				}
			} else {
				return;
			}
		}
		if(dblDot.children.length > 2) {
			return;
		}
		this.noLineEndAfter(dblDot);
	}
	,isArrayComprehension: function(token) {
		if(token == null) {
			return false;
		}
		var parent = token.parent;
		while(parent != null && parent.tok != null) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 0:
				switch(_g.k._hx_index) {
				case 3:case 4:case 5:case 7:
					parent = parent.parent;
					break;
				default:
					return false;
				}
				break;
			case 14:
				return true;
			default:
				return false;
			}
		}
		return false;
	}
	,markFor: function(token) {
		if(token == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == null) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		var _g = parent.tok;
		if(_g._hx_index == 0) {
			if(_g.k._hx_index == 40) {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
				if(lastToken == null) {
					return;
				}
				if(this.parsedCode.isOriginalSameLine(token,lastToken)) {
					this.markBodyAfterPOpen(token,"same",false);
					return;
				}
			}
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
	}
	,markWhile: function(token) {
		if(token == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || parent.tok == null) {
			return;
		}
		if(this.isArrayComprehension(token)) {
			this.markArrayComprehension(token,parent);
			return;
		}
		this.markBodyAfterPOpen(token,this.config.sameLine.whileBody,false);
	}
	,markArrayComprehension: function(token,bkOpen) {
		var bkClose = this.getCloseToken(bkOpen);
		switch(this.config.sameLine.comprehensionFor) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
			}
			this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
			if(bkClose != null && this.parsedCode.isOriginalNewlineBefore(bkClose)) {
				this.lineEndBefore(bkClose);
			}
			break;
		case "next":
			break;
		case "same":
			var origSame = false;
			if(bkClose != null) {
				origSame = this.parsedCode.isOriginalSameLine(bkOpen,bkClose);
			} else {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(bkOpen);
				if(lastToken != null) {
					origSame = this.parsedCode.isOriginalSameLine(bkOpen,lastToken);
				}
			}
			if(origSame) {
				this.markBodyAfterPOpen(token,this.config.sameLine.comprehensionFor,false);
				if(bkClose != null) {
					this.whitespace(token,"noneBefore");
					this.whitespace(bkClose,"noneBefore");
				}
			} else {
				this.markBodyAfterPOpen(token,this.config.sameLine.forBody,false);
			}
			break;
		}
	}
	,getBodyAfterCondition: function(token) {
		var pClose = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.POpen),haxeparser_TokenDef.PClose);
		if(pClose != null) {
			var next = this.getNextToken(pClose);
			if(next != null) {
				if(next.token.tok._hx_index != 11) {
					return next.token;
				}
			}
		}
		if(token.children == null) {
			return null;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 0:
				switch(_g2.k._hx_index) {
				case 36:case 37:case 38:
					return child.nextSibling;
				default:
				}
				break;
			case 1:
				var _g11 = _g2.c;
				if(_g11._hx_index == 3) {
					var _g21 = _g11.s;
					return child.nextSibling;
				}
				break;
			case 16:
				return child;
			case 21:
				break;
			default:
			}
		}
		return null;
	}
	,markBodyAfterPOpen: function(token,policy,includeBrOpen) {
		var body = this.getBodyAfterCondition(token);
		_hx_loop1: while(body != null) {
			var _g = body.tok;
			switch(_g._hx_index) {
			case 2:
				switch(_g.s) {
				case "else":case "elseif":case "end":
					return;
				default:
					break _hx_loop1;
				}
				break;
			case 7:
				var _g2 = _g.s;
				var prev = this.getPreviousToken(body);
				if(prev != null) {
					if(!this.parsedCode.isOriginalSameLine(body,prev.token)) {
						this.applySameLinePolicy(body,policy);
						return;
					}
				}
				body = body.nextSibling;
				break;
			case 16:
				var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body);
				switch(type._hx_index) {
				case 0:
					if(includeBrOpen) {
						this.markBlockBody(body,policy);
					}
					return;
				case 1:
					break;
				case 2:
					this.applySameLinePolicy(body,policy);
					break;
				case 3:
					break;
				case 4:
					break;
				}
				body = body.nextSibling;
				break;
			default:
				break _hx_loop1;
			}
		}
		if(body == null) {
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	,markBody: function(token,policy,includeBrOpen) {
		var body = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token);
		if(body == null) {
			return;
		}
		if(body.is(haxeparser_TokenDef.BrOpen)) {
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(body);
			switch(type._hx_index) {
			case 0:
				if(includeBrOpen) {
					this.markBlockBody(body,policy);
				}
				return;
			case 1:
				break;
			case 2:
				this.applySameLinePolicy(body,policy);
				break;
			case 3:
				break;
			case 4:
				break;
			}
			return;
		}
		this.applySameLinePolicy(body,policy);
	}
	,markBlockBody: function(token,policy) {
		if(token == null) {
			return;
		}
		if(!token.is(haxeparser_TokenDef.BrOpen)) {
			return;
		}
		if(token.children == null) {
			return;
		}
		var lastChild = token.getLastChild();
		if(lastChild.is(haxeparser_TokenDef.Semicolon)) {
			if(token.children.length > 3) {
				return;
			}
		} else if(token.children.length > 2) {
			return;
		}
		this.noLineEndAfter(token);
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			if(child.tok._hx_index == 17) {
				var next = this.getNextToken(child);
				var _g2 = next.token.tok;
				switch(_g2._hx_index) {
				case 0:
					switch(_g2.k._hx_index) {
					case 4:
						this.noLineEndAfter(child);
						break;
					case 21:
						this.noLineEndAfter(child);
						break;
					default:
					}
					break;
				case 9:
					this.whitespace(child,"noneAfter");
					break;
				case 13:
					this.whitespace(child,"noneAfter");
					break;
				default:
				}
				return;
			} else {
				var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				if(lastToken == null) {
					return;
				}
				this.noLineEndAfter(lastToken);
			}
		}
	}
	,applySameLinePolicyChained: function(token,previousBlockPolicy,policy) {
		if(policy == "same") {
			var prev = this.getPreviousToken(token);
			if(prev == null) {
				policy = "next";
			}
			if(!prev.token.is(haxeparser_TokenDef.BrClose) && previousBlockPolicy != "same") {
				policy = "next";
			}
		}
		this.applySameLinePolicy(token,policy);
	}
	,applySameLinePolicy: function(token,policy) {
		switch(policy) {
		case "keep":
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.applySameLinePolicy(token,"next");
			} else {
				this.applySameLinePolicy(token,"same");
			}
			break;
		case "next":
			var _g = token.tok;
			switch(_g._hx_index) {
			case 7:
				var s = _g.s;
				if(!this.parsedCode.isOriginalNewlineBefore(token)) {
					return;
				}
				break;
			case 14:
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(token),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFor)) != null) {
					return;
				}
				break;
			default:
			}
			this.lineEndBefore(token);
			break;
		case "same":
			this.wrapBefore(token,true);
			var prev = this.getPreviousToken(token);
			if(prev == null) {
				this.noLineEndBefore(token);
			} else {
				switch(prev.token.tok._hx_index) {
				case 10:case 18:
					this.whitespace(token,"noneBefore");
					break;
				default:
					this.noLineEndBefore(token);
				}
			}
			var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
			if(lastToken == null) {
				return;
			}
			var next = this.getNextToken(lastToken);
			if(next == null) {
				return;
			}
			var _g1 = next.token.tok;
			if(_g1._hx_index == 0) {
				if(_g1.k._hx_index == 4) {
					this.noLineEndAfter(lastToken);
				}
			}
			return;
		}
	}
	,markDollarSameLine: function() {
		var tokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 3) {
				var _g1 = _g.s;
				return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g2 = 0;
		while(_g2 < tokens.length) {
			var token1 = tokens[_g2];
			++_g2;
			var brOpen = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token1),haxeparser_TokenDef.BrOpen);
			if(brOpen == null) {
				continue;
			}
			var brClose = this.getCloseToken(brOpen);
			if(!this.parsedCode.isOriginalSameLine(brOpen,brClose)) {
				continue;
			}
			this.whitespace(brOpen,"none");
			var next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 11:
					break;
				case 9:case 10:case 13:
					this.whitespace(brClose,"none");
					break;
				case 17:
					break;
				case 14:case 15:case 18:case 19:
					this.whitespace(brClose,"none");
					break;
				default:
					this.whitespace(brClose,"onlyAfter");
				}
			} else {
				this.noLineEndAfter(brClose);
			}
			this.wrapBefore(brOpen,false);
			this.wrapAfter(brOpen,false);
			this.wrapBefore(brClose,false);
			this.wrapAfter(brClose,false);
		}
	}
	,markFunction: function(token) {
		var body = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token));
		if(body == null) {
			body = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdNew));
		}
		var policy = this.config.sameLine.functionBody;
		if(body == null) {
			body = token;
			policy = this.config.sameLine.anonFunctionBody;
		}
		if(body == null || body.children == null) {
			return;
		}
		body = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(body,haxeparser_TokenDef.POpen);
		if(body == null) {
			return;
		}
		if(body.nextSibling == null) {
			return;
		}
		body = body.nextSibling;
		if(body.tok._hx_index == 11) {
			body = body.nextSibling;
		}
		if(body == null) {
			return;
		}
		var _g1 = body.tok;
		switch(_g1._hx_index) {
		case 7:
			var _g2 = _g1.s;
			return;
		case 9:
			return;
		case 16:
			return;
		default:
		}
		this.applySameLinePolicy(body,policy);
	}
	,markDoWhile: function(token) {
		this.markBody(token,this.config.sameLine.doWhileBody,false);
		var whileTok = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdWhile));
		if(whileTok == null) {
			return;
		}
		this.applySameLinePolicy(whileTok,this.config.sameLine.doWhile);
	}
	,markMacro: function(token) {
		var brOpen = this.getNextToken(token);
		if(brOpen == null || !brOpen.token.is(haxeparser_TokenDef.BrOpen)) {
			return;
		}
		var brClose = this.getCloseToken(brOpen.token);
		if(this.parsedCode.isOriginalSameLine(brOpen.token,brClose)) {
			this.noLineEndAfter(brOpen.token);
			this.noLineEndBefore(brClose);
			this.noWrappingBetween(brOpen.token,brClose);
		}
	}
	,markReturn: function(token) {
		if(this.shouldReturnBeSameLine(token)) {
			this.markBody(token,this.config.sameLine.returnBodySingleLine,false);
		} else {
			this.markBody(token,this.config.sameLine.returnBody,false);
		}
	}
	,markUntyped: function(token) {
		if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token),haxeparser_TokenDef.BrOpen) == null) {
			return;
		}
		var parent = token.parent;
		if(parent == null || token.tok == null) {
			return;
		}
		if(parent.tok._hx_index == 16) {
			var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			switch(type._hx_index) {
			case 0:
				return;
			case 1:
				return;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			}
		}
		this.applySameLinePolicy(token,this.config.sameLine.untypedBody);
	}
	,shouldReturnBeSameLine: function(token) {
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(token);
		if(lastToken == null) {
			return true;
		}
		if(this.isSameLineBetween(token,lastToken,false)) {
			return true;
		}
		return this.shouldReturnChildsBeSameLine(token);
	}
	,shouldReturnChildsBeSameLine: function(token) {
		if(token.children == null) {
			return true;
		}
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 0) {
				switch(_g2.k._hx_index) {
				case 3:case 5:case 7:case 14:case 20:
					return false;
				default:
					var result = this.shouldReturnChildsBeSameLine(child);
					if(!result) {
						return false;
					}
				}
			} else {
				var result1 = this.shouldReturnChildsBeSameLine(child);
				if(!result1) {
					return false;
				}
			}
		}
		return true;
	}
});
var formatter_marker_MarkTokenText = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkTokenText.__name__ = true;
formatter_marker_MarkTokenText.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkTokenText.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.c;
				switch(_g1._hx_index) {
				case 2:
					var text = _g1.s;
					var tmp = _gthis.printStringToken(token);
					_gthis.tokenText(token,tmp);
					break;
				case 4:
					var _g3 = _g1.opt;
					var _g2 = _g1.r;
					var tmp1 = _gthis.printEregToken(token);
					_gthis.tokenText(token,tmp1);
					break;
				default:
					var tmp2 = token.toString();
					_gthis.tokenText(token,tmp2);
				}
				break;
			case 7:
				var text1 = _g.s;
				var tmp3 = _gthis.printCommentLine(text1);
				_gthis.tokenText(token,tmp3);
				break;
			default:
				var tmp4 = token.toString();
				_gthis.tokenText(token,tmp4);
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
	}
	,finalRun: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 6) {
				var text = _g.s;
				var tmp = _gthis.printComment(text,token);
				_gthis.tokenText(token,tmp);
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
	}
	,printStringToken: function(token) {
		var text = this.parsedCode.getString(token.pos.min,token.pos.max);
		if(!this.config.whitespace.formatStringInterpolation) {
			return text;
		}
		if(StringTools.startsWith(text,"'")) {
			var start = 0;
			var index;
			while(true) {
				index = text.indexOf("${",start);
				if(!(index >= 0)) {
					break;
				}
				if(this.isDollarEscaped(text,index)) {
					return text;
				}
				start = index + 1;
				var indexEnd = text.indexOf("}",index + 2);
				var fragment = text.substring(index + 2,indexEnd);
				if(fragment.indexOf("{") >= 0) {
					continue;
				}
				var formatted = this.formatFragment(fragment);
				start += formatted.length;
				text = HxOverrides.substr(text,0,index + 2) + formatted + HxOverrides.substr(text,indexEnd,null);
			}
		}
		return text;
	}
	,isDollarEscaped: function(text,index) {
		var escaped = false;
		while(--index >= 0) {
			if(text.charCodeAt(index) != 36) {
				return escaped;
			}
			escaped = !escaped;
		}
		return escaped;
	}
	,formatFragment: function(fragment) {
		try {
			var fileName = "string interpolation";
			var this1 = haxe_io_Bytes.ofString(fragment);
			var tokens = this.makeTokens(this1,fileName);
			var this2 = haxe_io_Bytes.ofString(fragment);
			var stream = new tokentree_TokenStream(tokens,this2);
			var root = new tokentree_TokenTree(null,"",null,-1);
			var progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) if(stream.hasMore()) {
				tokentree_walk_WalkStatement.walkStatement(stream,root);
			}
			var this3 = haxe_io_Bytes.ofString(fragment);
			var inputData = { fileName : fileName, content : this3, tokenList : tokens, tokenTree : root, config : this.config, entryPoint : tokentree_TokenTreeEntryPoint.EXPRESSION_LEVEL};
			var interpolParsedCode = new formatter_codedata_ParsedCode(inputData);
			var interpolIndenter = new formatter_marker_Indenter(this.config.indentation);
			interpolIndenter.setParsedCode(interpolParsedCode);
			var markTokenText = new formatter_marker_MarkTokenText(this.config,interpolParsedCode,interpolIndenter);
			var markWhitespace = new formatter_marker_MarkWhitespace(this.config,interpolParsedCode,interpolIndenter);
			markTokenText.run();
			markWhitespace.run();
			var lines = new formatter_codedata_CodeLines(interpolParsedCode,interpolIndenter);
			var formatted = lines.print(interpolParsedCode.lineSeparator);
			return StringTools.trim(formatted);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		}
		return fragment;
	}
	,makeTokens: function(fragment,name) {
		var tokens = [];
		try {
			var lexer = new haxeparser_HaxeLexer(fragment,name);
			var t = lexer.token(haxeparser_HaxeLexer.tok);
			while(t.tok != haxeparser_TokenDef.Eof) {
				tokens.push(t);
				t = lexer.token(haxeparser_HaxeLexer.tok);
			}
		} catch( e ) {
			haxe_CallStack.lastException = e;
			throw new js__$Boot_HaxeError("failed to make tokens " + Std.string(((e) instanceof js__$Boot_HaxeError) ? e.val : e));
		}
		return tokens;
	}
	,printEregToken: function(token) {
		return this.parsedCode.getString(token.pos.min,token.pos.max);
	}
	,printComment: function(text,token) {
		var lines = text.split(this.parsedCode.lineSeparator);
		var indent = this.indenter.calcIndent(token);
		var startsWithStar = lines.length >= 3;
		var _g = 1;
		var _g1 = lines.length - 1;
		while(_g < _g1) {
			var index = _g++;
			if(!new EReg("^\\s*\\*(\\s|$)","").match(lines[index])) {
				startsWithStar = false;
				break;
			}
		}
		var linesNew = [];
		var _g2 = 0;
		while(_g2 < lines.length) {
			var line = lines[_g2];
			++_g2;
			linesNew.push(this.convertLeadingIndent(line));
		}
		lines = this.removeCommentPrefix(linesNew);
		text = "/*" + lines[0];
		var _g3 = 1;
		var _g4 = lines.length;
		while(_g3 < _g4) {
			var index1 = _g3++;
			text += this.parsedCode.lineSeparator;
			var line1 = StringTools.rtrim(lines[index1]);
			var lineIndent = indent;
			var lastLine = index1 == lines.length - 1;
			if(!lastLine) {
				++lineIndent;
			}
			if(startsWithStar) {
				lineIndent = indent;
			}
			if(!lastLine && line1.length <= 0) {
				lineIndent = 0;
			}
			if(!lastLine && startsWithStar) {
				line1 = " " + line1;
			}
			if(lastLine) {
				if(new EReg("^\\s*\\*\\s*[^\\s\\*]","").match(line1)) {
					line1 = " " + line1;
				}
				var leadingWS = new EReg("^\\s*}","");
				if(leadingWS.match(line1)) {
					line1 = StringTools.trim(line1);
				} else {
					if(new EReg("^\\s*[^*\\s]","").match(line1)) {
						lineIndent = indent + 1;
					}
					line1 = StringTools.rtrim(line1);
					if(!StringTools.endsWith(line1,"*")) {
						line1 += " ";
					}
				}
				if(new EReg("^\\s*$","").match(line1)) {
					line1 = " ";
				}
			}
			text += this.indenter.makeIndentString(lineIndent) + line1;
		}
		return text + "*/";
	}
	,removeCommentPrefix: function(lines) {
		var prefixReg = new EReg("^(\\s*)","");
		var prefix = null;
		var linesNew = [];
		var endIndex = lines.length - 1;
		var lastLine = lines[lines.length - 1];
		if(!new EReg("^\\s*(\\**$|\\})","").match(lastLine)) {
			endIndex = lines.length;
		}
		var _g = 1;
		var _g1 = endIndex;
		while(_g < _g1) {
			var index = _g++;
			var line = lines[index];
			prefixReg.match(line);
			var linePrefix = prefixReg.matched(1);
			if(linePrefix.length <= 0) {
				continue;
			}
			if(prefix == null || prefix.length > linePrefix.length) {
				prefix = linePrefix;
			}
		}
		if(prefix != null) {
			linesNew = [];
			var startPrefix = prefix + " *";
			var _g2 = 0;
			while(_g2 < lines.length) {
				var line1 = lines[_g2];
				++_g2;
				if(StringTools.startsWith(line1,startPrefix)) {
					line1 = HxOverrides.substr(line1,startPrefix.length - 1,null);
				}
				if(StringTools.startsWith(line1,prefix)) {
					line1 = HxOverrides.substr(line1,prefix.length,null);
				}
				linesNew.push(line1);
			}
			lines = linesNew;
		}
		var lastLine1 = lines[lines.length - 1];
		if(new EReg("^\\s*\\*\\**$","").match(lastLine1)) {
			lines[lines.length - 1] = StringTools.ltrim(lastLine1);
		}
		return lines;
	}
	,convertLeadingIndent: function(line) {
		var spaceIndent = StringTools.lpad(""," ",this.config.indentation.tabWidth);
		var oneIndent = this.config.indentation.character;
		var whitespaceReg = new EReg("^\\s+","");
		if(!whitespaceReg.match(line)) {
			return line;
		}
		var match = whitespaceReg.matched(0);
		if(this.config.indentation.character == "\t") {
			var newPrefix = StringTools.replace(match,spaceIndent,oneIndent);
			line = newPrefix + HxOverrides.substr(line,match.length,null);
		} else {
			var newPrefix1 = StringTools.replace(match,"\t",oneIndent);
			line = newPrefix1 + HxOverrides.substr(line,match.length,null);
		}
		return line;
	}
	,printCommentLine: function(text) {
		if(new EReg("^[/\\*\\-\\s]+","").match(text)) {
			return "//" + StringTools.rtrim(text);
		}
		if(this.config.whitespace.addLineCommentSpace) {
			return "// " + StringTools.trim(text);
		}
		return "//" + StringTools.trim(text);
	}
});
var formatter_marker_MarkWhitespace = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
};
formatter_marker_MarkWhitespace.__name__ = true;
formatter_marker_MarkWhitespace.__super__ = formatter_marker_MarkerBase;
formatter_marker_MarkWhitespace.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	run: function() {
		var _gthis = this;
		this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 0:
				var _g4 = _g.k;
				_gthis.markKeyword(token);
				break;
			case 1:
				var _g5 = _g.c;
				if(_g5._hx_index == 3) {
					switch(_g5.s) {
					case "final":
						_gthis.whitespace(token,"after");
						break;
					case "is":
						var parent = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(token),haxeparser_TokenDef.POpen);
						if(parent != null) {
							var prev = _gthis.getPreviousToken(parent);
							if(prev != null && prev.token.is(haxeparser_TokenDef.POpen)) {
								_gthis.whitespace(token,"around");
							}
						}
						_gthis.fixConstAfterConst(token);
						break;
					case "from":case "to":
						var parent1 = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(token)),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdAbstract));
						if(parent1 != null) {
							_gthis.whitespace(token,"around");
							_gthis.wrapBefore(token,true);
						}
						_gthis.fixConstAfterConst(token);
						break;
					default:
						_gthis.fixConstAfterConst(token);
					}
				} else {
					_gthis.fixConstAfterConst(token);
				}
				break;
			case 2:
				var _g3 = _g.s;
				_gthis.markSharp(token);
				break;
			case 3:
				var _g7 = _g.s;
				_gthis.markDollar(token);
				break;
			case 4:
				var _g2 = _g.op;
				_gthis.markUnop(token);
				break;
			case 5:
				switch(_g.op._hx_index) {
				case 1:
					if(tokentree_utils_TokenTreeCheckUtils.isImport(token.parent)) {
						_gthis.whitespace(token,"none");
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 3:
					if(tokentree_utils_TokenTreeCheckUtils.filterOpSub(token)) {
						var policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(_gthis.config.whitespace.binopPolicy,"after");
						var prev1 = _gthis.getPreviousToken(token);
						switch(prev1.token.tok._hx_index) {
						case 14:case 18:
							policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
							break;
						default:
						}
						_gthis.whitespace(token,policy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 7:
					_gthis.markGt(token);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
						_gthis.whitespace(token,_gthis.config.whitespace.typeParamOpenPolicy);
					} else {
						_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
					}
					break;
				case 21:
					_gthis.whitespace(token,_gthis.config.whitespace.intervalPolicy);
					break;
				case 23:
					_gthis.whitespace(token,"around");
					break;
				default:
					_gthis.whitespace(token,_gthis.config.whitespace.binopPolicy);
				}
				break;
			case 6:
				var _g9 = _g.s;
				_gthis.markComment(token);
				break;
			case 7:
				var _g8 = _g.s;
				_gthis.whitespace(token,"before");
				break;
			case 9:
				_gthis.markSemicolon(token);
				break;
			case 11:
				_gthis.markDblDot(token);
				break;
			case 12:
				_gthis.markArrow(token);
				break;
			case 13:
				_gthis.whitespace(token,_gthis.config.whitespace.commaPolicy);
				break;
			case 14:
				_gthis.successiveParenthesis(token,false,_gthis.config.whitespace.openingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 15:
				_gthis.successiveParenthesis(token,true,_gthis.config.whitespace.closingBracketPolicy,_gthis.config.whitespace.compressSuccessiveParenthesis);
				break;
			case 16:
				_gthis.markBrOpen(token);
				break;
			case 17:
				_gthis.markBrClose(token);
				break;
			case 18:
				_gthis.markPOpen(token);
				break;
			case 19:
				_gthis.markPClose(token);
				break;
			case 20:
				if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
					_gthis.whitespace(token,_gthis.config.whitespace.ternaryPolicy);
				} else {
					_gthis.whitespace(token,"noneAfter");
				}
				break;
			default:
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
	}
	,markGt: function(token) {
		if(tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension(token)) {
			this.whitespace(token,this.config.whitespace.typeExtensionPolicy);
			return;
		}
		if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token)) {
			var policy = this.config.whitespace.typeParamClosePolicy;
			var next = this.getNextToken(token);
			if(next != null) {
				var _g = next.token.tok;
				switch(_g._hx_index) {
				case 0:
					var _g2 = _g.k;
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"after");
					break;
				case 5:
					if(_g.op._hx_index == 7) {
						policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
					}
					break;
				case 9:case 13:
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
					break;
				case 17:case 19:
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
					break;
				default:
				}
			}
			this.whitespace(token,policy);
		} else {
			this.whitespace(token,this.config.whitespace.binopPolicy);
		}
	}
	,fixConstAfterConst: function(token) {
		var next = this.getNextToken(token);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 0:
				var _g2 = _g.k;
				this.whitespace(token,"after");
				break;
			case 1:
				var _g1 = _g.c;
				this.whitespace(token,"after");
				break;
			default:
			}
		}
	}
	,successiveParenthesis: function(token,closing,policy,compress) {
		var next = this.getNextToken(token);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 0:
				var _g2 = _g.k;
				if(closing) {
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"after");
				}
				break;
			case 5:
				switch(_g.op._hx_index) {
				case 7:
					if(token.is(haxeparser_TokenDef.BrClose)) {
						policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
					}
					break;
				case 22:
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"after");
					break;
				default:
				}
				break;
			case 9:case 10:case 11:case 13:
				policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
				break;
			default:
			}
		}
		if(!compress) {
			this.whitespace(token,policy);
			return;
		}
		if(closing) {
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 17:
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
					break;
				case 14:case 15:case 16:case 18:case 19:
					if(token.is(haxeparser_TokenDef.PClose)) {
						switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent)._hx_index) {
						case 1:
							policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"after");
							break;
						case 3:
							policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"after");
							break;
						case 4:
							policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"after");
							break;
						default:
							policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
						}
					} else {
						policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
					}
					break;
				default:
				}
			}
		} else {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				var _g1 = prev.token.tok;
				switch(_g1._hx_index) {
				case 5:
					switch(_g1.op._hx_index) {
					case 9:
						if(token.is(haxeparser_TokenDef.BrOpen)) {
							return;
						}
						break;
					case 21:
						policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
						break;
					default:
					}
					break;
				case 8:
					var _g21 = _g1.s;
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
					break;
				case 11:
					switch(prev.whitespaceAfter._hx_index) {
					case 0:
						policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
						break;
					case 1:
						policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"before");
						break;
					case 2:
						break;
					}
					break;
				case 12:
					return;
				case 13:
					var _g3 = this.config.whitespace.commaPolicy;
					if(_g3 != null) {
						switch(_g3) {
						case "after":case "around":case "onlyAfter":
							policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"before");
							break;
						default:
						}
					}
					break;
				case 14:case 16:case 18:
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
					break;
				default:
				}
			}
		}
		this.whitespace(token,policy);
	}
	,markKeyword: function(token) {
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 1:
				var _g1 = _g.c;
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 19:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			case 21:
				return;
			default:
			}
		}
		var _g2 = token.tok;
		if(_g2._hx_index == 0) {
			switch(_g2.k._hx_index) {
			case 3:case 4:
				this.whitespace(token,this.config.whitespace.ifPolicy);
				break;
			case 5:
				this.whitespace(token,this.config.whitespace.whilePolicy);
				break;
			case 6:
				this.whitespace(token,this.config.whitespace.doPolicy);
				break;
			case 7:
				this.whitespace(token,this.config.whitespace.forPolicy);
				break;
			case 9:case 16:case 23:case 36:case 37:case 38:
				var next = this.getNextToken(token);
				if(next != null) {
					var _g3 = next.token.tok;
					switch(_g3._hx_index) {
					case 0:
						var _g11 = _g3.k;
						this.whitespace(token,"after");
						return;
					case 1:
						var _g21 = _g3.c;
						if(_g21._hx_index == 3) {
							var _g31 = _g21.s;
							this.whitespace(token,"after");
							return;
						}
						break;
					case 20:
						this.whitespace(token,"after");
						return;
					default:
					}
				}
				this.whitespace(token,"noneAfter");
				break;
			case 10:
				this.whitespace(token,"after");
				break;
			case 11:case 12:
				this.whitespace(token,"around");
				break;
			case 14:
				this.whitespace(token,this.config.whitespace.switchPolicy);
				break;
			case 20:
				this.whitespace(token,this.config.whitespace.tryPolicy);
				break;
			case 21:
				this.whitespace(token,this.config.whitespace.catchPolicy);
				break;
			case 28:
				this.whitespace(token,"after");
				break;
			default:
				var next1 = this.getNextToken(token);
				if(next1 != null) {
					switch(next1.token.tok._hx_index) {
					case 10:
						return;
					case 18:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	,markUnop: function(token) {
		var next = this.getNextToken(token);
		if(next != null) {
			switch(next.token.tok._hx_index) {
			case 9:case 13:
				return;
			case 15:case 17:case 19:
				return;
			default:
			}
		}
		var prev = this.getPreviousToken(token);
		if(prev == null) {
			return;
		}
		var _g = prev.token.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				var _g3 = token.tok;
				if(_g3._hx_index == 4) {
					switch(_g3.op._hx_index) {
					case 2:case 3:case 4:
						return;
					default:
					}
				}
				this.whitespace(token,"after");
			}
		}
	}
	,markDollar: function(token) {
		var next = this.getNextToken(token);
		if(next == null) {
			return;
		}
		var _g = next.token.tok;
		switch(_g._hx_index) {
		case 0:
			var _g1 = _g.k;
			this.whitespace(token,"after");
			break;
		case 1:
			var _g2 = _g.c;
			this.whitespace(token,"after");
			break;
		default:
		}
	}
	,markDblDot: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getColonType(token);
		switch(type._hx_index) {
		case 0:
			this.whitespace(token,this.config.whitespace.caseColonPolicy);
			break;
		case 1:
			this.whitespace(token,this.config.whitespace.typeHintColonPolicy);
			break;
		case 2:
			this.whitespace(token,this.config.whitespace.typeCheckColonPolicy);
			break;
		case 3:
			this.whitespace(token,this.config.whitespace.ternaryPolicy);
			break;
		case 4:
			this.whitespace(token,this.config.whitespace.objectFieldColonPolicy);
			break;
		case 5:
			this.whitespace(token,"none");
			break;
		case 6:
			this.whitespace(token,this.config.whitespace.colonPolicy);
			break;
		}
	}
	,markSemicolon: function(token) {
		var next = this.getNextToken(token);
		var policy = this.config.whitespace.semicolonPolicy;
		if(next != null) {
			if(next.token.tok._hx_index == 17) {
				policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
			}
		}
		this.whitespace(token,policy);
	}
	,markSharp: function(token) {
		var _g = token.tok;
		if(_g._hx_index == 2) {
			switch(_g.s) {
			case "else":
				this.whitespace(token,"around");
				break;
			case "elseif":
				this.whitespace(token,"around");
				break;
			case "end":
				var prev = this.getPreviousToken(token);
				if(prev != null) {
					switch(prev.token.tok._hx_index) {
					case 14:case 16:case 18:
						break;
					default:
						this.whitespace(token,"before");
					}
				}
				var next = this.getNextToken(token);
				if(next != null) {
					var _g1 = next.token.tok;
					switch(_g1._hx_index) {
					case 0:
						var _g2 = _g1.k;
						this.whitespace(token,"after");
						break;
					case 1:
						var _g11 = _g1.c;
						this.whitespace(token,"after");
						break;
					case 9:case 13:
						break;
					case 14:case 16:case 18:case 20:
						this.whitespace(token,"after");
						break;
					default:
					}
				}
				break;
			case "error":
				this.whitespace(token,"after");
				break;
			case "if":
				this.whitespace(token,"after");
				var prev1 = this.getPreviousToken(token);
				if(prev1 != null) {
					var _g3 = prev1.token.tok;
					switch(_g3._hx_index) {
					case 0:
						var _g21 = _g3.k;
						this.whitespace(token,"before");
						break;
					case 1:
						var _g12 = _g3.c;
						this.whitespace(token,"before");
						break;
					default:
					}
				}
				var next1 = this.getNextToken(token);
				if(next1 != null) {
					var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.getFirstChild());
					if(lastChild != null) {
						this.whitespace(lastChild,"after");
					}
				}
				break;
			default:
			}
		}
	}
	,markArrow: function(token) {
		var arrowType = tokentree_utils_TokenTreeCheckUtils.getArrowType(token);
		switch(arrowType._hx_index) {
		case 0:
			this.whitespace(token,this.config.whitespace.arrowFunctionsPolicy);
			break;
		case 1:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe3Policy);
			break;
		case 2:
			this.whitespace(token,this.config.whitespace.functionTypeHaxe4Policy);
			break;
		}
	}
	,determinePOpenPolicy: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token);
		switch(type._hx_index) {
		case 0:
			this.config.whitespace.parenConfig.metadataParens.openingPolicy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(this.config.whitespace.parenConfig.metadataParens.openingPolicy,"before");
			return this.config.whitespace.parenConfig.metadataParens;
		case 1:
			var _g = token.parent.tok;
			switch(_g._hx_index) {
			case 0:
				if(_g.k._hx_index == 22) {
					return this.config.whitespace.parenConfig.funcParamParens;
				} else {
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			case 1:
				var _g1 = _g.c;
				if(_g1._hx_index == 3) {
					var _g2 = _g1.s;
					return this.config.whitespace.parenConfig.funcParamParens;
				} else {
					return this.config.whitespace.parenConfig.anonFuncParamParens;
				}
				break;
			default:
				return this.config.whitespace.parenConfig.anonFuncParamParens;
			}
			break;
		case 2:
			return this.config.whitespace.parenConfig.callParens;
		case 3:
			return this.config.whitespace.parenConfig.conditionParens;
		case 4:
			return this.config.whitespace.parenConfig.forLoopParens;
		case 5:
			return this.config.whitespace.parenConfig.expressionParens;
		}
	}
	,markPOpen: function(token) {
		var openClosePolicy = this.determinePOpenPolicy(token);
		var policy = openClosePolicy.openingPolicy;
		var prev = this.getPreviousToken(token);
		if(prev != null) {
			var _g = prev.token.tok;
			switch(_g._hx_index) {
			case 4:
				var _g1 = _g.op;
				policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
				break;
			case 5:
				var _g2 = _g.op;
				if(prev.spacesAfter > 0) {
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"before");
				}
				break;
			case 6:
				var _g3 = _g.s;
				if(prev.spacesAfter > 0) {
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.add(policy,"before");
				}
				break;
			default:
			}
		}
		if(openClosePolicy.removeInnerWhenEmpty) {
			var next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 19) {
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markPClose: function(token) {
		var openClosePolicy = this.determinePOpenPolicy(token.parent);
		var policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 18) {
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,determineBrOpenPolicy: function(token) {
		var type = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token);
		switch(type._hx_index) {
		case 0:
			return this.config.whitespace.bracesConfig.blockBraces;
		case 1:
			return this.config.whitespace.bracesConfig.typedefBraces;
		case 2:
			return this.config.whitespace.bracesConfig.objectLiteralBraces;
		case 3:
			return this.config.whitespace.bracesConfig.anonTypeBraces;
		case 4:
			return this.config.whitespace.bracesConfig.unknownBraces;
		}
	}
	,markBrOpen: function(token) {
		var openClosePolicy = this.determineBrOpenPolicy(token);
		var policy = openClosePolicy.openingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var next = this.getNextToken(token);
			if(next != null) {
				if(next.token.tok._hx_index == 17) {
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
				}
			}
		}
		this.successiveParenthesis(token,false,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markBrClose: function(token) {
		var openClosePolicy = this.determineBrOpenPolicy(token.parent);
		var policy = openClosePolicy.closingPolicy;
		if(openClosePolicy.removeInnerWhenEmpty) {
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				if(prev.token.tok._hx_index == 16) {
					policy = formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"before");
				}
			}
		}
		this.successiveParenthesis(token,true,policy,this.config.whitespace.compressSuccessiveParenthesis);
	}
	,markComment: function(token) {
		var policy = "around";
		var next = this.getNextToken(token);
		if(next == null) {
			this.whitespace(token,policy);
			return;
		}
		if(next.token.tok._hx_index == 13) {
			formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.remove(policy,"after");
		}
		this.whitespace(token,policy);
	}
});
var formatter_marker_wrapping_MarkWrappingBase = function(config,parsedCode,indenter) {
	formatter_marker_MarkerBase.call(this,config,parsedCode,indenter);
	this.wrappingQueue = [];
};
formatter_marker_wrapping_MarkWrappingBase.__name__ = true;
formatter_marker_wrapping_MarkWrappingBase.__super__ = formatter_marker_MarkerBase;
formatter_marker_wrapping_MarkWrappingBase.prototype = $extend(formatter_marker_MarkerBase.prototype,{
	noWrap: function(open,close) {
		var colon = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(open,haxeparser_TokenDef.BrOpen)),haxeparser_TokenDef.DblDot);
		if(colon != null) {
			var type = tokentree_utils_TokenTreeCheckUtils.getColonType(colon);
			switch(type._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				this.noLineEndBefore(open);
				break;
			case 5:
				break;
			case 6:
				break;
			}
		}
		this.noWrappingBetween(open,close);
		var _g = 0;
		var _g1 = open.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 5:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 9:case 13:
				continue;
			case 15:case 17:case 19:
				break _hx_loop1;
			default:
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				continue;
			} else {
				switch(lastChild.tok._hx_index) {
				case 9:case 13:
					this.noLineEndAfter(lastChild);
					break;
				default:
				}
			}
		}
		this.noLineEndBefore(close);
	}
	,keep2: function(open,close,items,addIndent,location) {
		var tokens = [];
		var _g = [];
		var _g1 = 0;
		while(_g1 < items.length) {
			var item = items[_g1];
			++_g1;
			_g.push(item.last);
		}
		tokens = _g;
		if(items.length > 0) {
			tokens.unshift(items[0].first);
		}
		var _g2 = [];
		var _g3 = 0;
		while(_g3 < items.length) {
			var item1 = items[_g3];
			++_g3;
			_g2.push(item1.first);
		}
		tokens = tokens.concat(_g2);
		if(close != null) {
			tokens.push(close);
		}
		tokens.push(close);
		var _g4 = 0;
		while(_g4 < tokens.length) {
			var token = tokens[_g4];
			++_g4;
			if(this.parsedCode.isOriginalNewlineBefore(token)) {
				this.lineEndBefore(token);
				this.additionalIndent(token,addIndent);
			} else {
				this.noLineEndBefore(token);
				this.wrapBefore(token,false);
			}
		}
	}
	,keep: function(open,close,addIndent) {
		this.noWrappingBetween(open,close);
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var last = false;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 5:
				if(_g2.op._hx_index == 7) {
					continue;
				}
				break;
			case 9:case 13:
				continue;
			case 15:case 17:case 19:
				last = true;
				break;
			default:
			}
			if(this.parsedCode.isOriginalNewlineBefore(child)) {
				this.lineEndBefore(child);
				this.additionalIndent(child,addIndent);
			} else {
				this.noLineEndBefore(child);
				this.wrapBefore(child,false);
			}
			if(last) {
				break;
			}
		}
		if(!this.parsedCode.isOriginalNewlineBefore(open)) {
			this.noLineEndBefore(open);
		}
	}
	,wrapChildOneLineEach2: function(open,close,items,addIndent,location,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		switch(location) {
		case "afterLast":
			var _g = 0;
			while(_g < items.length) {
				var item = items[_g];
				++_g;
				this.additionalIndent(item.first,addIndent);
				this.lineEndBefore(item.first);
				var _g1 = item.last.tok;
				if(_g1._hx_index == 2) {
					var _g11 = _g1.s;
					this.lineEndBefore(item.last);
				}
			}
			break;
		case "beforeLast":
			var item1 = items[0];
			this.additionalIndent(item1.first,addIndent);
			this.lineEndBefore(item1.first);
			item1 = items.pop();
			var _g2 = 0;
			while(_g2 < items.length) {
				var it = items[_g2];
				++_g2;
				this.additionalIndent(it.last,addIndent);
				this.lineEndBefore(it.last);
			}
			items.push(item1);
			break;
		}
		if(keepFirst) {
			if(open != null) {
				this.noLineEndAfter(open);
			}
			var lastToken = items[items.length - 1].last;
			if(lastToken.tok._hx_index != 9) {
				var next = this.getNextToken(lastToken);
				if(next == null) {
					this.noLineEndAfter(lastToken);
					return;
				}
				var _g3 = next.token.tok;
				switch(_g3._hx_index) {
				case 0:
					switch(_g3.k._hx_index) {
					case 22:case 23:case 36:
						this.noLineEndAfter(lastToken);
						break;
					default:
					}
					break;
				case 9:
					break;
				default:
					this.noLineEndAfter(lastToken);
				}
			}
		} else {
			var lastToken1 = items[items.length - 1].last;
			var next1 = this.getNextToken(lastToken1);
			if(next1 == null) {
				this.lineEndAfter(lastToken1);
				return;
			}
			var _g4 = next1.token.tok;
			switch(_g4._hx_index) {
			case 0:
				switch(_g4.k._hx_index) {
				case 22:case 23:case 36:
					this.lineEndAfter(lastToken1);
					break;
				default:
				}
				break;
			case 9:
				break;
			case 14:case 16:case 18:
				break;
			default:
				this.lineEndAfter(lastToken1);
			}
		}
	}
	,wrapChildOneLineEach: function(open,close,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(!keepFirst) {
			this.lineEndAfter(open);
		}
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 2:
				var _g21 = _g2.s;
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 5:
				if(_g2.op._hx_index == 7) {
					if(keepFirst) {
						this.noLineEndBefore(child);
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 7:
				var _g3 = _g2.s;
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 15:case 17:case 19:
				if(keepFirst) {
					this.noLineEndBefore(child);
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				this.lineEndAfter(child);
			} else {
				this.lineEndAfter(lastChild);
			}
		}
		if(close == null) {
			return;
		}
		switch(close.tok._hx_index) {
		case 15:case 17:case 19:
			this.lineEndBefore(close);
			break;
		default:
		}
	}
	,wrapChildOneLineEachSharp: function(sharp,addIndent,keepFirst) {
		if(keepFirst == null) {
			keepFirst = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		var children = sharp.children;
		var skipFirst = false;
		this.lineEndBefore(sharp);
		var _g = sharp.tok;
		if(_g._hx_index == 2) {
			switch(_g.s) {
			case "else":
				this.lineEndAfter(sharp);
				break;
			case "elseif":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			case "end":
				this.lineEndAfter(sharp);
				return;
			case "if":
				this.lineEndAfter(tokentree_utils_TokenTreeCheckUtils.getLastToken(sharp.getFirstChild()));
				skipFirst = true;
				break;
			default:
			}
		}
		var _g2 = 0;
		while(_g2 < children.length) {
			var child = children[_g2];
			++_g2;
			if(skipFirst) {
				skipFirst = false;
				continue;
			}
			var _g21 = child.tok;
			switch(_g21._hx_index) {
			case 2:
				var _g4 = _g21.s;
				this.wrapChildOneLineEachSharp(child,addIndent,keepFirst);
				break;
			case 5:
				if(_g21.op._hx_index == 7) {
					if(keepFirst) {
						this.whitespace(child,"noneBefore");
					}
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 7:
				var _g5 = _g21.s;
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 15:case 17:case 19:
				if(keepFirst) {
					this.whitespace(child,"noneBefore");
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
		}
	}
	,wrapFillLine2AfterLast: function(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		var first = false;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				this.noLineEndBefore(item.first);
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			var lastItem = items[items.length - 1];
			var lengthAfter = this.calcLineLengthAfter(lastItem.last);
			if(lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(lastItem.first);
				this.additionalIndent(lastItem.first,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	,wrapFillLineWithLeading2AfterLast: function(open,close,items,maxLineLength,addIndent) {
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
		var first = true;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(lineLength + tokenLength >= maxLineLength) {
				this.lineEndBefore(item.first);
				this.additionalIndent(item.first,addIndent);
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				if(item.multiline) {
					lineLength = item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(!first) {
					this.noLineEndBefore(item.first);
				} else {
					this.lineEndBefore(item.first);
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = item.lastLineLength;
				}
			}
		}
		var lastItem = items[items.length - 1];
		switch(lastItem.last.tok._hx_index) {
		case 9:
			break;
		case 11:
			break;
		case 15:case 17:case 19:
			if(this.isNewLineAfter(lastItem.last)) {
				this.lineEndAfter(lastItem.last);
			}
			break;
		default:
			this.lineEndAfter(lastItem.last);
		}
	}
	,wrapFillLine2BeforeLast: function(open,close,items,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		if(items.length <= 0) {
			return;
		}
		var lineStart = open;
		if(lineStart == null) {
			lineStart = items[0].first;
		}
		lineStart = this.findLineStartToken(lineStart);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent) + this.calcTokenLength(open);
		var first = true;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var tokenLength = item.firstLineLength;
			if(!first && lineLength + tokenLength >= maxLineLength) {
				lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent);
				var prev = this.getPreviousToken(item.first);
				if(prev != null) {
					this.lineEndBefore(prev.token);
					this.additionalIndent(prev.token,addIndent);
					lineLength += prev.text.length;
				}
				if(item.multiline) {
					lineLength += item.lastLineLength;
				} else {
					lineLength += item.firstLineLength;
				}
				continue;
			} else {
				if(first) {
					this.noLineEndBefore(item.first);
				} else {
					var prev1 = this.getPreviousToken(item.first);
					if(prev1 != null) {
						this.noLineEndBefore(prev1.token);
					}
				}
				lineLength += tokenLength;
				first = false;
				if(item.multiline) {
					lineLength = this.indenter.calcAbsoluteIndent(indent + 1 + addIndent) + item.lastLineLength;
				}
			}
		}
		if(useTrailing) {
			var lastItem = items[items.length - 1];
			var lengthAfter = this.calcLineLengthAfter(lastItem.last);
			var prev2 = this.getPreviousToken(lastItem.first);
			if(prev2 != null && lineLength + lengthAfter >= maxLineLength) {
				this.lineEndBefore(prev2.token);
				this.additionalIndent(prev2.token,addIndent);
			}
		}
		this.noLineEndAfter(open);
		this.wrapAfter(open,false);
	}
	,wrapFillLine: function(open,close,maxLineLength,addIndent,useTrailing) {
		if(useTrailing == null) {
			useTrailing = false;
		}
		if(addIndent == null) {
			addIndent = 0;
		}
		var lineStart = this.findLineStartToken(open);
		if(lineStart == null) {
			return;
		}
		var indent = this.indenter.calcIndent(lineStart);
		var lineLength = this.calcLineLengthBefore(open) + this.indenter.calcAbsoluteIndent(indent + addIndent);
		var first = true;
		var _g = 0;
		var _g1 = open.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 0:
				if(_g2.k._hx_index == 0) {
					continue;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 5:
				if(_g2.op._hx_index == 7) {
					this.whitespace(child,"noneBefore");
					return;
				} else {
					this.additionalIndent(child,addIndent);
				}
				break;
			case 7:
				var _g3 = _g2.s;
				var prev = this.getPreviousToken(child);
				if(prev != null) {
					if(this.parsedCode.isOriginalSameLine(child,prev.token)) {
						this.noLineEndBefore(child);
					}
				}
				this.lineEndAfter(child);
				this.additionalIndent(child,addIndent);
				continue;
			case 16:
				continue;
			case 15:case 17:case 19:
				this.whitespace(child,"noneBefore");
				if(useTrailing) {
					var trailing = this.calcLineLengthAfter(child);
					if(trailing + lineLength > maxLineLength) {
						var prev1 = child.previousSibling;
						if(prev1 == null) {
							return;
						}
						this.lineEndBefore(prev1);
						this.additionalIndent(prev1,addIndent);
					}
				}
				return;
			default:
				this.additionalIndent(child,addIndent);
			}
			var tokenLength = this.calcLength(child);
			var lastChild = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
			if(lastChild == null) {
				lastChild = child;
			}
			lineLength += tokenLength;
			if(lineLength > maxLineLength) {
				this.lineEndBefore(child);
				this.noLineEndAfter(lastChild);
				indent = this.indenter.calcIndent(child);
				lineLength = tokenLength + this.indenter.calcAbsoluteIndent(indent);
			} else {
				this.noLineEndAfter(lastChild);
			}
			if(first) {
				first = false;
				this.noLineEndBefore(child);
			}
		}
	}
	,calcLineLength: function(token) {
		var indent = this.indenter.calcIndent(token);
		return formatter_marker_MarkerBase.prototype.calcLineLength.call(this,token) + this.indenter.calcAbsoluteIndent(indent);
	}
	,hasEmptyFunctionBody: function(token) {
		var last = token.getLastChild();
		if(last.tok._hx_index == 9) {
			return true;
		}
		var body = token.nextSibling;
		if(body == null) {
			return true;
		}
		if(body.is(haxeparser_TokenDef.DblDot)) {
			body = body.nextSibling;
		}
		while(body != null && body.is(haxeparser_TokenDef.At)) body = body.nextSibling;
		if(body == null) {
			return true;
		}
		switch(body.tok._hx_index) {
		case 9:
			return true;
		case 16:
			var brClose = body.getFirstChild();
			if(brClose == null) {
				return false;
			}
			return brClose.is(haxeparser_TokenDef.BrClose);
		default:
			return false;
		}
	}
	,makeWrappableItems: function(token) {
		var items = [];
		var lastIndex = -1;
		var _g = 0;
		var _g1 = token.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 5:
				if(_g2.op._hx_index == 7) {
					return items;
				}
				break;
			case 15:case 17:case 19:
				return items;
			default:
			}
			if(child.index <= lastIndex) {
				continue;
			}
			var endToken = this.findItemEnd(child);
			if(endToken == null) {
				continue;
			}
			lastIndex = endToken.index;
			var sameLine = this.isSameLineBetween(child,endToken,false);
			var firstLineLength = this.calcLengthUntilNewline(child,endToken);
			if(this.isMultilineToken(endToken)) {
				sameLine = false;
			}
			var lastLineLength = 0;
			if(!sameLine) {
				lastLineLength = this.calcLineLengthAfter(endToken);
			}
			var item = { first : child, last : endToken, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
			items.push(item);
		}
		return items;
	}
	,findItemEnd: function(child) {
		var endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
		if(endToken == null) {
			return null;
		}
		if(endToken.tok._hx_index == 13) {
			var next = this.getNextToken(endToken);
			if(next == null) {
				return endToken;
			}
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 6:
				var s = _g.s;
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			case 7:
				var s1 = _g.s;
				if(this.parsedCode.isOriginalSameLine(endToken,next.token)) {
					return next.token;
				}
				break;
			default:
			}
			return endToken;
		}
		var next1 = this.getNextToken(endToken);
		if(next1 == null) {
			return endToken;
		}
		var _g1 = next1.token.tok;
		switch(_g1._hx_index) {
		case 5:
			if(_g1.op._hx_index == 7) {
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(next1.token),haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt)) != null) {
					return endToken;
				}
				return this.findItemEnd(next1.token);
			} else {
				return this.findItemEnd(next1.token);
			}
			break;
		case 6:
			var _g4 = _g1.s;
			return this.findItemEnd(next1.token);
		case 7:
			var _g3 = _g1.s;
			return this.findItemEnd(next1.token);
		default:
		}
		return endToken;
	}
	,determineWrapType2: function(rules,token,items) {
		var itemCount = items.length;
		if(items.length <= 0) {
			return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
		}
		var maxItemLength = 0;
		var totalItemLength = 0;
		var lineLength = this.calcLineLength(token);
		var hasMultiLineItem = false;
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			totalItemLength += item.firstLineLength + item.lastLineLength;
			if(item.multiline) {
				hasMultiLineItem = true;
			}
			var length = Math.floor(Math.max(item.firstLineLength,item.lastLineLength));
			if(length > maxItemLength) {
				maxItemLength = length;
			}
		}
		var _g1 = 0;
		var _g2 = rules.rules;
		while(_g1 < _g2.length) {
			var rule = _g2[_g1];
			++_g1;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	,determineWrapType: function(rules,itemCount,maxItemLength,totalItemLength,lineLength) {
		var _g = 0;
		var _g1 = rules.rules;
		while(_g < _g1.length) {
			var rule = _g1[_g];
			++_g;
			if(this.matchesRule(rule,itemCount,maxItemLength,totalItemLength,lineLength,false)) {
				return rule;
			}
		}
		return { conditions : [], type : rules.defaultWrap, location : rules.defaultLocation, additionalIndent : rules.defaultAdditionalIndent};
	}
	,matchesRule: function(rule,itemCount,maxItemLength,totalItemLength,lineLength,hasMultiLineItem) {
		var _g = 0;
		var _g1 = rule.conditions;
		while(_g < _g1.length) {
			var cond = _g1[_g];
			++_g;
			switch(cond.cond) {
			case "anyItemLength <= n":
				if(maxItemLength > cond.value) {
					return false;
				}
				break;
			case "anyItemLength >= n":
				if(maxItemLength < cond.value) {
					return false;
				}
				break;
			case "hasMultilineItems":
				if(cond.value == 1) {
					if(!hasMultiLineItem) {
						return false;
					}
				} else if(hasMultiLineItem) {
					return false;
				}
				break;
			case "itemCount <= n":
				if(itemCount > cond.value) {
					return false;
				}
				break;
			case "itemCount >= n":
				if(itemCount < cond.value) {
					return false;
				}
				break;
			case "lineLength <= n":
				if(lineLength > cond.value) {
					return false;
				}
				break;
			case "lineLength >= n":
				if(lineLength < cond.value) {
					return false;
				}
				break;
			case "totalItemLength <= n":
				if(totalItemLength > cond.value) {
					return false;
				}
				break;
			case "totalItemLength >= n":
				if(totalItemLength < cond.value) {
					return false;
				}
				break;
			}
		}
		return true;
	}
	,applyRule: function(rule,open,close,items,addIndent,useTrailing) {
		var location = "afterLast";
		if(rule.location != null) {
			location = rule.location;
		}
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			switch(location) {
			case "afterLast":
				this.wrapFillLine2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "fillLineWithLeadingBreak":
			switch(location) {
			case "afterLast":
				this.wrapFillLineWithLeading2AfterLast(open,close,items,this.config.wrapping.maxLineLength,addIndent);
				break;
			case "beforeLast":
				this.wrapFillLine2BeforeLast(open,close,items,this.config.wrapping.maxLineLength,addIndent,useTrailing);
				break;
			}
			break;
		case "keep":
			this.keep2(open,close,items,addIndent,location);
			break;
		case "noWrap":
			this.noWrappingBetween(open,close,false);
			break;
		case "onePerLine":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach2(open,close,items,addIndent,location,true);
			break;
		}
	}
	,applyWrappingQueue: function() {
		var _g = 0;
		var _g1 = this.wrappingQueue;
		while(_g < _g1.length) {
			var place = _g1[_g];
			++_g;
			this.applyWrappingPlace(place);
		}
	}
	,applyWrappingPlace: function(place) {
		var rule = this.determineWrapType2(place.rules,place.start,place.items);
		var additionalIndent = rule.additionalIndent;
		if(place.overrideAdditionalIndent != null) {
			additionalIndent = place.overrideAdditionalIndent;
		}
		this.applyRule(rule,place.start,place.end,place.items,additionalIndent,place.useTrailing);
	}
	,queueWrapping: function(place,name) {
		if(place.items == null || place.items.length <= 0) {
			return;
		}
		var startIndex = this.getPlaceStartIndex(place);
		var endIndex = this.getPlaceEndIndex(place);
		if(startIndex < 0 || endIndex < 0) {
			return;
		}
		var index = 0;
		var _g = 0;
		var _g1 = this.wrappingQueue.length;
		while(_g < _g1) {
			var index1 = _g++;
			var p = this.wrappingQueue[index1];
			var itemStart = this.getPlaceStartIndex(p);
			if(startIndex > itemStart) {
				continue;
			}
			if(startIndex == itemStart) {
				var itemEnd = this.getPlaceEndIndex(p);
				if(endIndex > itemEnd) {
					this.wrappingQueue.splice(index1,0,place);
					return;
				}
				continue;
			}
			this.wrappingQueue.splice(index1,0,place);
			return;
		}
		this.wrappingQueue.push(place);
	}
	,getPlaceStartIndex: function(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.start != null) {
			return place.start.index;
		} else {
			return place.items[0].first.index;
		}
	}
	,getPlaceEndIndex: function(place) {
		if(place.items == null || place.items.length <= 0) {
			return -1;
		}
		if(place.end != null) {
			return place.end.index;
		} else {
			return place.items[place.items.length - 1].last.index;
		}
	}
});
var formatter_marker_wrapping_MarkWrapping = function(config,parsedCode,indenter) {
	formatter_marker_wrapping_MarkWrappingBase.call(this,config,parsedCode,indenter);
};
formatter_marker_wrapping_MarkWrapping.__name__ = true;
formatter_marker_wrapping_MarkWrapping.__super__ = formatter_marker_wrapping_MarkWrappingBase;
formatter_marker_wrapping_MarkWrapping.prototype = $extend(formatter_marker_wrapping_MarkWrappingBase.prototype,{
	run: function() {
		var _gthis = this;
		var wrappableTokens = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			switch(_g._hx_index) {
			case 5:
				switch(_g.op._hx_index) {
				case 0:
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				case 9:
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				case 22:
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				default:
				}
				break;
			case 7:
				var _g2 = _g.s;
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			case 10:
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			case 12:
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			case 13:
				_gthis.wrapAfter(token,true);
				return tokentree_FilterResult.GO_DEEPER;
			case 14:
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			case 16:
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			case 18:
				return tokentree_FilterResult.FOUND_GO_DEEPER;
			default:
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
		wrappableTokens.reverse();
		var _g1 = 0;
		while(_g1 < wrappableTokens.length) {
			var token1 = wrappableTokens[_g1];
			++_g1;
			var _g3 = token1.tok;
			switch(_g3._hx_index) {
			case 5:
				switch(_g3.op._hx_index) {
				case 0:
					this.wrapAfter(token1,true);
					break;
				case 9:
					if(tokentree_utils_TokenTreeCheckUtils.isTypeParameter(token1)) {
						this.wrapTypeParameter(token1);
					}
					break;
				case 22:
					this.wrapAfter(token1,true);
					break;
				default:
				}
				break;
			case 7:
				var _g21 = _g3.s;
				this.wrapBefore(token1,false);
				break;
			case 10:
				break;
			case 12:
				this.wrapAfter(token1,true);
				break;
			case 14:
				this.arrayWrapping(token1);
				break;
			case 16:
				this.markBrWrapping(token1);
				break;
			case 18:
				this.markPWrapping(token1);
				break;
			default:
			}
		}
		this.markMethodChaining(this.parsedCode.root);
		this.markMultiVarChaining();
		this.markImplementsExtendsChaining();
		this.markOpBoolChaining();
		this.markOpAddChaining();
		this.applyWrappingQueue();
	}
	,wrapTypeParameter: function(token) {
		var close = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		this.queueWrapping({ start : token, end : null, items : items, rules : this.config.wrapping.typeParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapTypeParameter");
		return;
	}
	,markBrWrapping: function(token) {
		switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
		case 0:
			break;
		case 1:
			this.typedefWrapping(token);
			break;
		case 2:
			this.objectLiteralWrapping(token);
			break;
		case 3:
			this.anonTypeWrapping(token);
			break;
		case 4:
			break;
		}
	}
	,typedefWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(this.isNewLineBefore(token)) {
			return;
		}
		if(this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.noWrap(token,brClose);
			return;
		}
	}
	,anonTypeWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		var next = this.getNextToken(brClose);
		if(next != null) {
			var _g = next.token.tok;
			switch(_g._hx_index) {
			case 0:
				var _g4 = _g.k;
				this.lineEndAfter(brClose);
				break;
			case 1:
				var _g2 = _g.c;
				if(_g2._hx_index == 3) {
					switch(_g2.s) {
					case "from":case "to":
						this.noLineEndAfter(brClose);
						break;
					default:
						this.lineEndAfter(brClose);
					}
				} else {
					this.lineEndAfter(brClose);
				}
				break;
			case 5:
				if(_g.op._hx_index == 7) {
					this.noLineEndAfter(brClose);
					this.whitespace(brClose,"noneAfter");
				}
				break;
			case 16:
				switch(this.config.lineEnds.leftCurly) {
				case "after":case "none":
					this.noLineEndAfter(brClose);
					break;
				case "before":case "both":
					break;
				}
				break;
			default:
			}
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		var maxLength = 0;
		var totalLength = 0;
		var itemCount = 0;
		var _g1 = 0;
		var _g11 = token.children;
		_hx_loop1: while(_g1 < _g11.length) {
			var child = _g11[_g1];
			++_g1;
			var _g3 = child.tok;
			switch(_g3._hx_index) {
			case 7:
				var _g12 = _g3.s;
				this.wrapChildOneLineEach(token,brClose,0);
				return;
			case 17:
				break _hx_loop1;
			default:
			}
			var length = this.calcLength(child);
			totalLength += length;
			if(length > maxLength) {
				maxLength = length;
			}
			++itemCount;
		}
		var lineLength = this.calcLineLength(token);
		var rule = this.determineWrapType(this.config.wrapping.anonType,itemCount,maxLength,totalLength,lineLength);
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "fillLineWithLeadingBreak":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "keep":
			this.keep(token,brClose,rule.additionalIndent);
			break;
		case "noWrap":
			this.noWrap(token,brClose);
			var prev = this.getPreviousToken(token);
			if(prev == null) {
				return;
			}
			switch(prev.whitespaceAfter._hx_index) {
			case 0:
				break;
			case 1:
				break;
			case 2:
				prev.whitespaceAfter = formatter_codedata_WhitespaceAfterType.Space;
				break;
			}
			break;
		case "onePerLine":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent,true);
			break;
		}
	}
	,objectLiteralWrapping: function(token) {
		var brClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 1) {
			return;
		}
		if(token.index + 1 == brClose.index) {
			this.whitespace(token,"noneAfter");
			this.whitespace(brClose,"noneBefore");
			return;
		}
		if(!this.parsedCode.isOriginalSameLine(token,brClose)) {
			this.wrapChildOneLineEach(token,brClose,0);
			return;
		}
		var maxLength = 0;
		var totalLength = 0;
		var itemCount = 0;
		var _g = 0;
		var _g1 = token.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 7:
				var _g11 = _g2.s;
				this.wrapChildOneLineEach(token,brClose,0);
				return;
			case 17:
				break _hx_loop1;
			default:
			}
			var length = this.calcLength(child);
			totalLength += length;
			if(length > maxLength) {
				maxLength = length;
			}
			++itemCount;
		}
		var lineLength = this.calcLineLength(token);
		var rule = this.determineWrapType(this.config.wrapping.objectLiteral,itemCount,maxLength,totalLength,lineLength);
		switch(rule.type) {
		case "equalNumber":
			break;
		case "fillLine":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "fillLineWithLeadingBreak":
			this.wrapFillLine(token,brClose,this.config.wrapping.maxLineLength,rule.additionalIndent);
			break;
		case "keep":
			this.keep(token,brClose,rule.additionalIndent);
			break;
		case "noWrap":
			this.noWrap(token,brClose);
			var next = this.getNextToken(brClose);
			if(next != null) {
				switch(next.token.tok._hx_index) {
				case 11:
					this.noLineEndAfter(brClose);
					break;
				case 10:case 13:
					this.whitespace(brClose,"noneAfter");
					break;
				default:
				}
			}
			var prev = this.getPreviousToken(token);
			if(prev != null) {
				var _g21 = prev.token.tok;
				switch(_g21._hx_index) {
				case 0:
					var _g4 = _g21.k;
					this.noLineEndBefore(token);
					this.whitespace(token,"before");
					break;
				case 5:
					var _g3 = _g21.op;
					this.noLineEndBefore(token);
					break;
				case 13:case 18:
					this.noLineEndBefore(token);
					break;
				default:
				}
			}
			break;
		case "onePerLine":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent);
			break;
		case "onePerLineAfterFirst":
			this.wrapChildOneLineEach(token,brClose,rule.additionalIndent,true);
			break;
		}
	}
	,markPWrapping: function(token) {
		var pClose = this.getCloseToken(token);
		switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(token)._hx_index) {
		case 0:
			this.wrapMetadataCallParameter(token);
			break;
		case 1:
			this.wrapFunctionSignature(token);
			break;
		case 2:
			this.wrapCallParameter(token);
			break;
		case 3:
			break;
		case 4:
			break;
		case 5:
			break;
		}
	}
	,arrayWrapping: function(token) {
		var bkClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		var itemsWithoutMetadata = [];
		var _g = 0;
		while(_g < items.length) {
			var item = items[_g];
			++_g;
			var _g1 = item.first.tok;
			switch(_g1._hx_index) {
			case 0:
				switch(_g1.k._hx_index) {
				case 5:case 7:
					if(this.config.sameLine.comprehensionFor == "keep") {
						return;
					}
					itemsWithoutMetadata.push(item);
					break;
				default:
					itemsWithoutMetadata.push(item);
				}
				break;
			case 21:
				if(item.firstLineLength > 30) {
					this.lineEndBefore(token);
					this.lineEndBefore(item.first);
				}
				break;
			default:
				itemsWithoutMetadata.push(item);
			}
		}
		if(this.config.wrapping.arrayMatrixWrap != "noMatrixWrap") {
			if(this.tryMatrixWrap(token,bkClose,itemsWithoutMetadata)) {
				return;
			}
		}
		this.applyWrappingPlace({ start : token, end : bkClose, items : itemsWithoutMetadata, rules : this.config.wrapping.arrayWrap, useTrailing : true, overrideAdditionalIndent : null});
	}
	,tryMatrixWrap: function(open,close,items) {
		var prev = null;
		var run = 1;
		var lineRun = 0;
		var _g = 0;
		var _g1 = items.length;
		while(_g < _g1) {
			var index = _g++;
			var item = items[index];
			if(prev == null) {
				prev = item;
				continue;
			}
			if(item.multiline) {
				return false;
			}
			if(this.parsedCode.isOriginalSameLine(prev.first,item.first)) {
				++run;
				prev = item;
				continue;
			}
			if(lineRun != 0) {
				if(lineRun != run) {
					return false;
				}
			}
			lineRun = run;
			run = 1;
			prev = item;
		}
		if(lineRun <= 1) {
			return false;
		}
		if(lineRun != run) {
			return false;
		}
		this.lineEndAfter(open);
		if(this.config.wrapping.arrayMatrixWrap == "matrixWrapWithAlign") {
			var _g2 = [];
			var _g3 = 0;
			var _g4 = lineRun;
			while(_g3 < _g4) {
				var i = _g3++;
				_g2.push(0);
			}
			var maxCols = _g2;
			var _g5 = 0;
			var _g6 = items.length;
			while(_g5 < _g6) {
				var index1 = _g5++;
				var item1 = items[index1];
				var col = index1 % lineRun;
				if(item1.firstLineLength > maxCols[col]) {
					maxCols[col] = item1.firstLineLength;
				}
			}
			var _g7 = 0;
			var _g8 = items.length;
			while(_g7 < _g8) {
				var index2 = _g7++;
				var item2 = items[index2];
				var expectedLength = maxCols[index2 % lineRun];
				if(index2 == items.length - 1) {
					if(item2.last.tok._hx_index == 13) {
						--expectedLength;
					} else {
						expectedLength -= 2;
					}
				}
				if(item2.firstLineLength < expectedLength) {
					this.spacesBefore(item2.first,expectedLength - item2.firstLineLength);
				}
			}
		}
		var index3 = lineRun - 1;
		while(index3 < items.length) {
			var item3 = items[index3];
			this.lineEndAfter(item3.last);
			index3 += lineRun;
		}
		return true;
	}
	,calcLineLength: function(token) {
		if(token == null) {
			return 0;
		}
		return formatter_marker_wrapping_MarkWrappingBase.prototype.calcLineLength.call(this,token);
	}
	,wrapFunctionSignature: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var rules = this.config.wrapping.functionSignature;
		var _g = token.parent.tok;
		if(_g._hx_index == 0) {
			if(_g.k._hx_index == 0) {
				rules = this.config.wrapping.anonFunctionSignature;
			}
		}
		var emptyBody = this.hasEmptyFunctionBody(token);
		var items = this.makeWrappableItems(token);
		var addIndent = null;
		if(emptyBody) {
			addIndent = 0;
		}
		this.queueWrapping({ start : token, end : pClose, items : items, rules : rules, useTrailing : true, overrideAdditionalIndent : addIndent},"wrapFunctionSignature");
	}
	,wrapCallParameter: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		this.queueWrapping({ start : token, end : pClose, items : items, rules : this.config.wrapping.callParameter, useTrailing : true, overrideAdditionalIndent : null},"wrapCallParameter");
	}
	,wrapMetadataCallParameter: function(token) {
		var pClose = this.getCloseToken(token);
		if(token.children == null || token.children.length <= 0) {
			return;
		}
		var items = this.makeWrappableItems(token);
		this.queueWrapping({ start : token, end : pClose, items : items, rules : this.config.wrapping.metadataCallParameter, useTrailing : false, overrideAdditionalIndent : null},"wrapMetadataCallParameter");
	}
	,markMethodChaining: function(startToken) {
		var _gthis = this;
		if(startToken == null) {
			return;
		}
		var chainStarts = startToken.filterCallback(function(token,index) {
			if(token.tok._hx_index == 10) {
				var prev = _gthis.getPreviousToken(token);
				if(prev == null) {
					return tokentree_FilterResult.GO_DEEPER;
				}
				if(prev.token.tok._hx_index == 19) {
					_gthis.wrapBefore(token,true);
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				}
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
		var _g = 0;
		while(_g < chainStarts.length) {
			var chainStart = chainStarts[_g];
			++_g;
			this.markInternalMethodChaining(chainStart);
			this.markSingleMethodChain(chainStart);
		}
	}
	,markInternalMethodChaining: function(startToken) {
		var _gthis = this;
		startToken.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 14:case 16:case 18:
				_gthis.markMethodChaining(token);
				break;
			default:
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
	}
	,markSingleMethodChain: function(chainStart) {
		var _gthis = this;
		var chainedCalls = chainStart.filterCallback(function(token,index) {
			switch(token.tok._hx_index) {
			case 10:
				var prev = _gthis.getPreviousToken(token);
				if(prev == null) {
					return tokentree_FilterResult.GO_DEEPER;
				}
				if(prev.token.tok._hx_index == 19) {
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				}
				break;
			case 14:case 16:case 18:
				return tokentree_FilterResult.SKIP_SUBTREE;
			default:
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
		var firstMethodCall = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(chainStart))),haxeparser_TokenDef.Dot);
		if(firstMethodCall != null) {
			chainedCalls.unshift(firstMethodCall);
			chainStart = firstMethodCall;
		}
		var items = [];
		var chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainStart);
		var info = this.getPreviousToken(chainStart);
		var chainOpen = chainStart.parent;
		if(info != null) {
			chainOpen = info.token;
		}
		var _g = 0;
		var _g1 = chainedCalls.length;
		while(_g < _g1) {
			var index1 = _g++;
			var child = chainedCalls[index1];
			var endToken = chainEnd;
			if(index1 + 1 < chainedCalls.length) {
				var next = chainedCalls[index1 + 1];
				info = this.getPreviousToken(next);
				if(info != null) {
					endToken = info.token;
				}
			}
			items.push(this.makeWrappableItem(child,endToken));
		}
		chainEnd = null;
		if(chainOpen != null) {
			chainEnd = this.getCloseToken(chainOpen);
		}
		this.queueWrapping({ start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.methodChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleMethodChain");
	}
	,markOpBoolChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SKIP_SUBTREE;
			}
			var _g = 0;
			var _g1 = token.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				var _g2 = child.tok;
				if(_g2._hx_index == 5) {
					switch(_g2.op._hx_index) {
					case 14:case 15:
						return tokentree_FilterResult.FOUND_GO_DEEPER;
					default:
					}
				}
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
		var _g3 = 0;
		while(_g3 < chainStarts.length) {
			var chainStart = chainStarts[_g3];
			++_g3;
			this.markSingleOpBoolChain(chainStart);
		}
	}
	,markSingleOpBoolChain: function(itemStart) {
		var items = [];
		var firstItemStart = itemStart;
		var _g = itemStart.tok;
		if(_g._hx_index == 5) {
			var _g1 = _g.op;
			if(itemStart.previousSibling != null) {
				firstItemStart = itemStart.previousSibling;
			}
		}
		var prev = this.getPreviousToken(firstItemStart);
		var chainStart = itemStart;
		if(prev != null) {
			chainStart = prev.token;
		}
		var chainEnd = itemStart.getLastChild();
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 9:case 13:case 19:
				break;
			default:
				var next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		var first = true;
		var _g2 = 0;
		var _g3 = itemStart.children;
		while(_g2 < _g3.length) {
			var child = _g3[_g2];
			++_g2;
			var _g21 = child.tok;
			if(_g21._hx_index == 5) {
				switch(_g21.op._hx_index) {
				case 14:case 15:
					if(first) {
						itemStart = firstItemStart;
						first = false;
					}
					items.push(this.makeWrappableItem(itemStart,child));
					var next1 = this.getNextToken(child);
					if(next1 == null) {
						return;
					}
					itemStart = next1.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ start : chainStart, end : chainEnd, items : items, rules : this.config.wrapping.opBoolChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpBoolChain");
	}
	,markOpAddChaining: function() {
		var chainStarts = this.parsedCode.root.filterCallback(function(token,index) {
			if(!token.hasChildren()) {
				return tokentree_FilterResult.SKIP_SUBTREE;
			}
			var _g = 0;
			var _g1 = token.children;
			while(_g < _g1.length) {
				var child = _g1[_g];
				++_g;
				var _g2 = child.tok;
				if(_g2._hx_index == 5) {
					switch(_g2.op._hx_index) {
					case 0:case 3:
						return tokentree_FilterResult.FOUND_GO_DEEPER;
					default:
					}
				}
			}
			return tokentree_FilterResult.GO_DEEPER;
		});
		var _g3 = 0;
		while(_g3 < chainStarts.length) {
			var chainStart = chainStarts[_g3];
			++_g3;
			this.markSingleOpAddChain(chainStart);
		}
	}
	,markSingleOpAddChain: function(itemContainer) {
		var items = [];
		var prev = this.getPreviousToken(this.findOpAddItemStart(itemContainer));
		var chainStart = this.findOpAddItemStart(itemContainer);
		var chainEnd = itemContainer.getLastChild();
		if(chainStart.tok._hx_index == 18) {
			var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(chainStart);
			switch(type._hx_index) {
			case 0:
				return;
			case 1:
				break;
			case 2:
				break;
			case 3:
				break;
			case 4:
				break;
			case 5:
				break;
			}
		}
		if(chainEnd != null) {
			chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(chainEnd);
			switch(chainEnd.tok._hx_index) {
			case 9:case 13:
				break;
			default:
				var next = this.getNextToken(chainEnd);
				if(next != null) {
					chainEnd = next.token;
				}
			}
		}
		var next1 = this.getNextToken(chainStart);
		if(next1 == null) {
			return;
		}
		var itemStart = next1.token;
		var _g1 = 0;
		var _g2 = itemContainer.children;
		while(_g1 < _g2.length) {
			var child = _g2[_g1];
			++_g1;
			var _g11 = child.tok;
			if(_g11._hx_index == 5) {
				switch(_g11.op._hx_index) {
				case 0:case 3:
					items.push(this.makeWrappableItem(itemStart,child));
					var next2 = this.getNextToken(child);
					if(next2 == null) {
						continue;
					}
					itemStart = next2.token;
					break;
				default:
					continue;
				}
			} else {
				continue;
			}
		}
		items.push(this.makeWrappableItem(itemStart,tokentree_utils_TokenTreeCheckUtils.getLastToken(itemStart)));
		this.queueWrapping({ start : chainStart, end : null, items : items, rules : this.config.wrapping.opAddSubChain, useTrailing : false, overrideAdditionalIndent : null},"markSingleOpAddChain");
	}
	,findOpAddItemStart: function(itemStart) {
		if(itemStart == null || itemStart.tok == null) {
			return itemStart;
		}
		var parent = itemStart;
		while(parent != null && parent.tok != null) {
			var _g = parent.tok;
			switch(_g._hx_index) {
			case 0:
				switch(_g.k._hx_index) {
				case 23:case 28:case 36:
					break;
				default:
					return parent;
				}
				break;
			case 5:
				var _g1 = _g.op;
				switch(_g1._hx_index) {
				case 4:
					return parent;
				case 20:
					var _g2 = _g1.op;
					return parent;
				default:
				}
				break;
			case 14:case 16:case 18:
				return parent;
			default:
			}
			itemStart = parent;
			parent = parent.parent;
		}
		return itemStart;
	}
	,makeWrappableItem: function(start,end) {
		var sameLine = this.isSameLineBetween(start,end,false);
		var firstLineLength = 0;
		var lastLineLength = 0;
		if(sameLine) {
			firstLineLength = this.calcLengthBetween(start,end) + this.calcTokenLength(end);
		} else {
			firstLineLength = this.calcLengthUntilNewline(start,end);
			lastLineLength = this.calcLineLengthBefore(end) + this.calcTokenLength(end);
		}
		return { first : start, last : end, multiline : !sameLine, firstLineLength : firstLineLength, lastLineLength : lastLineLength};
	}
	,markImplementsExtendsChaining: function() {
		var classesAndInterfaces = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 0) {
				switch(_g.k._hx_index) {
				case 1:case 27:
					return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
				case 26:case 31:case 39:
					return tokentree_FilterResult.SKIP_SUBTREE;
				default:
					return tokentree_FilterResult.GO_DEEPER;
				}
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g1 = 0;
		while(_g1 < classesAndInterfaces.length) {
			var type = classesAndInterfaces[_g1];
			++_g1;
			var items = [];
			var impls = type.filterCallback(function(token1,index1) {
				var _g2 = token1.tok;
				if(_g2._hx_index == 0) {
					switch(_g2.k._hx_index) {
					case 0:case 2:
						return tokentree_FilterResult.SKIP_SUBTREE;
					case 11:case 12:
						return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
					default:
						return tokentree_FilterResult.GO_DEEPER;
					}
				} else {
					return tokentree_FilterResult.GO_DEEPER;
				}
			});
			var _g3 = 0;
			while(_g3 < impls.length) {
				var impl = impls[_g3];
				++_g3;
				var endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(impl);
				items.push(this.makeWrappableItem(impl,endToken));
			}
			if(items.length <= 0) {
				continue;
			}
			var chainOpen = items[0].first;
			var prev = this.getPreviousToken(items[0].first);
			if(prev != null) {
				chainOpen = prev.token;
			}
			var chainEnd = items[items.length - 1].last;
			this.queueWrapping({ start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.implementsExtends, useTrailing : false, overrideAdditionalIndent : null},"markImplementsExtendsChaining");
		}
	}
	,markMultiVarChaining: function() {
		var allVars = this.parsedCode.root.filterCallback(function(token,index) {
			var _g = token.tok;
			if(_g._hx_index == 0) {
				if(_g.k._hx_index == 2) {
					if(token.hasChildren() && token.children.length > 1) {
						return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
					}
					return tokentree_FilterResult.SKIP_SUBTREE;
				} else {
					return tokentree_FilterResult.GO_DEEPER;
				}
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
		var _g1 = 0;
		while(_g1 < allVars.length) {
			var v = allVars[_g1];
			++_g1;
			var items = [];
			var _g2 = 0;
			var _g11 = v.children;
			while(_g2 < _g11.length) {
				var child = _g11[_g2];
				++_g2;
				var endToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(child);
				items.push(this.makeWrappableItem(child,endToken));
			}
			if(items.length <= 0) {
				continue;
			}
			var chainOpen = v;
			var chainEnd = tokentree_utils_TokenTreeCheckUtils.getLastToken(v);
			this.queueWrapping({ start : chainOpen, end : chainEnd, items : items, rules : this.config.wrapping.multiVar, useTrailing : false, overrideAdditionalIndent : null},"markMultiVarChaining");
		}
	}
});
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
	,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
};
var haxe_CallStack = function() { };
haxe_CallStack.__name__ = true;
haxe_CallStack.getStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = function(error,callsites) {
		var stack = [];
		var _g = 0;
		while(_g < callsites.length) {
			var site = callsites[_g];
			++_g;
			if(haxe_CallStack.wrapCallSite != null) {
				site = haxe_CallStack.wrapCallSite(site);
			}
			var method = null;
			var fullName = site.getFunctionName();
			if(fullName != null) {
				var idx = fullName.lastIndexOf(".");
				if(idx >= 0) {
					var className = HxOverrides.substr(fullName,0,idx);
					var methodName = HxOverrides.substr(fullName,idx + 1,null);
					method = haxe_StackItem.Method(className,methodName);
				}
			}
			var fileName = site.getFileName();
			var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
			if(haxe_CallStack.wrapCallSite != null && fileAddr > 0) {
				fileName = HxOverrides.substr(fileName,fileAddr + 6,null);
			}
			stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
		}
		return stack;
	};
	var a = haxe_CallStack.makeStack(e.stack);
	Error.prepareStackTrace = oldValue;
	return a;
};
haxe_CallStack.exceptionStack = function() {
	return haxe_CallStack.getStack(haxe_CallStack.lastException);
};
haxe_CallStack.toString = function(stack) {
	var b = new StringBuf();
	var _g = 0;
	while(_g < stack.length) {
		var s = stack[_g];
		++_g;
		b.b += "\nCalled from ";
		haxe_CallStack.itemToString(b,s);
	}
	return b.b;
};
haxe_CallStack.itemToString = function(b,s) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var col = s.column;
		var line = s.line;
		var file = s.file;
		var s1 = s.s;
		if(s1 != null) {
			haxe_CallStack.itemToString(b,s1);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(col != null) {
			b.b += " column ";
			b.b += col == null ? "null" : "" + col;
		}
		if(s1 != null) {
			b.b += ")";
		}
		break;
	case 3:
		var meth = s.method;
		var cname = s.classname;
		b.b += cname == null ? "null" : "" + cname;
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		break;
	case 4:
		var n = s.v;
		b.b += "local function #";
		b.b += n == null ? "null" : "" + n;
		break;
	}
};
haxe_CallStack.makeStack = function(s) {
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var rie10 = new EReg("^   at ([A-Za-z0-9_. ]+) \\(([^)]+):([0-9]+):([0-9]+)\\)$","");
		var _g = 0;
		while(_g < stack.length) {
			var line = stack[_g];
			++_g;
			if(rie10.match(line)) {
				var path = rie10.matched(1).split(".");
				var meth = path.pop();
				var file = rie10.matched(2);
				var line1 = Std.parseInt(rie10.matched(3));
				var column = Std.parseInt(rie10.matched(4));
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else {
		return s;
	}
};
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
var haxe_ds_List = function() {
	this.length = 0;
};
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	push: function(item) {
		var x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	,remove: function(v) {
		var prev = null;
		var l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
haxe_ds__$List_ListNode.__name__ = true;
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s,encoding) {
	if(encoding == haxe_io_Encoding.RawNative) {
		var buf = new Uint8Array(s.length << 1);
		var _g = 0;
		var _g1 = s.length;
		while(_g < _g1) {
			var i = _g++;
			var c = s.charCodeAt(i);
			buf[i << 1] = c & 255;
			buf[i << 1 | 1] = c >> 8;
		}
		return new haxe_io_Bytes(buf.buffer);
	}
	var a = [];
	var i1 = 0;
	while(i1 < s.length) {
		var c1 = s.charCodeAt(i1++);
		if(55296 <= c1 && c1 <= 56319) {
			c1 = c1 - 55232 << 10 | s.charCodeAt(i1++) & 1023;
		}
		if(c1 <= 127) {
			a.push(c1);
		} else if(c1 <= 2047) {
			a.push(192 | c1 >> 6);
			a.push(128 | c1 & 63);
		} else if(c1 <= 65535) {
			a.push(224 | c1 >> 12);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		} else {
			a.push(240 | c1 >> 18);
			a.push(128 | c1 >> 12 & 63);
			a.push(128 | c1 >> 6 & 63);
			a.push(128 | c1 & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	sub: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c1 = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c1);
			}
			break;
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
haxe_io_Path.__name__ = true;
haxe_io_Path.directory = function(path) {
	var s = new haxe_io_Path(path);
	if(s.dir == null) {
		return "";
	}
	return s.dir;
};
haxe_io_Path.join = function(paths) {
	var paths1 = paths.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	if(paths1.length == 0) {
		return "";
	}
	var path = paths1[0];
	var _g = 1;
	var _g1 = paths1.length;
	while(_g < _g1) {
		var i = _g++;
		path = haxe_io_Path.addTrailingSlash(path);
		path += paths1[i];
	}
	return haxe_io_Path.normalize(path);
};
haxe_io_Path.normalize = function(path) {
	var slash = "/";
	path = path.split("\\").join(slash);
	if(path == slash) {
		return slash;
	}
	var target = [];
	var _g = 0;
	var _g1 = path.split(slash);
	while(_g < _g1.length) {
		var token = _g1[_g];
		++_g;
		if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
			target.pop();
		} else if(token == "") {
			if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
				target.push(token);
			}
		} else if(token != ".") {
			target.push(token);
		}
	}
	var tmp = target.join(slash);
	var acc_b = "";
	var colon = false;
	var slashes = false;
	var _g2_offset = 0;
	var _g2_s = tmp;
	while(_g2_offset < _g2_s.length) {
		var s = _g2_s;
		var index = _g2_offset++;
		var c = s.charCodeAt(index);
		if(c >= 55296 && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
		}
		var c1 = c;
		if(c1 >= 65536) {
			++_g2_offset;
		}
		var c2 = c1;
		switch(c2) {
		case 47:
			if(!colon) {
				slashes = true;
			} else {
				var i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
			break;
		case 58:
			acc_b += ":";
			colon = true;
			break;
		default:
			var i1 = c2;
			colon = false;
			if(slashes) {
				acc_b += "/";
				slashes = false;
			}
			acc_b += String.fromCodePoint(i1);
		}
	}
	return acc_b;
};
haxe_io_Path.addTrailingSlash = function(path) {
	if(path.length == 0) {
		return "/";
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		if(c2 != path.length - 1) {
			return path + "\\";
		} else {
			return path;
		}
	} else if(c1 != path.length - 1) {
		return path + "/";
	} else {
		return path;
	}
};
var haxe_macro_Constant = $hxEnums["haxe.macro.Constant"] = { __ename__ : true, __constructs__ : ["CInt","CFloat","CString","CIdent","CRegexp"]
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(f) { return {_hx_index:1,f:f,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["f"],$_)
	,CString: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CIdent: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CRegexp: ($_=function(r,opt) { return {_hx_index:4,r:r,opt:opt,__enum__:"haxe.macro.Constant",toString:$estr}; },$_.__params__ = ["r","opt"],$_)
};
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__ : true, __constructs__ : ["OpAdd","OpMult","OpDiv","OpSub","OpAssign","OpEq","OpNotEq","OpGt","OpGte","OpLt","OpLte","OpAnd","OpOr","OpXor","OpBoolAnd","OpBoolOr","OpShl","OpShr","OpUShr","OpMod","OpAssignOp","OpInterval","OpArrow","OpIn"]
	,OpAdd: {_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
};
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__ : true, __constructs__ : ["OpIncrement","OpDecrement","OpNot","OpNeg","OpNegBits"]
	,OpIncrement: {_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
};
var haxe_macro_ComplexType = $hxEnums["haxe.macro.ComplexType"] = { __ename__ : true, __constructs__ : ["TPath","TFunction","TAnonymous","TParent","TExtend","TOptional","TNamed","TIntersection"]
	,TPath: ($_=function(p) { return {_hx_index:0,p:p,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p"],$_)
	,TFunction: ($_=function(args,ret) { return {_hx_index:1,args:args,ret:ret,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["args","ret"],$_)
	,TAnonymous: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,TParent: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TExtend: ($_=function(p,fields) { return {_hx_index:4,p:p,fields:fields,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["p","fields"],$_)
	,TOptional: ($_=function(t) { return {_hx_index:5,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["t"],$_)
	,TNamed: ($_=function(n,t) { return {_hx_index:6,n:n,t:t,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["n","t"],$_)
	,TIntersection: ($_=function(tl) { return {_hx_index:7,tl:tl,__enum__:"haxe.macro.ComplexType",toString:$estr}; },$_.__params__ = ["tl"],$_)
};
var haxe_macro_Printer = function(tabString) {
	if(tabString == null) {
		tabString = "\t";
	}
	this.tabs = "";
	this.tabString = tabString;
};
haxe_macro_Printer.__name__ = true;
haxe_macro_Printer.prototype = {
	printUnop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "++";
		case 1:
			return "--";
		case 2:
			return "!";
		case 3:
			return "-";
		case 4:
			return "~";
		}
	}
	,printBinop: function(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			var op1 = op.op;
			return this.printBinop(op1) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		case 23:
			return "in";
		}
	}
};
var haxeparser_Keyword = $hxEnums["haxeparser.Keyword"] = { __ename__ : true, __constructs__ : ["KwdFunction","KwdClass","KwdVar","KwdIf","KwdElse","KwdWhile","KwdDo","KwdFor","KwdBreak","KwdContinue","KwdReturn","KwdExtends","KwdImplements","KwdImport","KwdSwitch","KwdCase","KwdDefault","KwdStatic","KwdPublic","KwdPrivate","KwdTry","KwdCatch","KwdNew","KwdThis","KwdThrow","KwdExtern","KwdEnum","KwdInterface","KwdUntyped","KwdCast","KwdOverride","KwdTypedef","KwdDynamic","KwdPackage","KwdInline","KwdUsing","KwdNull","KwdTrue","KwdFalse","KwdAbstract","KwdMacro","KwdFinal"]
	,KwdFunction: {_hx_index:0,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdClass: {_hx_index:1,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdVar: {_hx_index:2,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdIf: {_hx_index:3,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdElse: {_hx_index:4,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdWhile: {_hx_index:5,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDo: {_hx_index:6,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFor: {_hx_index:7,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdBreak: {_hx_index:8,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdContinue: {_hx_index:9,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdReturn: {_hx_index:10,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtends: {_hx_index:11,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImplements: {_hx_index:12,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdImport: {_hx_index:13,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdSwitch: {_hx_index:14,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCase: {_hx_index:15,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDefault: {_hx_index:16,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdStatic: {_hx_index:17,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPublic: {_hx_index:18,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPrivate: {_hx_index:19,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTry: {_hx_index:20,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCatch: {_hx_index:21,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNew: {_hx_index:22,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThis: {_hx_index:23,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdThrow: {_hx_index:24,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdExtern: {_hx_index:25,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdEnum: {_hx_index:26,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInterface: {_hx_index:27,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUntyped: {_hx_index:28,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdCast: {_hx_index:29,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdOverride: {_hx_index:30,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTypedef: {_hx_index:31,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdDynamic: {_hx_index:32,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdPackage: {_hx_index:33,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdInline: {_hx_index:34,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdUsing: {_hx_index:35,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdNull: {_hx_index:36,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdTrue: {_hx_index:37,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFalse: {_hx_index:38,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdAbstract: {_hx_index:39,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdMacro: {_hx_index:40,__enum__:"haxeparser.Keyword",toString:$estr}
	,KwdFinal: {_hx_index:41,__enum__:"haxeparser.Keyword",toString:$estr}
};
var haxeparser_KeywordPrinter = function() { };
haxeparser_KeywordPrinter.__name__ = true;
haxeparser_KeywordPrinter.toString = function(kwd) {
	switch(kwd._hx_index) {
	case 0:
		return "function";
	case 1:
		return "class";
	case 2:
		return "var";
	case 3:
		return "if";
	case 4:
		return "else";
	case 5:
		return "while";
	case 6:
		return "do";
	case 7:
		return "for";
	case 8:
		return "break";
	case 9:
		return "continue";
	case 10:
		return "return";
	case 11:
		return "extends";
	case 12:
		return "implements";
	case 13:
		return "import";
	case 14:
		return "switch";
	case 15:
		return "case";
	case 16:
		return "default";
	case 17:
		return "static";
	case 18:
		return "public";
	case 19:
		return "private";
	case 20:
		return "try";
	case 21:
		return "catch";
	case 22:
		return "new";
	case 23:
		return "this";
	case 24:
		return "throw";
	case 25:
		return "extern";
	case 26:
		return "enum";
	case 27:
		return "interface";
	case 28:
		return "untyped";
	case 29:
		return "cast";
	case 30:
		return "override";
	case 31:
		return "typedef";
	case 32:
		return "dynamic";
	case 33:
		return "package";
	case 34:
		return "inline";
	case 35:
		return "using";
	case 36:
		return "null";
	case 37:
		return "true";
	case 38:
		return "false";
	case 39:
		return "abstract";
	case 40:
		return "macro";
	case 41:
		return "final";
	}
};
var haxeparser_TokenDef = $hxEnums["haxeparser.TokenDef"] = { __ename__ : true, __constructs__ : ["Kwd","Const","Sharp","Dollar","Unop","Binop","Comment","CommentLine","IntInterval","Semicolon","Dot","DblDot","Arrow","Comma","BkOpen","BkClose","BrOpen","BrClose","POpen","PClose","Question","At","Eof"]
	,Kwd: ($_=function(k) { return {_hx_index:0,k:k,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["k"],$_)
	,Const: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Sharp: ($_=function(s) { return {_hx_index:2,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Dollar: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Unop: ($_=function(op) { return {_hx_index:4,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Binop: ($_=function(op) { return {_hx_index:5,op:op,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["op"],$_)
	,Comment: ($_=function(s) { return {_hx_index:6,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,CommentLine: ($_=function(s) { return {_hx_index:7,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IntInterval: ($_=function(s) { return {_hx_index:8,s:s,__enum__:"haxeparser.TokenDef",toString:$estr}; },$_.__params__ = ["s"],$_)
	,Semicolon: {_hx_index:9,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Dot: {_hx_index:10,__enum__:"haxeparser.TokenDef",toString:$estr}
	,DblDot: {_hx_index:11,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Arrow: {_hx_index:12,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Comma: {_hx_index:13,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkOpen: {_hx_index:14,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BkClose: {_hx_index:15,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrOpen: {_hx_index:16,__enum__:"haxeparser.TokenDef",toString:$estr}
	,BrClose: {_hx_index:17,__enum__:"haxeparser.TokenDef",toString:$estr}
	,POpen: {_hx_index:18,__enum__:"haxeparser.TokenDef",toString:$estr}
	,PClose: {_hx_index:19,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Question: {_hx_index:20,__enum__:"haxeparser.TokenDef",toString:$estr}
	,At: {_hx_index:21,__enum__:"haxeparser.TokenDef",toString:$estr}
	,Eof: {_hx_index:22,__enum__:"haxeparser.TokenDef",toString:$estr}
};
var haxeparser_TokenDefPrinter = function() { };
haxeparser_TokenDefPrinter.__name__ = true;
haxeparser_TokenDefPrinter.toString = function(def) {
	switch(def._hx_index) {
	case 0:
		var k = def.k;
		return HxOverrides.substr($hxEnums[k.__enum__].__constructs__[k._hx_index],3,null).toLowerCase();
	case 1:
		var _g5 = def.c;
		switch(_g5._hx_index) {
		case 0:
			var s = _g5.v;
			return s;
		case 1:
			var s1 = _g5.f;
			return s1;
		case 2:
			var s2 = _g5.s;
			return "\"" + s2 + "\"";
		case 3:
			var s3 = _g5.s;
			return s3;
		case 4:
			var opt = _g5.opt;
			var r = _g5.r;
			return "~/" + r + "/" + opt;
		}
		break;
	case 2:
		var s4 = def.s;
		return "#" + s4;
	case 3:
		var s5 = def.s;
		return "$" + s5;
	case 4:
		var op = def.op;
		return new haxe_macro_Printer("").printUnop(op);
	case 5:
		var op1 = def.op;
		return new haxe_macro_Printer("").printBinop(op1);
	case 6:
		var s6 = def.s;
		return "/*" + s6 + "*/";
	case 7:
		var s7 = def.s;
		return "//" + s7;
	case 8:
		var s8 = def.s;
		return "" + s8 + "...";
	case 9:
		return ";";
	case 10:
		return ".";
	case 11:
		return ":";
	case 12:
		return "->";
	case 13:
		return ",";
	case 14:
		return "[";
	case 15:
		return "]";
	case 16:
		return "{";
	case 17:
		return "}";
	case 18:
		return "(";
	case 19:
		return ")";
	case 20:
		return "?";
	case 21:
		return "@";
	case 22:
		return "<eof>";
	}
};
haxeparser_TokenDefPrinter.print = function(def) {
	return haxeparser_TokenDefPrinter.toString(def);
};
var haxeparser_Token = function(tok,pos) {
	this.tok = tok;
	this.pos = pos;
};
haxeparser_Token.__name__ = true;
haxeparser_Token.prototype = {
	toString: function() {
		return haxeparser_TokenDefPrinter.toString(this.tok);
	}
};
var haxeparser_TypeDef = $hxEnums["haxeparser.TypeDef"] = { __ename__ : true, __constructs__ : ["EClass","EEnum","EAbstract","EImport","ETypedef","EUsing"]
	,EClass: ($_=function(d) { return {_hx_index:0,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["d"],$_)
	,EEnum: ($_=function(d) { return {_hx_index:1,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["d"],$_)
	,EAbstract: ($_=function(a) { return {_hx_index:2,a:a,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["a"],$_)
	,EImport: ($_=function(sl,mode) { return {_hx_index:3,sl:sl,mode:mode,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["sl","mode"],$_)
	,ETypedef: ($_=function(d) { return {_hx_index:4,d:d,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["d"],$_)
	,EUsing: ($_=function(path) { return {_hx_index:5,path:path,__enum__:"haxeparser.TypeDef",toString:$estr}; },$_.__params__ = ["path"],$_)
};
var haxeparser_ClassFlag = $hxEnums["haxeparser.ClassFlag"] = { __ename__ : true, __constructs__ : ["HInterface","HExtern","HPrivate","HExtends","HImplements"]
	,HInterface: {_hx_index:0,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HExtern: {_hx_index:1,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HPrivate: {_hx_index:2,__enum__:"haxeparser.ClassFlag",toString:$estr}
	,HExtends: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"haxeparser.ClassFlag",toString:$estr}; },$_.__params__ = ["t"],$_)
	,HImplements: ($_=function(t) { return {_hx_index:4,t:t,__enum__:"haxeparser.ClassFlag",toString:$estr}; },$_.__params__ = ["t"],$_)
};
var haxeparser_AbstractFlag = $hxEnums["haxeparser.AbstractFlag"] = { __ename__ : true, __constructs__ : ["APrivAbstract","AFromType","AToType","AIsType","AExtern"]
	,APrivAbstract: {_hx_index:0,__enum__:"haxeparser.AbstractFlag",toString:$estr}
	,AFromType: ($_=function(ct) { return {_hx_index:1,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_.__params__ = ["ct"],$_)
	,AToType: ($_=function(ct) { return {_hx_index:2,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_.__params__ = ["ct"],$_)
	,AIsType: ($_=function(ct) { return {_hx_index:3,ct:ct,__enum__:"haxeparser.AbstractFlag",toString:$estr}; },$_.__params__ = ["ct"],$_)
	,AExtern: {_hx_index:4,__enum__:"haxeparser.AbstractFlag",toString:$estr}
};
var haxeparser_EnumFlag = $hxEnums["haxeparser.EnumFlag"] = { __ename__ : true, __constructs__ : ["EPrivate","EExtern"]
	,EPrivate: {_hx_index:0,__enum__:"haxeparser.EnumFlag",toString:$estr}
	,EExtern: {_hx_index:1,__enum__:"haxeparser.EnumFlag",toString:$estr}
};
var haxeparser_ImportMode = $hxEnums["haxeparser.ImportMode"] = { __ename__ : true, __constructs__ : ["INormal","IAsName","IAll"]
	,INormal: {_hx_index:0,__enum__:"haxeparser.ImportMode",toString:$estr}
	,IAsName: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"haxeparser.ImportMode",toString:$estr}; },$_.__params__ = ["s"],$_)
	,IAll: {_hx_index:2,__enum__:"haxeparser.ImportMode",toString:$estr}
};
var haxeparser_LexerErrorMsg = $hxEnums["haxeparser.LexerErrorMsg"] = { __ename__ : true, __constructs__ : ["UnterminatedString","UnterminatedRegExp","UnclosedComment","UnterminatedEscapeSequence","InvalidEscapeSequence","UnknownEscapeSequence","UnclosedCode"]
	,UnterminatedString: {_hx_index:0,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedRegExp: {_hx_index:1,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnclosedComment: {_hx_index:2,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,UnterminatedEscapeSequence: {_hx_index:3,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
	,InvalidEscapeSequence: ($_=function(c) { return {_hx_index:4,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnknownEscapeSequence: ($_=function(c) { return {_hx_index:5,c:c,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}; },$_.__params__ = ["c"],$_)
	,UnclosedCode: {_hx_index:6,__enum__:"haxeparser.LexerErrorMsg",toString:$estr}
};
var haxeparser_LexerError = function(msg,pos) {
	this.msg = msg;
	this.pos = pos;
};
haxeparser_LexerError.__name__ = true;
var hxparse_Lexer = function(input,sourceName) {
	if(sourceName == null) {
		sourceName = "<null>";
	}
	this.current = "";
	this.input = input;
	this.source = sourceName;
	this.pos = 0;
};
hxparse_Lexer.__name__ = true;
hxparse_Lexer.buildRuleset = function(rules,name) {
	if(name == null) {
		name = "";
	}
	var cases = [];
	var functions = [];
	var eofFunction = null;
	var _g = 0;
	while(_g < rules.length) {
		var rule = rules[_g];
		++_g;
		if(rule.rule == "") {
			eofFunction = rule.func;
		} else {
			cases.push(hxparse_LexEngine.parse(rule.rule));
			functions.push(rule.func);
		}
	}
	return new hxparse_Ruleset(new hxparse_LexEngine(cases).firstState(),functions,eofFunction,name);
};
hxparse_Lexer.prototype = {
	curPos: function() {
		return new hxparse_Position(this.source,this.pos - this.current.length,this.pos);
	}
	,token: function(ruleset) {
		if(this.pos == this.input.length) {
			if(ruleset.eofFunction != null) {
				return ruleset.eofFunction(this);
			} else {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			}
		}
		var state = ruleset.state;
		var lastMatch = null;
		var lastMatchPos = this.pos;
		var start = this.pos;
		while(true) {
			if(state.finalId > -1) {
				lastMatch = state;
				lastMatchPos = this.pos;
			}
			if(this.pos == this.input.length) {
				break;
			}
			var i = this.input.b[this.pos];
			++this.pos;
			state = state.trans[i];
			if(state == null) {
				break;
			}
		}
		this.pos = lastMatchPos;
		this.current = this.input.getString(start,this.pos - start);
		if(lastMatch == null || lastMatch.finalId == -1) {
			var code = this.input.b[this.pos];
			throw new js__$Boot_HaxeError(new hxparse_UnexpectedChar(String.fromCodePoint(code),new hxparse_Position(this.source,this.pos - this.current.length,this.pos)));
		}
		return ruleset.functions[lastMatch.finalId](this);
	}
};
var hxparse_LexEngine = function(patterns) {
	this.nodes = [];
	this.finals = [];
	this.states = [];
	this.hstates = new haxe_ds_StringMap();
	this.uid = 0;
	var pid = 0;
	var _g = 0;
	while(_g < patterns.length) {
		var p = patterns[_g];
		++_g;
		var id = pid++;
		var f = new hxparse__$LexEngine_Node(this.uid++,id);
		var n = this.initNode(p,f,id);
		this.nodes.push(n);
		this.finals.push(f);
	}
	this.makeState(this.addNodes([],this.nodes));
};
hxparse_LexEngine.__name__ = true;
hxparse_LexEngine.single = function(c) {
	return [{ min : c, max : c}];
};
hxparse_LexEngine.parse = function(pattern) {
	var this1 = haxe_io_Bytes.ofString(pattern);
	var p = hxparse_LexEngine.parseInner(this1);
	if(p == null) {
		throw new js__$Boot_HaxeError("Invalid pattern '" + pattern + "'");
	}
	return p.pattern;
};
hxparse_LexEngine.next = function(a,b) {
	if(a == hxparse__$LexEngine_Pattern.Empty) {
		return b;
	} else {
		return hxparse__$LexEngine_Pattern.Next(a,b);
	}
};
hxparse_LexEngine.plus = function(r) {
	if(r._hx_index == 4) {
		var r2 = r.p2;
		var r1 = r.p1;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.plus(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Plus(r);
	}
};
hxparse_LexEngine.star = function(r) {
	if(r._hx_index == 4) {
		var r2 = r.p2;
		var r1 = r.p1;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.star(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Star(r);
	}
};
hxparse_LexEngine.opt = function(r) {
	if(r._hx_index == 4) {
		var r2 = r.p2;
		var r1 = r.p1;
		return hxparse__$LexEngine_Pattern.Next(r1,hxparse_LexEngine.opt(r2));
	} else {
		return hxparse__$LexEngine_Pattern.Choice(r,hxparse__$LexEngine_Pattern.Empty);
	}
};
hxparse_LexEngine.cinter = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),hxparse_LexEngine.ccomplement(c2)));
};
hxparse_LexEngine.cdiff = function(c1,c2) {
	return hxparse_LexEngine.ccomplement(hxparse_LexEngine.cunion(hxparse_LexEngine.ccomplement(c1),c2));
};
hxparse_LexEngine.ccomplement = function(c) {
	var first = c[0];
	var start = first != null && first.min == -1 ? c.shift().max + 1 : -1;
	var out = [];
	var _g = 0;
	while(_g < c.length) {
		var k = c[_g];
		++_g;
		out.push({ min : start, max : k.min - 1});
		start = k.max + 1;
	}
	if(start <= 255) {
		out.push({ min : start, max : 255});
	}
	return out;
};
hxparse_LexEngine.cunion = function(ca,cb) {
	var i = 0;
	var j = 0;
	var out = [];
	var a = ca[i++];
	var b = cb[j++];
	while(true) {
		if(a == null) {
			out.push(b);
			while(j < cb.length) out.push(cb[j++]);
			break;
		}
		if(b == null) {
			out.push(a);
			while(i < ca.length) out.push(ca[i++]);
			break;
		}
		if(a.min <= b.min) {
			if(a.max + 1 < b.min) {
				out.push(a);
				a = ca[i++];
			} else if(a.max < b.max) {
				b = { min : a.min, max : b.max};
				a = ca[i++];
			} else {
				b = cb[j++];
			}
		} else {
			var tmp = ca;
			ca = cb;
			cb = tmp;
			var tmp1 = j;
			j = i;
			i = tmp1;
			var tmp2 = a;
			a = b;
			b = tmp2;
		}
	}
	return out;
};
hxparse_LexEngine.parseInner = function(pattern,i,pDepth) {
	if(pDepth == null) {
		pDepth = 0;
	}
	if(i == null) {
		i = 0;
	}
	var readChar = function() {
		i += 1;
		var c = pattern.b[i - 1];
		if(c != c) {
			c = 92;
		} else if(c == 120) {
			c = Std.parseInt("0x" + pattern.getString(i,2));
			i += 2;
		} else if(c >= 48 && c <= 57) {
			var v = c - 48;
			while(true) {
				var cNext = pattern.b[i];
				if(cNext >= 48 && cNext <= 57) {
					v = v * 10 + (cNext - 48);
					i += 1;
				} else {
					break;
				}
			}
			c = v;
		}
		return c;
	};
	var r = hxparse__$LexEngine_Pattern.Empty;
	var l = pattern.length;
	while(i < l) {
		i += 1;
		var c1 = pattern.b[i - 1];
		if(c1 > 255) {
			throw new js__$Boot_HaxeError(c1);
		}
		switch(c1) {
		case 40:
			var r2 = hxparse_LexEngine.parseInner(pattern,i,pDepth + 1);
			i = r2.pos;
			r = hxparse_LexEngine.next(r,r2.pattern);
			break;
		case 41:
			if(r == hxparse__$LexEngine_Pattern.Empty) {
				throw new js__$Boot_HaxeError("Empty group");
			}
			return { pattern : hxparse__$LexEngine_Pattern.Group(r), pos : i};
		case 42:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.star(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([{ min : c1, max : c1}]));
			}
			break;
		case 43:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.plus(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([{ min : c1, max : c1}]));
			}
			break;
		case 46:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(hxparse_LexEngine.ALL_CHARS));
			break;
		case 63:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				r = hxparse_LexEngine.opt(r);
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([{ min : c1, max : c1}]));
			}
			break;
		case 91:
			if(pattern.length > 1) {
				var range = 0;
				var acc = [];
				var not = pattern.b[i] == 94;
				if(not) {
					i += 1;
				}
				while(true) {
					i += 1;
					var c2 = pattern.b[i - 1];
					if(c2 == 93) {
						if(range != 0) {
							return null;
						}
						break;
					} else if(c2 == 45) {
						if(range != 0) {
							return null;
						}
						var last = acc.pop();
						if(last == null) {
							acc.push({ min : c2, max : c2});
						} else {
							if(last.min != last.max) {
								return null;
							}
							range = last.min;
						}
					} else {
						if(c2 == 92) {
							c2 = readChar();
						}
						if(range == 0) {
							acc.push({ min : c2, max : c2});
						} else {
							acc.push({ min : range, max : c2});
							range = 0;
						}
					}
				}
				var g = [];
				var _g = 0;
				while(_g < acc.length) {
					var k = acc[_g];
					++_g;
					g = hxparse_LexEngine.cunion(g,[k]);
				}
				if(not) {
					g = hxparse_LexEngine.cdiff(hxparse_LexEngine.ALL_CHARS,g);
				}
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match(g));
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([{ min : c1, max : c1}]));
			}
			break;
		case 92:
			c1 = readChar();
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([{ min : c1, max : c1}]));
			break;
		case 124:
			if(r != hxparse__$LexEngine_Pattern.Empty) {
				var r21 = hxparse_LexEngine.parseInner(pattern,i);
				return { pattern : hxparse__$LexEngine_Pattern.Choice(r,r21.pattern), pos : r21.pos};
			} else {
				r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([{ min : c1, max : c1}]));
			}
			break;
		default:
			r = hxparse_LexEngine.next(r,hxparse__$LexEngine_Pattern.Match([{ min : c1, max : c1}]));
		}
	}
	if(pDepth != 0) {
		throw new js__$Boot_HaxeError("Found unclosed parenthesis while parsing \"" + Std.string(pattern) + "\"");
	}
	return { pattern : r, pos : i};
};
hxparse_LexEngine.prototype = {
	firstState: function() {
		return this.states[0];
	}
	,makeState: function(nodes) {
		var _gthis = this;
		var buf_b = "";
		var _g = 0;
		while(_g < nodes.length) {
			var n = nodes[_g];
			++_g;
			buf_b += Std.string(n.id);
			buf_b += String.fromCodePoint(45);
		}
		var key = buf_b;
		var _this = this.hstates;
		var s = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
		if(s != null) {
			return s;
		}
		s = new hxparse_State();
		this.states.push(s);
		var _this1 = this.hstates;
		if(__map_reserved[key] != null) {
			_this1.setReserved(key,s);
		} else {
			_this1.h[key] = s;
		}
		var trans = this.getTransitions(nodes);
		var _g1 = 0;
		while(_g1 < trans.length) {
			var t = trans[_g1];
			++_g1;
			var target = this.makeState(t.n);
			var _g11 = 0;
			var _g2 = t.chars;
			while(_g11 < _g2.length) {
				var chr = _g2[_g11];
				++_g11;
				var _g12 = chr.min;
				var _g21 = chr.max + 1;
				while(_g12 < _g21) {
					var i = _g12++;
					s.trans[i] = target;
				}
			}
		}
		var setFinal = function() {
			var _g22 = 0;
			var _g3 = _gthis.finals;
			while(_g22 < _g3.length) {
				var f = _g3[_g22];
				++_g22;
				var _g23 = 0;
				while(_g23 < nodes.length) {
					var n1 = nodes[_g23];
					++_g23;
					if(n1 == f) {
						s.finalId = n1.pid;
						return;
					}
				}
			}
		};
		if(s.finalId == -1) {
			setFinal();
		}
		return s;
	}
	,getTransitions: function(nodes) {
		var tl = [];
		var _g = 0;
		while(_g < nodes.length) {
			var n = nodes[_g];
			++_g;
			var _g1 = 0;
			var _g11 = n.trans;
			while(_g1 < _g11.length) {
				var t = _g11[_g1];
				++_g1;
				tl.push(t);
			}
		}
		tl.sort(function(t1,t2) {
			return t1.n.id - t2.n.id;
		});
		var t0 = tl[0];
		var _g12 = 1;
		var _g2 = tl.length;
		while(_g12 < _g2) {
			var i = _g12++;
			var t11 = tl[i];
			if(t0.n == t11.n) {
				tl[i - 1] = null;
				t11 = { chars : hxparse_LexEngine.cunion(t0.chars,t11.chars), n : t11.n};
				tl[i] = t11;
			}
			t0 = t11;
		}
		while(HxOverrides.remove(tl,null)) {
		}
		var allChars = hxparse_LexEngine.EMPTY;
		var allStates = new haxe_ds_List();
		var _g3 = 0;
		while(_g3 < tl.length) {
			var t3 = tl[_g3];
			++_g3;
			var states = new haxe_ds_List();
			states.push({ chars : hxparse_LexEngine.cdiff(t3.chars,allChars), n : [t3.n]});
			var _g3_head = allStates.h;
			while(_g3_head != null) {
				var val = _g3_head.item;
				_g3_head = _g3_head.next;
				var s = val;
				var nodes1 = s.n.slice();
				nodes1.push(t3.n);
				states.push({ chars : hxparse_LexEngine.cinter(s.chars,t3.chars), n : nodes1});
				states.push({ chars : hxparse_LexEngine.cdiff(s.chars,t3.chars), n : s.n});
			}
			var _g4_head = states.h;
			while(_g4_head != null) {
				var val1 = _g4_head.item;
				_g4_head = _g4_head.next;
				var s1 = val1;
				if(s1.chars.length == 0) {
					states.remove(s1);
				}
			}
			allChars = hxparse_LexEngine.cunion(allChars,t3.chars);
			allStates = states;
		}
		var states1 = [];
		var _g4_head1 = allStates.h;
		while(_g4_head1 != null) {
			var val2 = _g4_head1.item;
			_g4_head1 = _g4_head1.next;
			var s2 = val2;
			states1.push({ chars : s2.chars, n : this.addNodes([],s2.n)});
		}
		states1.sort(function(s11,s21) {
			var a = s11.chars.length;
			var b = s21.chars.length;
			var _g5 = 0;
			var _g6 = a < b ? a : b;
			while(_g5 < _g6) {
				var i1 = _g5++;
				var a1 = s11.chars[i1];
				var b1 = s21.chars[i1];
				if(a1.min != b1.min) {
					return b1.min - a1.min;
				}
				if(a1.max != b1.max) {
					return b1.max - a1.max;
				}
			}
			if(a < b) {
				return b - a;
			}
			return 0;
		});
		return states1;
	}
	,addNode: function(nodes,n) {
		var _g = 0;
		while(_g < nodes.length) {
			var n2 = nodes[_g];
			++_g;
			if(n == n2) {
				return;
			}
		}
		nodes.push(n);
		this.addNodes(nodes,n.epsilon);
	}
	,addNodes: function(nodes,add) {
		var _g = 0;
		while(_g < add.length) {
			var n = add[_g];
			++_g;
			this.addNode(nodes,n);
		}
		return nodes;
	}
	,node: function(pid) {
		return new hxparse__$LexEngine_Node(this.uid++,pid);
	}
	,initNode: function(p,finalId,pid) {
		switch(p._hx_index) {
		case 0:
			return finalId;
		case 1:
			var c = p.c;
			var n = new hxparse__$LexEngine_Node(this.uid++,pid);
			n.trans.push({ chars : c, n : finalId});
			return n;
		case 2:
			var p1 = p.p;
			var n1 = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an = this.initNode(p1,n1,pid);
			n1.epsilon.push(an);
			n1.epsilon.push(finalId);
			return n1;
		case 3:
			var p2 = p.p;
			var n2 = new hxparse__$LexEngine_Node(this.uid++,pid);
			var an1 = this.initNode(p2,n2,pid);
			n2.epsilon.push(an1);
			n2.epsilon.push(finalId);
			return an1;
		case 4:
			var b = p.p2;
			var a = p.p1;
			return this.initNode(a,this.initNode(b,finalId,pid),pid);
		case 5:
			var b1 = p.p2;
			var a1 = p.p1;
			var n3 = new hxparse__$LexEngine_Node(this.uid++,pid);
			n3.epsilon.push(this.initNode(a1,finalId,pid));
			n3.epsilon.push(this.initNode(b1,finalId,pid));
			return n3;
		case 6:
			var p3 = p.p;
			return this.initNode(p3,finalId,pid);
		}
	}
};
var hxparse__$LexEngine_Pattern = $hxEnums["hxparse._LexEngine.Pattern"] = { __ename__ : true, __constructs__ : ["Empty","Match","Star","Plus","Next","Choice","Group"]
	,Empty: {_hx_index:0,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}
	,Match: ($_=function(c) { return {_hx_index:1,c:c,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["c"],$_)
	,Star: ($_=function(p) { return {_hx_index:2,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Plus: ($_=function(p) { return {_hx_index:3,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
	,Next: ($_=function(p1,p2) { return {_hx_index:4,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Choice: ($_=function(p1,p2) { return {_hx_index:5,p1:p1,p2:p2,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p1","p2"],$_)
	,Group: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxparse._LexEngine.Pattern",toString:$estr}; },$_.__params__ = ["p"],$_)
};
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = o.length;
			while(_g3 < _g11) {
				var i = _g3++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			haxe_CallStack.lastException = e1;
			var e2 = ((e1) instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var hxparse__$LexEngine_Node = function(id,pid) {
	this.id = id;
	this.pid = pid;
	this.trans = [];
	this.epsilon = [];
};
hxparse__$LexEngine_Node.__name__ = true;
var hxparse_Ruleset = function(state,functions,eofFunction,name) {
	if(name == null) {
		name = "";
	}
	this.state = state;
	this.functions = functions;
	this.eofFunction = eofFunction;
	this.name = name;
};
hxparse_Ruleset.__name__ = true;
var hxparse_Position = function(source,min,max) {
	this.psource = source;
	this.pmin = min;
	this.pmax = max;
};
hxparse_Position.__name__ = true;
hxparse_Position.union = function(p1,p2) {
	return new hxparse_Position(p1.psource,p1.pmin < p2.pmin ? p1.pmin : p2.pmin,p1.pmax > p2.pmax ? p1.pmax : p2.pmax);
};
hxparse_Position.prototype = {
	toString: function() {
		return "" + this.psource + ":characters " + this.pmin + "-" + this.pmax;
	}
	,getLinePosition: function(input) {
		var lineMin = 1;
		var lineMax = 1;
		var posMin = 0;
		var posMax = 0;
		var cur = 0;
		while(cur < this.pmin) {
			if(input.b[cur] == 10) {
				++lineMin;
				posMin = cur + 1;
			}
			++cur;
		}
		lineMax = lineMin;
		posMax = posMin;
		posMin = cur - posMin;
		while(cur < this.pmax) {
			if(input.b[cur] == 10) {
				++lineMax;
				posMax = cur + 1;
			}
			++cur;
		}
		posMax = cur - posMax;
		return { lineMin : lineMin, lineMax : lineMax, posMin : posMin, posMax : posMax};
	}
	,format: function(input) {
		var linePos = this.getLinePosition(input);
		if(linePos.lineMin != linePos.lineMax) {
			return "" + this.psource + ":lines " + linePos.lineMin + "-" + linePos.lineMax;
		} else {
			return "" + this.psource + ":" + linePos.lineMin + ": characters " + linePos.posMin + "-" + linePos.posMax;
		}
	}
};
var haxeparser_HaxeLexer = function(input,sourceName) {
	hxparse_Lexer.call(this,input,sourceName);
};
haxeparser_HaxeLexer.__name__ = true;
haxeparser_HaxeLexer.mkPos = function(p) {
	return { file : p.psource, min : p.pmin, max : p.pmax};
};
haxeparser_HaxeLexer.mk = function(lexer,td) {
	return new haxeparser_Token(td,haxeparser_HaxeLexer.mkPos(new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos)));
};
haxeparser_HaxeLexer.unescapePos = function(pos,index,length) {
	return { file : pos.file, min : pos.min + index, max : pos.min + index + length};
};
haxeparser_HaxeLexer.unescape = function(s,pos) {
	var b_b = "";
	var i = 0;
	var esc = false;
	while(s.length != i) {
		var c = HxOverrides.cca(s,i);
		if(esc) {
			var iNext = i + 1;
			var _hx_tmp;
			if(c == null) {
				_hx_tmp = c >= 48 && c <= 51;
				if(_hx_tmp == true) {
					iNext += 2;
				} else {
					var c1 = c;
					throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c1)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
				}
			} else {
				switch(c) {
				case 34:case 39:case 92:
					b_b += String.fromCodePoint(c);
					break;
				case 110:
					b_b += "\n";
					break;
				case 114:
					b_b += "\r";
					break;
				case 116:
					b_b += "\t";
					break;
				case 117:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c2;
						if(s.charAt(i + 1) == "{") {
							var endIndex = s.indexOf("}",i + 3);
							if(endIndex == -1) {
								throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedEscapeSequence,{ file : pos.file, min : pos.min + i, max : pos.min + i + 2}));
							}
							var l = endIndex - (i + 2);
							var chars = HxOverrides.substr(s,i + 2,l);
							if(!new EReg("^[0-9a-fA-F]+$","").match(chars)) {
								throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							c2 = Std.parseInt("0x" + chars);
							if(c2 > 1114111) {
								throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u{" + chars + "}"),{ file : pos.file, min : pos.min + i, max : pos.min + i + (3 + l)}));
							}
							iNext += 2 + l;
						} else {
							var chars1 = HxOverrides.substr(s,i + 1,4);
							if(!new EReg("^[0-9a-fA-F]{4}$","").match(chars1)) {
								throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\u" + chars1),{ file : pos.file, min : pos.min + i, max : pos.min + i + 5}));
							}
							c2 = Std.parseInt("0x" + chars1);
							iNext += 4;
						}
						b_b += String.fromCodePoint(c2);
					}
					break;
				case 120:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var chars2 = HxOverrides.substr(s,i + 1,2);
						if(!new EReg("^[0-9a-fA-F]{2}$","").match(chars2)) {
							throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.InvalidEscapeSequence("\\x" + chars2),{ file : pos.file, min : pos.min + i, max : pos.min + i + 3}));
						}
						var c3 = Std.parseInt("0x" + chars2);
						b_b += String.fromCodePoint(c3);
						iNext += 2;
					}
					break;
				default:
					_hx_tmp = c >= 48 && c <= 51;
					if(_hx_tmp == true) {
						iNext += 2;
					} else {
						var c4 = c;
						throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnknownEscapeSequence("\\" + String.fromCodePoint(c4)),{ file : pos.file, min : pos.min + i, max : pos.min + i + 1}));
					}
				}
			}
			esc = false;
			i = iNext;
		} else if(c == null) {
			b_b += String.fromCodePoint(c);
			++i;
		} else if(c == 92) {
			++i;
			esc = true;
		} else {
			b_b += String.fromCodePoint(c);
			++i;
		}
	}
	return b_b;
};
haxeparser_HaxeLexer.__super__ = hxparse_Lexer;
haxeparser_HaxeLexer.prototype = $extend(hxparse_Lexer.prototype,{
});
var hxargs_Args = function() { };
hxargs_Args.__name__ = true;
var hxjsonast_Error = function(message,pos) {
	this.message = message;
	this.pos = pos;
};
hxjsonast_Error.__name__ = true;
var hxjsonast_Json = function(value,pos) {
	this.value = value;
	this.pos = pos;
};
hxjsonast_Json.__name__ = true;
var hxjsonast_JsonValue = $hxEnums["hxjsonast.JsonValue"] = { __ename__ : true, __constructs__ : ["JString","JNumber","JObject","JArray","JBool","JNull"]
	,JString: ($_=function(s) { return {_hx_index:0,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["s"],$_)
	,JNumber: ($_=function(s) { return {_hx_index:1,s:s,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["s"],$_)
	,JObject: ($_=function(fields) { return {_hx_index:2,fields:fields,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["fields"],$_)
	,JArray: ($_=function(values) { return {_hx_index:3,values:values,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["values"],$_)
	,JBool: ($_=function(b) { return {_hx_index:4,b:b,__enum__:"hxjsonast.JsonValue",toString:$estr}; },$_.__params__ = ["b"],$_)
	,JNull: {_hx_index:5,__enum__:"hxjsonast.JsonValue",toString:$estr}
};
var hxjsonast_JObjectField = function(name,namePos,value) {
	this.name = name;
	this.namePos = namePos;
	this.value = value;
};
hxjsonast_JObjectField.__name__ = true;
var hxjsonast_Parser = function(source,filename) {
	this.source = source;
	this.filename = filename;
	this.pos = 0;
};
hxjsonast_Parser.__name__ = true;
hxjsonast_Parser.parse = function(source,filename) {
	return new hxjsonast_Parser(source,filename).parseRec();
};
hxjsonast_Parser.prototype = {
	parseRec: function() {
		while(true) {
			var c = this.source.charCodeAt(this.pos++);
			switch(c) {
			case 9:case 10:case 13:case 32:
				break;
			case 34:
				var save = this.pos;
				var s = this.parseString();
				return new hxjsonast_Json(hxjsonast_JsonValue.JString(s),new hxjsonast_Position(this.filename,save - 1,this.pos));
			case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				var start = this.pos - 1;
				var minus = c == 45;
				var digit = !minus;
				var zero = c == 48;
				var point = false;
				var e = false;
				var pm = false;
				var end = false;
				while(true) {
					switch(this.source.charCodeAt(this.pos++)) {
					case 43:case 45:
						if(!e || pm) {
							this.invalidNumber(start);
						}
						digit = false;
						pm = true;
						break;
					case 46:
						if(minus || point) {
							this.invalidNumber(start);
						}
						digit = false;
						point = true;
						break;
					case 48:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
							zero = true;
						}
						digit = true;
						break;
					case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
						if(zero && !point) {
							this.invalidNumber(start);
						}
						if(minus) {
							minus = false;
						}
						digit = true;
						zero = false;
						break;
					case 69:case 101:
						if(minus || zero || e) {
							this.invalidNumber(start);
						}
						digit = false;
						e = true;
						break;
					default:
						if(!digit) {
							this.invalidNumber(start);
						}
						this.pos--;
						end = true;
					}
					if(end) {
						break;
					}
				}
				var s1 = HxOverrides.substr(this.source,start,this.pos - start);
				return new hxjsonast_Json(hxjsonast_JsonValue.JNumber(s1),new hxjsonast_Position(this.filename,start,this.pos));
			case 91:
				var values = [];
				var comma = null;
				var startPos = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 44:
					if(comma) {
						comma = false;
					} else {
						this.invalidChar();
					}
					break;
				case 93:
					if(comma == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JArray(values),new hxjsonast_Position(this.filename,startPos,this.pos));
				default:
					if(comma) {
						this.invalidChar();
					}
					this.pos--;
					values.push(this.parseRec());
					comma = true;
				}
				break;
			case 102:
				var save1 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 97 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 115 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save1;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(false),new hxjsonast_Position(this.filename,save1 - 1,this.pos));
			case 110:
				var save2 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 108 || this.source.charCodeAt(this.pos++) != 108) {
					this.pos = save2;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JNull,new hxjsonast_Position(this.filename,save2 - 1,this.pos));
			case 116:
				var save3 = this.pos;
				if(this.source.charCodeAt(this.pos++) != 114 || this.source.charCodeAt(this.pos++) != 117 || this.source.charCodeAt(this.pos++) != 101) {
					this.pos = save3;
					this.invalidChar();
				}
				return new hxjsonast_Json(hxjsonast_JsonValue.JBool(true),new hxjsonast_Position(this.filename,save3 - 1,this.pos));
			case 123:
				var fields = [];
				var names = new haxe_ds_StringMap();
				var field = null;
				var fieldPos = null;
				var comma1 = null;
				var startPos1 = this.pos - 1;
				while(true) switch(this.source.charCodeAt(this.pos++)) {
				case 9:case 10:case 13:case 32:
					break;
				case 34:
					if(comma1) {
						this.invalidChar();
					}
					var fieldStartPos = this.pos - 1;
					field = this.parseString();
					fieldPos = new hxjsonast_Position(this.filename,fieldStartPos,this.pos);
					if(__map_reserved[field] != null ? names.existsReserved(field) : names.h.hasOwnProperty(field)) {
						throw new js__$Boot_HaxeError(new hxjsonast_Error("Duplicate field name \"" + field + "\"",fieldPos));
					} else if(__map_reserved[field] != null) {
						names.setReserved(field,true);
					} else {
						names.h[field] = true;
					}
					break;
				case 44:
					if(comma1) {
						comma1 = false;
					} else {
						this.invalidChar();
					}
					break;
				case 58:
					if(field == null) {
						this.invalidChar();
					}
					fields.push(new hxjsonast_JObjectField(field,fieldPos,this.parseRec()));
					field = null;
					fieldPos = null;
					comma1 = true;
					break;
				case 125:
					if(field != null || comma1 == false) {
						this.invalidChar();
					}
					return new hxjsonast_Json(hxjsonast_JsonValue.JObject(fields),new hxjsonast_Position(this.filename,startPos1,this.pos));
				default:
					this.invalidChar();
				}
				break;
			default:
				this.invalidChar();
			}
		}
	}
	,parseString: function() {
		var start = this.pos;
		var buf = null;
		while(true) {
			var c = this.source.charCodeAt(this.pos++);
			if(c == 34) {
				break;
			}
			if(c == 92) {
				if(buf == null) {
					buf = new StringBuf();
				}
				var s = this.source;
				var len = this.pos - start - 1;
				buf.b += len == null ? HxOverrides.substr(s,start,null) : HxOverrides.substr(s,start,len);
				c = this.source.charCodeAt(this.pos++);
				switch(c) {
				case 34:case 47:case 92:
					buf.b += String.fromCodePoint(c);
					break;
				case 98:
					buf.b += String.fromCodePoint(8);
					break;
				case 102:
					buf.b += String.fromCodePoint(12);
					break;
				case 110:
					buf.b += String.fromCodePoint(10);
					break;
				case 114:
					buf.b += String.fromCodePoint(13);
					break;
				case 116:
					buf.b += String.fromCodePoint(9);
					break;
				case 117:
					var uc = Std.parseInt("0x" + HxOverrides.substr(this.source,this.pos,4));
					this.pos += 4;
					buf.b += String.fromCodePoint(uc);
					break;
				default:
					throw new js__$Boot_HaxeError(new hxjsonast_Error("Invalid escape sequence \\" + String.fromCodePoint(c),new hxjsonast_Position(this.filename,this.pos - 2,this.pos)));
				}
				start = this.pos;
			} else if(c != c) {
				this.pos--;
				throw new js__$Boot_HaxeError(new hxjsonast_Error("Unclosed string",new hxjsonast_Position(this.filename,start - 1,this.pos)));
			}
		}
		if(buf == null) {
			return HxOverrides.substr(this.source,start,this.pos - start - 1);
		} else {
			var s1 = this.source;
			var len1 = this.pos - start - 1;
			buf.b += len1 == null ? HxOverrides.substr(s1,start,null) : HxOverrides.substr(s1,start,len1);
			return buf.b;
		}
	}
	,parseNumber: function(c) {
		var start = this.pos - 1;
		var minus = c == 45;
		var digit = !minus;
		var zero = c == 48;
		var point = false;
		var e = false;
		var pm = false;
		var end = false;
		while(true) {
			switch(this.source.charCodeAt(this.pos++)) {
			case 43:case 45:
				if(!e || pm) {
					this.invalidNumber(start);
				}
				digit = false;
				pm = true;
				break;
			case 46:
				if(minus || point) {
					this.invalidNumber(start);
				}
				digit = false;
				point = true;
				break;
			case 48:
				if(zero && !point) {
					this.invalidNumber(start);
				}
				if(minus) {
					minus = false;
					zero = true;
				}
				digit = true;
				break;
			case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				if(zero && !point) {
					this.invalidNumber(start);
				}
				if(minus) {
					minus = false;
				}
				digit = true;
				zero = false;
				break;
			case 69:case 101:
				if(minus || zero || e) {
					this.invalidNumber(start);
				}
				digit = false;
				e = true;
				break;
			default:
				if(!digit) {
					this.invalidNumber(start);
				}
				this.pos--;
				end = true;
			}
			if(end) {
				break;
			}
		}
		var s = HxOverrides.substr(this.source,start,this.pos - start);
		return new hxjsonast_Json(hxjsonast_JsonValue.JNumber(s),new hxjsonast_Position(this.filename,start,this.pos));
	}
	,nextChar: function() {
		return this.source.charCodeAt(this.pos++);
	}
	,mk: function(pos,value) {
		return new hxjsonast_Json(value,pos);
	}
	,mkPos: function(min,max) {
		return new hxjsonast_Position(this.filename,min,max);
	}
	,invalidChar: function() {
		this.pos--;
		throw new js__$Boot_HaxeError(new hxjsonast_Error("Invalid character: " + this.source.charAt(this.pos),new hxjsonast_Position(this.filename,this.pos,this.pos + 1)));
	}
	,invalidNumber: function(start) {
		throw new js__$Boot_HaxeError(new hxjsonast_Error("Invalid number: " + this.source.substring(start,this.pos),new hxjsonast_Position(this.filename,start,this.pos)));
	}
};
var hxjsonast_Position = function(file,min,max) {
	this.file = file;
	this.min = min;
	this.max = max;
};
hxjsonast_Position.__name__ = true;
var hxparse__$LexEngine_Transition = function(chars) {
	this.chars = chars;
};
hxparse__$LexEngine_Transition.__name__ = true;
hxparse__$LexEngine_Transition.prototype = {
	toString: function() {
		return Std.string(this.chars);
	}
};
var hxparse_ParserError = function(pos) {
	this.pos = pos;
};
hxparse_ParserError.__name__ = true;
hxparse_ParserError.prototype = {
	toString: function() {
		return "Parser error";
	}
};
var hxparse_RuleBuilderImpl = function() { };
hxparse_RuleBuilderImpl.__name__ = true;
var hxparse_State = function() {
	this.finalId = -1;
	var this1 = new Array(256);
	this.trans = this1;
};
hxparse_State.__name__ = true;
var hxparse_UnexpectedChar = function(char,pos) {
	hxparse_ParserError.call(this,pos);
	this.char = char;
};
hxparse_UnexpectedChar.__name__ = true;
hxparse_UnexpectedChar.__super__ = hxparse_ParserError;
hxparse_UnexpectedChar.prototype = $extend(hxparse_ParserError.prototype,{
	toString: function() {
		return "Unexpected " + this.char;
	}
});
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_lib__$ArrayBuffer_ArrayBufferCompat = function() { };
js_lib__$ArrayBuffer_ArrayBufferCompat.__name__ = true;
js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var resultArray = new Uint8Array(u.byteLength);
	resultArray.set(u);
	return resultArray.buffer;
};
var js_node_Fs = require("fs");
var js_node_Path = require("path");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_buffer__$Buffer_Helper = function() { };
js_node_buffer__$Buffer_Helper.__name__ = true;
js_node_buffer__$Buffer_Helper.bytesOfBuffer = function(b) {
	var o = Object.create(haxe_io_Bytes.prototype);
	o.length = b.byteLength;
	o.b = b;
	b.bufferValue = b;
	b.hxBytes = o;
	b.bytes = b;
	return o;
};
var json2object_Error = $hxEnums["json2object.Error"] = { __ename__ : true, __constructs__ : ["IncorrectType","IncorrectEnumValue","InvalidEnumConstructor","UninitializedVariable","UnknownVariable","ParserError"]
	,IncorrectType: ($_=function(variable,expected,pos) { return {_hx_index:0,variable:variable,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","expected","pos"],$_)
	,IncorrectEnumValue: ($_=function(value,expected,pos) { return {_hx_index:1,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["value","expected","pos"],$_)
	,InvalidEnumConstructor: ($_=function(value,expected,pos) { return {_hx_index:2,value:value,expected:expected,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["value","expected","pos"],$_)
	,UninitializedVariable: ($_=function(variable,pos) { return {_hx_index:3,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","pos"],$_)
	,UnknownVariable: ($_=function(variable,pos) { return {_hx_index:4,variable:variable,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["variable","pos"],$_)
	,ParserError: ($_=function(message,pos) { return {_hx_index:5,message:message,pos:pos,__enum__:"json2object.Error",toString:$estr}; },$_.__params__ = ["message","pos"],$_)
};
var json2object_JsonParser = function() { };
json2object_JsonParser.__name__ = true;
var json2object_PositionUtils = function(content) {
	this.linesInfo = [];
	var s = 0;
	var e = 0;
	var i = 0;
	var lineCount = 0;
	while(i < content.length) switch(content.charAt(i)) {
	case "\n":
		e = i;
		this.linesInfo.push({ number : lineCount, start : s, end : e});
		++lineCount;
		++i;
		s = i;
		break;
	case "\r":
		e = i;
		if(content.charAt(i + 1) == "\n") {
			++e;
		}
		this.linesInfo.push({ number : lineCount, start : s, end : e});
		++lineCount;
		i = e + 1;
		s = i;
		break;
	default:
		++i;
	}
	this.linesInfo.push({ number : lineCount, start : s, end : i});
};
json2object_PositionUtils.__name__ = true;
json2object_PositionUtils.prototype = {
	convertPosition: function(position) {
		var file = position.file;
		var min = position.min;
		var max = position.max;
		var pos = { file : file, min : min + 1, max : max + 1, lines : []};
		var lastLine = this.linesInfo.length - 1;
		var bounds_min = 0;
		var bounds_max = lastLine;
		if(min > this.linesInfo[0].end) {
			while(bounds_max > bounds_min) {
				var i = (bounds_min + bounds_max) / 2 | 0;
				var line = this.linesInfo[i];
				if(line.start == min) {
					bounds_min = i;
					bounds_max = i;
				}
				if(line.end < min) {
					bounds_min = i + 1;
				}
				if(line.start > min || line.end >= min && line.start < min) {
					bounds_max = i;
				}
			}
		}
		var _g = bounds_min;
		var _g1 = this.linesInfo.length;
		while(_g < _g1) {
			var i1 = _g++;
			var line1 = this.linesInfo[i1];
			if(line1.start <= min && line1.end >= max) {
				pos.lines.push({ number : line1.number + 1, start : min - line1.start + 1, end : max - line1.start + 1});
				break;
			}
			if(line1.start <= min && min <= line1.end) {
				pos.lines.push({ number : line1.number + 1, start : min - line1.start + 1, end : line1.end + 1});
			}
			if(line1.start <= max && max <= line1.end) {
				pos.lines.push({ number : line1.number + 1, start : line1.start + 1, end : max - line1.start + 1});
			}
			if(line1.start >= max || line1.end >= max) {
				break;
			}
		}
		return pos;
	}
	,revert: function(position) {
		return new hxjsonast_Position(position.file,position.min - 1,position.max - 1);
	}
};
var sys_FileSystem = function() { };
sys_FileSystem.__name__ = true;
sys_FileSystem.exists = function(path) {
	try {
		js_node_Fs.accessSync(path);
		return true;
	} catch( _ ) {
		haxe_CallStack.lastException = _;
		var _1 = ((_) instanceof js__$Boot_HaxeError) ? _.val : _;
		return false;
	}
};
sys_FileSystem.isDirectory = function(path) {
	try {
		return js_node_Fs.statSync(path).isDirectory();
	} catch( e ) {
		haxe_CallStack.lastException = e;
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		return false;
	}
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( e ) {
			haxe_CallStack.lastException = e;
			var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,eof: function() {
		return this.pos >= js_node_Fs.fstatSync(this.fd).size;
	}
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
sys_io_FileOutput.__name__ = true;
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(b) {
		var buf = new js_node_buffer_Buffer(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = js_node_buffer_Buffer.from(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
});
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__ : true, __constructs__ : ["SeekBegin","SeekCur","SeekEnd"]
	,SeekBegin: {_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
var tokentree_TokenStreamMode = $hxEnums["tokentree.TokenStreamMode"] = { __ename__ : true, __constructs__ : ["STRICT","RELAXED"]
	,STRICT: {_hx_index:0,__enum__:"tokentree.TokenStreamMode",toString:$estr}
	,RELAXED: {_hx_index:1,__enum__:"tokentree.TokenStreamMode",toString:$estr}
};
var tokentree_TokenStream = function(tokens,bytes) {
	this.tokens = tokens;
	this.bytes = bytes;
	this.sharpIfStack = [];
	this.tempStore = [];
	this.current = 0;
};
tokentree_TokenStream.__name__ = true;
tokentree_TokenStream.prototype = {
	hasMore: function() {
		return this.current < this.tokens.length;
	}
	,consumeToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("no more tokens");
			case 1:
				return this.createDummyToken(haxeparser_TokenDef.CommentLine("auto insert"));
			}
		}
		var token = this.tokens[this.current];
		this.current++;
		var space = "";
		return new tokentree_TokenTree(token.tok,space,token.pos,this.current - 1);
	}
	,consumeConstIdent: function() {
		var _g = this.token();
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				return this.consumeToken();
			} else {
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					var s = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
					throw new js__$Boot_HaxeError(this.formatCurrentPos() + ": " + s);
				case 1:
					return this.createDummyToken(haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
				}
			}
			break;
		case 3:
			var _g3 = _g.s;
			return this.consumeToken();
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s1 = "bad token " + Std.string(this.token()) + " != Const(CIdent(_))";
				throw new js__$Boot_HaxeError(this.formatCurrentPos() + ": " + s1);
			case 1:
				return this.createDummyToken(haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent("autoInsert")));
			}
		}
	}
	,consumeConst: function() {
		var _g = this.token();
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			return this.consumeToken();
		} else {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				var s = "bad token " + Std.string(this.token()) + " != Const(_)";
				throw new js__$Boot_HaxeError(this.formatCurrentPos() + ": " + s);
			case 1:
				return this.createDummyToken(haxeparser_TokenDef.Const(haxe_macro_Constant.CString("autoInsert")));
			}
		}
	}
	,consumeTokenDef: function(tokenDef) {
		if(this.is(tokenDef)) {
			return this.consumeToken();
		}
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			var s = "bad token " + Std.string(this.token()) + " != " + Std.string(tokenDef);
			throw new js__$Boot_HaxeError(this.formatCurrentPos() + ": " + s);
		case 1:
			return this.createDummyToken(tokenDef);
		}
	}
	,consumeToTempStore: function() {
		this.tempStore.push(this.consumeToken());
	}
	,addToTempStore: function(token) {
		this.tempStore.push(token);
	}
	,applyTempStore: function(parent) {
		while(this.tempStore.length > 0) parent.addChild(this.tempStore.shift());
	}
	,getTempStore: function() {
		return this.tempStore;
	}
	,clearTempStore: function() {
		this.tempStore = [];
	}
	,error: function(s) {
		throw new js__$Boot_HaxeError(this.formatCurrentPos() + ": " + s);
	}
	,formatCurrentPos: function() {
		var pos = this.tokens[this.current].pos;
		return new hxparse_Position(pos.file,pos.min,pos.max).format(this.bytes);
	}
	,is: function(tokenDef) {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var token = this.tokens[this.current];
		return Type.enumEq(tokenDef,token.tok);
	}
	,isSharp: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var token = this.tokens[this.current];
		var _g = token.tok;
		if(_g._hx_index == 2) {
			var _g1 = _g.s;
			return true;
		} else {
			return false;
		}
	}
	,isTypedParam: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return false;
		}
		var index = this.current + 1;
		var token = this.tokens[this.current];
		var _g = token.tok;
		if(_g._hx_index == 5) {
			if(_g.op._hx_index != 9) {
				return false;
			}
		} else {
			return false;
		}
		while(true) {
			token = this.tokens[index++];
			var _g2 = token.tok;
			switch(_g2._hx_index) {
			case 0:
				var _g5 = _g2.k;
				break;
			case 1:
				var _g4 = _g2.c;
				break;
			case 3:
				var _g6 = _g2.s;
				break;
			case 5:
				switch(_g2.op._hx_index) {
				case 7:
					return true;
				case 9:
					break;
				default:
					return false;
				}
				break;
			case 10:
				break;
			case 11:
				break;
			case 13:
				break;
			default:
				return false;
			}
		}
	}
	,token: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("no more tokens");
			case 1:
				return haxeparser_TokenDef.CommentLine("auto insert");
			}
		}
		return this.tokens[this.current].tok;
	}
	,peekNonCommentToken: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("no more tokens");
			case 1:
				return haxeparser_TokenDef.Const(haxe_macro_Constant.CString("auto insert"));
			}
		}
		var index = this.current;
		while(index < this.tokens.length) {
			var token = this.tokens[index++];
			if(haxeparser_Token == null) {
				continue;
			}
			var _g = token.tok;
			switch(_g._hx_index) {
			case 6:
				var _g2 = _g.s;
				break;
			case 7:
				var _g1 = _g.s;
				break;
			default:
				return token.tok;
			}
		}
		return null;
	}
	,getTokenPos: function() {
		if(this.current < 0 || this.current >= this.tokens.length) {
			return null;
		}
		return this.tokens[this.current].pos;
	}
	,rewind: function() {
		if(this.current <= 0) {
			return;
		}
		this.current--;
	}
	,getStreamIndex: function() {
		return this.current;
	}
	,rewindTo: function(pos) {
		this.current = pos;
	}
	,consumeOpGt: function() {
		var tok = this.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 5) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
				return new tokentree_TokenTree(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGte),tok.space + assignTok.space,{ file : tok.pos.file, min : tok.pos.min, max : assignTok.pos.max},tok.index);
			case 7:
				return this.consumeOpShr(tok);
			default:
				return tok;
			}
		} else {
			return tok;
		}
	}
	,consumeOpShr: function(parent) {
		var tok = this.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
		var _g = this.token();
		if(_g._hx_index == 5) {
			switch(_g.op._hx_index) {
			case 4:
				var assignTok = this.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
				return new tokentree_TokenTree(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShr)),assignTok.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok.pos.max},parent.index);
			case 7:
				var innerGt = this.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
				if(this.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign))) {
					var assignTok1 = this.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
					return new tokentree_TokenTree(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpUShr)),assignTok1.space,{ file : parent.pos.file, min : parent.pos.min, max : assignTok1.pos.max},parent.index);
				}
				return new tokentree_TokenTree(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpUShr),innerGt.space,{ file : parent.pos.file, min : parent.pos.min, max : innerGt.pos.max},parent.index);
			default:
				return new tokentree_TokenTree(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
			}
		} else {
			return new tokentree_TokenTree(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShr),tok.space,{ file : parent.pos.file, min : parent.pos.min, max : tok.pos.max},parent.index);
		}
	}
	,consumeOpSub: function() {
		var tok = this.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpSub));
		var _g = this.token();
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				var _g2 = _g1.v;
				break;
			case 1:
				var _g3 = _g1.f;
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
		} else {
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var previous = this.current - 2;
		if(previous < 0) {
			throw new js__$Boot_HaxeError("no more tokens");
		}
		var prevTok = this.tokens[previous];
		var _g4 = prevTok.tok;
		switch(_g4._hx_index) {
		case 0:
			switch(_g4.k._hx_index) {
			case 3:case 4:case 5:case 6:case 7:case 10:case 15:case 29:
				break;
			default:
				return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
			}
			break;
		case 4:
			var _g6 = _g4.op;
			break;
		case 5:
			var _g5 = _g4.op;
			break;
		case 8:
			var _g7 = _g4.s;
			break;
		case 11:case 13:case 14:case 18:case 20:
			break;
		default:
			return new tokentree_TokenTree(tok.tok,tok.space,tok.pos,tok.index);
		}
		var _g9 = this.token();
		if(_g9._hx_index == 1) {
			var _g10 = _g9.c;
			switch(_g10._hx_index) {
			case 0:
				var n = _g10.v;
				var $const = this.consumeConst();
				return new tokentree_TokenTree(haxeparser_TokenDef.Const(haxe_macro_Constant.CInt("-" + n)),$const.space,{ file : tok.pos.file, min : tok.pos.min, max : $const.pos.max},tok.index);
			case 1:
				var n1 = _g10.f;
				var const1 = this.consumeConst();
				return new tokentree_TokenTree(haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat("-" + n1)),const1.space,{ file : tok.pos.file, min : tok.pos.min, max : const1.pos.max},tok.index);
			default:
				throw new js__$Boot_HaxeError("no more tokens");
			}
		} else {
			throw new js__$Boot_HaxeError("no more tokens");
		}
	}
	,pushSharpIf: function(token) {
		this.sharpIfStack.push(token);
	}
	,popSharpIf: function() {
		var token = this.sharpIfStack.pop();
		if(token == null) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("no more tokens");
			case 1:
				return this.createDummyToken(haxeparser_TokenDef.CommentLine("dummy token"));
			}
		}
		return token;
	}
	,peekSharpIf: function() {
		if(this.sharpIfStack.length <= 0) {
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("no more tokens");
			case 1:
				return this.createDummyToken(haxeparser_TokenDef.CommentLine("dummy token"));
			}
		}
		return this.sharpIfStack[this.sharpIfStack.length - 1];
	}
	,createDummyToken: function(tokDef) {
		var pos;
		if(this.current < 0 || this.current >= this.tokens.length) {
			var prevPos = this.tokens[this.tokens.length - 1].pos;
			pos = { min : prevPos.max, max : prevPos.max, file : prevPos.file};
		} else {
			var prevPos1 = this.tokens[this.current].pos;
			pos = { min : prevPos1.min, max : prevPos1.min, file : prevPos1.file};
		}
		return new tokentree_TokenTree(tokDef,"",pos,-1,true);
	}
};
var tokentree_TokenStreamProgress = function(stream) {
	this.stream = stream;
	this.pos = -1;
};
tokentree_TokenStreamProgress.__name__ = true;
tokentree_TokenStreamProgress.prototype = {
	streamHasChanged: function() {
		if(this.pos == -1) {
			this.pos = this.stream.getStreamIndex();
			return true;
		}
		var oldPos = this.pos;
		this.pos = this.stream.getStreamIndex();
		return this.pos != oldPos;
	}
};
var tokentree_TokenTree = function(tok,space,pos,index,inserted) {
	if(inserted == null) {
		inserted = false;
	}
	haxeparser_Token.call(this,tok,pos);
	this.index = index;
	this.inserted = inserted;
	this.space = space;
	this.tokenTypeCache = { };
};
tokentree_TokenTree.__name__ = true;
tokentree_TokenTree.__super__ = haxeparser_Token;
tokentree_TokenTree.prototype = $extend(haxeparser_Token.prototype,{
	is: function(tokenDef) {
		if(this.tok == null) {
			return false;
		}
		return Type.enumEq(tokenDef,this.tok);
	}
	,isComment: function() {
		if(this.tok == null) {
			return false;
		}
		var _g = this.tok;
		switch(_g._hx_index) {
		case 6:
			var _g2 = _g.s;
			return true;
		case 7:
			var _g1 = _g.s;
			return true;
		default:
			return false;
		}
	}
	,isCIdent: function() {
		if(this.tok == null) {
			return false;
		}
		var _g = this.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	,isCIdentOrCString: function() {
		if(this.tok == null) {
			return false;
		}
		var _g = this.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			switch(_g1._hx_index) {
			case 2:
				var _g3 = _g1.s;
				return true;
			case 3:
				var _g2 = _g1.s;
				return true;
			default:
				return false;
			}
		} else {
			return false;
		}
	}
	,addChild: function(child) {
		if(child == null) {
			return;
		}
		if(this.children == null) {
			this.children = [];
		}
		if(this.children.length > 0) {
			child.previousSibling = this.children[this.children.length - 1];
			this.children[this.children.length - 1].nextSibling = child;
		}
		this.children.push(child);
		child.parent = this;
	}
	,hasChildren: function() {
		if(this.children == null) {
			return false;
		}
		return this.children.length > 0;
	}
	,getFirstChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[0];
	}
	,getLastChild: function() {
		if(!this.hasChildren()) {
			return null;
		}
		return this.children[this.children.length - 1];
	}
	,getPos: function() {
		if(this.children == null || this.children.length <= 0) {
			return this.pos;
		}
		var fullPos = { file : this.pos.file, min : this.pos.min, max : this.pos.max};
		var childPos;
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			childPos = child.getPos();
			if(childPos.min < fullPos.min) {
				fullPos.min = childPos.min;
			}
			if(childPos.max > fullPos.max) {
				fullPos.max = childPos.max;
			}
		}
		return fullPos;
	}
	,filter: function(searchFor,mode,maxLevel) {
		if(maxLevel == null) {
			maxLevel = 9999;
		}
		return this.filterCallback(function(token,depth) {
			if(depth > maxLevel) {
				return tokentree_FilterResult.SKIP_SUBTREE;
			}
			if(token.matchesAny(searchFor)) {
				if(mode == tokentree_TokenFilterMode.ALL) {
					return tokentree_FilterResult.FOUND_GO_DEEPER;
				}
				return tokentree_FilterResult.FOUND_SKIP_SUBTREE;
			} else {
				return tokentree_FilterResult.GO_DEEPER;
			}
		});
	}
	,filterCallback: function(callback) {
		var results = [];
		this.internalFilterCallback(callback,results,0);
		return results;
	}
	,internalFilterCallback: function(callback,results,depth) {
		if(depth == null) {
			depth = 0;
		}
		if(this.tok != null) {
			switch(callback(this,depth)._hx_index) {
			case 0:
				results.push(this);
				return;
			case 1:
				results.push(this);
				break;
			case 2:
				return;
			case 3:
				break;
			}
		}
		if(this.children == null) {
			return;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 2) {
				var _g11 = _g2.s;
				child.internalFilterCallback(callback,results,depth);
			} else {
				child.internalFilterCallback(callback,results,depth + 1);
			}
		}
	}
	,matchesAny: function(searchFor) {
		if(searchFor == null || this.tok == null) {
			return false;
		}
		var _g = 0;
		while(_g < searchFor.length) {
			var search = searchFor[_g];
			++_g;
			if(Type.enumEq(this.tok,search)) {
				return true;
			}
		}
		return false;
	}
	,printTokenTree: function(prefix) {
		if(prefix == null) {
			prefix = "";
		}
		var buf_b = "";
		var tokString = "" + Std.string(this.tok);
		if(this.inserted) {
			tokString = "*** " + tokString + " ***";
		}
		if(this.tok != null) {
			buf_b += Std.string("" + prefix + tokString + "\t\t\t\t" + Std.string(this.getPos()));
		}
		if(this.children == null) {
			return buf_b;
		}
		var _g = 0;
		var _g1 = this.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			buf_b += Std.string("\n" + prefix + child.printTokenTree(prefix + "  "));
		}
		return buf_b;
	}
});
var tokentree_TokenFilterMode = $hxEnums["tokentree.TokenFilterMode"] = { __ename__ : true, __constructs__ : ["ALL","FIRST"]
	,ALL: {_hx_index:0,__enum__:"tokentree.TokenFilterMode",toString:$estr}
	,FIRST: {_hx_index:1,__enum__:"tokentree.TokenFilterMode",toString:$estr}
};
var tokentree_FilterResult = $hxEnums["tokentree.FilterResult"] = { __ename__ : true, __constructs__ : ["FOUND_SKIP_SUBTREE","FOUND_GO_DEEPER","SKIP_SUBTREE","GO_DEEPER"]
	,FOUND_SKIP_SUBTREE: {_hx_index:0,__enum__:"tokentree.FilterResult",toString:$estr}
	,FOUND_GO_DEEPER: {_hx_index:1,__enum__:"tokentree.FilterResult",toString:$estr}
	,SKIP_SUBTREE: {_hx_index:2,__enum__:"tokentree.FilterResult",toString:$estr}
	,GO_DEEPER: {_hx_index:3,__enum__:"tokentree.FilterResult",toString:$estr}
};
var tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$ = {};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.__name__ = true;
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.get_token = function(this1) {
	return this1;
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.access = function(tok) {
	return tok;
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent = function(this1) {
	if(this1 != null) {
		return this1.parent;
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.findParent = function(this1,predicate) {
	var parent = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(this1);
	while(parent != null && parent.tok != null) {
		if(predicate(parent)) {
			return parent;
		}
		parent = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(parent);
	}
	return null;
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.previousSibling = function(this1) {
	if(this1 != null) {
		return this1.previousSibling;
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.nextSibling = function(this1) {
	if(this1 != null) {
		return this1.nextSibling;
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild = function(this1) {
	if(this1 != null) {
		return this1.getFirstChild();
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastChild = function(this1) {
	if(this1 != null) {
		return this1.getLastChild();
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf = function(this1,tokenDef) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(tok.is(tokenDef)) {
			return tok;
		}
	}
	return null;
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastOf = function(this1,tokenDef) {
	if(this1 == null || this1.children == null) {
		return null;
	}
	var found = null;
	var _g = 0;
	var _g1 = this1.children;
	while(_g < _g1.length) {
		var tok = _g1[_g];
		++_g;
		if(tok.is(tokenDef)) {
			found = tok;
		}
	}
	return found;
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.child = function(this1,index) {
	if(this1 != null && this1.children != null) {
		return this1.children[index];
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is = function(this1,tokenDef) {
	if(this1 != null && this1.is(tokenDef)) {
		return this1;
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isComment = function(this1) {
	if(this1 != null && this1.isComment()) {
		return this1;
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent = function(this1) {
	if(this1 != null && this1.isCIdent()) {
		return this1;
	} else {
		return null;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.or = function(this1,other) {
	if(this1 != null) {
		return this1;
	} else {
		return other;
	}
};
tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.exists = function(this1) {
	return this1 != null;
};
var tokentree_TokenTreeBuilder = function() { };
tokentree_TokenTreeBuilder.__name__ = true;
tokentree_TokenTreeBuilder.buildTokenTree = function(tokens,bytes,entryPoint) {
	if(entryPoint == null) {
		entryPoint = tokentree_TokenTreeEntryPoint.TYPE_LEVEL;
	}
	return tokentree_TokenTreeBuilder.buildTokenTreeFromStream(new tokentree_TokenStream(tokens,bytes),entryPoint);
};
tokentree_TokenTreeBuilder.buildTokenTreeFromStream = function(stream,entryPoint) {
	var root = new tokentree_TokenTree(null,"",null,-1);
	switch(entryPoint._hx_index) {
	case 0:
		tokentree_walk_WalkFile.walkFile(stream,root);
		break;
	case 1:
		tokentree_walk_WalkClass.walkClassBody(stream,root);
		break;
	case 2:
		tokentree_walk_WalkStatement.walkStatement(stream,root);
		break;
	}
	if(stream.hasMore()) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw new js__$Boot_HaxeError("invalid token tree structure - found:" + Std.string(stream.token()));
		case 1:
			var progress = new tokentree_TokenStreamProgress(stream);
			while(progress.streamHasChanged()) tokentree_walk_WalkStatement.walkStatement(stream,root);
			if(stream.hasMore()) {
				throw new js__$Boot_HaxeError("invalid token tree structure - found:" + Std.string(stream.token()));
			}
			break;
		}
	}
	var tempStore = stream.getTempStore();
	switch(tokentree_TokenStream.MODE._hx_index) {
	case 0:
		if(tempStore.length != 0) {
			throw new js__$Boot_HaxeError("invalid token tree structure - tokens in temp store:" + tempStore.join(", "));
		}
		break;
	case 1:
		var _g = 0;
		while(_g < tempStore.length) {
			var stored = tempStore[_g];
			++_g;
			root.addChild(stored);
		}
		break;
	}
	return root;
};
var tokentree_TokenTreeEntryPoint = $hxEnums["tokentree.TokenTreeEntryPoint"] = { __ename__ : true, __constructs__ : ["TYPE_LEVEL","FIELD_LEVEL","EXPRESSION_LEVEL"]
	,TYPE_LEVEL: {_hx_index:0,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,FIELD_LEVEL: {_hx_index:1,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
	,EXPRESSION_LEVEL: {_hx_index:2,__enum__:"tokentree.TokenTreeEntryPoint",toString:$estr}
};
var tokentree_utils_FieldUtils = function() { };
tokentree_utils_FieldUtils.__name__ = true;
tokentree_utils_FieldUtils.getFieldType = function(field,defaultVisibility) {
	if(field == null) {
		return tokentree_utils_TokenFieldType.UNKNOWN;
	}
	var _g = field.tok;
	if(_g._hx_index == 0) {
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_FieldUtils.getFunctionFieldType(field,defaultVisibility);
		case 2:case 41:
			return tokentree_utils_FieldUtils.getVarFieldType(field,defaultVisibility);
		default:
		}
	}
	return tokentree_utils_TokenFieldType.UNKNOWN;
};
tokentree_utils_FieldUtils.getFunctionFieldType = function(field,defaultVisibility) {
	var access = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(field);
	if(access == null) {
		return tokentree_utils_TokenFieldType.UNKNOWN;
	}
	var name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
	var visibility = defaultVisibility;
	var isStatic = false;
	var isInline = false;
	var isOverride = false;
	var isFinal = false;
	var isExtern = false;
	if(access.children != null) {
		var _g = 0;
		var _g1 = access.children;
		_hx_loop1: while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			switch(_g2._hx_index) {
			case 0:
				switch(_g2.k._hx_index) {
				case 17:
					isStatic = true;
					break;
				case 18:
					visibility = tokentree_utils_TokenFieldVisibility.PUBLIC;
					break;
				case 19:
					visibility = tokentree_utils_TokenFieldVisibility.PRIVATE;
					break;
				case 25:
					isExtern = true;
					break;
				case 30:
					isOverride = true;
					break;
				case 34:
					isInline = true;
					break;
				case 41:
					isFinal = true;
					break;
				default:
				}
				break;
			case 1:
				var _g21 = _g2.c;
				if(_g21._hx_index == 3) {
					if(_g21.s == "final") {
						isFinal = true;
					}
				}
				break;
			case 16:case 18:
				break _hx_loop1;
			default:
			}
		}
	}
	return tokentree_utils_TokenFieldType.FUNCTION(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern);
};
tokentree_utils_FieldUtils.getVarFieldType = function(field,defaultVisibility) {
	var access = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(field);
	if(access == null) {
		return tokentree_utils_TokenFieldType.UNKNOWN;
	}
	var name = tokentree_utils_TokenTreeCheckUtils.getName(tokentree_utils_TokenTreeCheckUtils.getNameToken(field));
	var visibility = defaultVisibility;
	var isStatic = false;
	var isInline = false;
	var isFinal = field.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFinal));
	var isExtern = false;
	if(access.children != null) {
		var _g = 0;
		var _g1 = access.children;
		while(_g < _g1.length) {
			var child = _g1[_g];
			++_g;
			var _g2 = child.tok;
			if(_g2._hx_index == 0) {
				switch(_g2.k._hx_index) {
				case 17:
					isStatic = true;
					break;
				case 18:
					visibility = tokentree_utils_TokenFieldVisibility.PUBLIC;
					break;
				case 19:
					visibility = tokentree_utils_TokenFieldVisibility.PRIVATE;
					break;
				case 25:
					isExtern = true;
					break;
				case 34:
					isInline = true;
					break;
				default:
				}
			}
		}
	}
	access = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(access,haxeparser_TokenDef.POpen);
	if(isFinal || access == null) {
		return tokentree_utils_TokenFieldType.VAR(name,visibility,isStatic,isInline,isFinal,isExtern);
	}
	var getterAccess = tokentree_utils_FieldUtils.makePropertyAccess(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(access));
	var setterAccess = tokentree_utils_FieldUtils.makePropertyAccess(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.child(access,1));
	return tokentree_utils_TokenFieldType.PROP(name,visibility,isStatic,getterAccess,setterAccess);
};
tokentree_utils_FieldUtils.makePropertyAccess = function(accessToken) {
	if(accessToken == null) {
		return tokentree_utils_TokenPropertyAccess.DEFAULT;
	}
	var _g = accessToken.tok;
	switch(_g._hx_index) {
	case 0:
		switch(_g.k._hx_index) {
		case 16:
			return tokentree_utils_TokenPropertyAccess.DEFAULT;
		case 32:
			return tokentree_utils_TokenPropertyAccess.DYNAMIC;
		case 36:
			return tokentree_utils_TokenPropertyAccess.NULL;
		default:
			return tokentree_utils_TokenPropertyAccess.DEFAULT;
		}
		break;
	case 1:
		var _g2 = _g.c;
		if(_g2._hx_index == 3) {
			switch(_g2.s) {
			case "get":
				return tokentree_utils_TokenPropertyAccess.GET;
			case "never":
				return tokentree_utils_TokenPropertyAccess.NEVER;
			case "set":
				return tokentree_utils_TokenPropertyAccess.SET;
			default:
				return tokentree_utils_TokenPropertyAccess.DEFAULT;
			}
		} else {
			return tokentree_utils_TokenPropertyAccess.DEFAULT;
		}
		break;
	default:
		return tokentree_utils_TokenPropertyAccess.DEFAULT;
	}
};
tokentree_utils_FieldUtils.isOperatorFunction = function(functionToken) {
	return Lambda.exists(tokentree_utils_TokenTreeCheckUtils.getMetadata(functionToken),function(meta) {
		var _g = meta.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "arrayAccess":
					return true;
				case "op":
					return true;
				case "resolve":
					return true;
				default:
					return false;
				}
			} else {
				return false;
			}
		} else {
			return false;
		}
	});
};
var tokentree_utils_TokenFieldType = $hxEnums["tokentree.utils.TokenFieldType"] = { __ename__ : true, __constructs__ : ["FUNCTION","VAR","PROP","UNKNOWN"]
	,FUNCTION: ($_=function(name,visibility,isStatic,isInline,isOverride,isFinal,isExtern) { return {_hx_index:0,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isOverride:isOverride,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","isInline","isOverride","isFinal","isExtern"],$_)
	,VAR: ($_=function(name,visibility,isStatic,isInline,isFinal,isExtern) { return {_hx_index:1,name:name,visibility:visibility,isStatic:isStatic,isInline:isInline,isFinal:isFinal,isExtern:isExtern,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","isInline","isFinal","isExtern"],$_)
	,PROP: ($_=function(name,visibility,isStatic,getter,setter) { return {_hx_index:2,name:name,visibility:visibility,isStatic:isStatic,getter:getter,setter:setter,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}; },$_.__params__ = ["name","visibility","isStatic","getter","setter"],$_)
	,UNKNOWN: {_hx_index:3,__enum__:"tokentree.utils.TokenFieldType",toString:$estr}
};
var tokentree_utils_TokenFieldVisibility = $hxEnums["tokentree.utils.TokenFieldVisibility"] = { __ename__ : true, __constructs__ : ["PUBLIC","PRIVATE"]
	,PUBLIC: {_hx_index:0,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
	,PRIVATE: {_hx_index:1,__enum__:"tokentree.utils.TokenFieldVisibility",toString:$estr}
};
var tokentree_utils_TokenPropertyAccess = $hxEnums["tokentree.utils.TokenPropertyAccess"] = { __ename__ : true, __constructs__ : ["DEFAULT","NULL","GET","SET","DYNAMIC","NEVER"]
	,DEFAULT: {_hx_index:0,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,NULL: {_hx_index:1,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,GET: {_hx_index:2,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,SET: {_hx_index:3,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,DYNAMIC: {_hx_index:4,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
	,NEVER: {_hx_index:5,__enum__:"tokentree.utils.TokenPropertyAccess",toString:$estr}
};
var tokentree_utils_TokenTreeCheckUtils = function() { };
tokentree_utils_TokenTreeCheckUtils.__name__ = true;
tokentree_utils_TokenTreeCheckUtils.isImportMult = function(token) {
	var _g = token.tok;
	switch(_g._hx_index) {
	case 5:
		if(_g.op._hx_index == 1) {
			return tokentree_utils_TokenTreeCheckUtils.isImport(token.parent);
		} else {
			return false;
		}
		break;
	case 10:
		return tokentree_utils_TokenTreeCheckUtils.isImport(token.parent);
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isImport = function(token) {
	var parent = token;
	while(parent != null) {
		if(parent.tok == null) {
			return false;
		}
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 13:
				return true;
			case 25:
				break;
			case 35:
				return true;
			case 40:
				break;
			default:
				return false;
			}
			break;
		case 1:
			var _g3 = _g.c;
			if(_g3._hx_index == 3) {
				var _g4 = _g3.s;
			} else {
				return false;
			}
			break;
		case 5:
			if(_g.op._hx_index != 23) {
				return false;
			}
			break;
		case 10:
			break;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isTypeParameter = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 5) {
		switch(_g.op._hx_index) {
		case 7:
			return tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(token),haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt)) != null;
		case 9:
			return tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt)) != null;
		default:
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isOpGtTypedefExtension = function(token) {
	var _g = token.tok;
	if(_g._hx_index == 5) {
		if(_g.op._hx_index == 7) {
			return tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(token),haxeparser_TokenDef.BrOpen)),haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign))))),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTypedef)) != null;
		} else {
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.filterOpSub = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	if(!(_g._hx_index == 5 && _g.op._hx_index == 3)) {
		return false;
	}
	var prev = token.previousSibling;
	if(token.previousSibling == null) {
		prev = token.parent;
	} else {
		prev = tokentree_utils_TokenTreeCheckUtils.getLastToken(token.previousSibling);
		if(prev == null) {
			return false;
		}
	}
	var _g2 = prev.tok;
	switch(_g2._hx_index) {
	case 0:
		switch(_g2.k._hx_index) {
		case 4:
			return true;
		case 5:
			return true;
		case 6:
			return true;
		case 10:
			return true;
		default:
			return false;
		}
		break;
	case 5:
		if(_g2.op._hx_index == 23) {
			return true;
		} else {
			return true;
		}
		break;
	case 11:
		return true;
	case 12:
		return true;
	case 13:
		return true;
	case 14:
		return true;
	case 15:
		return false;
	case 16:
		return true;
	case 17:
		return true;
	case 18:
		return true;
	case 19:
		var pOpen = prev.parent;
		var type = tokentree_utils_TokenTreeCheckUtils.getPOpenType(pOpen);
		switch(type._hx_index) {
		case 0:
			return true;
		case 1:
			return true;
		case 2:
			return false;
		case 3:
			return true;
		case 4:
			return true;
		case 5:
			return false;
		}
		break;
	case 20:
		return true;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isUnaryLeftSided = function(tok) {
	var child = tok.getFirstChild();
	if(child == null) {
		return false;
	}
	var _g = child.tok;
	switch(_g._hx_index) {
	case 0:
		switch(_g.k._hx_index) {
		case 23:
			return true;
		case 40:
			return true;
		default:
			return false;
		}
		break;
	case 1:
		var _g1 = _g.c;
		return true;
	case 18:
		return true;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTernary = function(token) {
	if(token == null) {
		return false;
	}
	if(token.is(haxeparser_TokenDef.DblDot)) {
		return tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent);
	}
	if(!token.is(haxeparser_TokenDef.Question)) {
		return false;
	}
	if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.DblDot) == null) {
		return false;
	}
	if(token.parent == null) {
		return false;
	}
	var _g = token.parent.tok;
	switch(_g._hx_index) {
	case 0:
		switch(_g.k._hx_index) {
		case 0:case 2:
			return false;
		case 41:
			return false;
		default:
			return true;
		}
		break;
	case 1:
		var _g4 = _g.c;
		if(_g4._hx_index == 3) {
			if(_g4.s == "final") {
				return false;
			} else {
				return true;
			}
		} else {
			return true;
		}
		break;
	case 2:
		var _g2 = _g.s;
		return false;
	case 5:
		var _g1 = _g.op;
		return true;
	case 13:
		return false;
	case 18:
		var prev = token.previousSibling;
		if(prev == null) {
			return false;
		}
		var lastToken = tokentree_utils_TokenTreeCheckUtils.getLastToken(prev);
		if(lastToken == null) {
			return false;
		}
		switch(lastToken.tok._hx_index) {
		case 9:
			return false;
		case 13:
			return false;
		default:
			return true;
		}
		break;
	default:
		return true;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract = function(type) {
	var _g = type.tok;
	if(_g._hx_index == 0) {
		if(_g.k._hx_index == 39) {
			var name = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(type);
			if(name == null || name.children == null || name.children.length <= 0) {
				return false;
			}
			if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(name,haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
				return true;
			}
			var _g1 = 0;
			var _g11 = name.children;
			while(_g1 < _g11.length) {
				var child = _g11[_g1];
				++_g1;
				if(!child.is(haxeparser_TokenDef.At)) {
					continue;
				}
				var enumTok = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(child),haxeparser_TokenDef.DblDot)),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdEnum));
				if(enumTok == null) {
					continue;
				}
				return true;
			}
		}
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isTypeStructure = function(typedefToken) {
	var afterAssign = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(typedefToken)),haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign)));
	if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(afterAssign,haxeparser_TokenDef.BrOpen) == null) {
		return tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent(afterAssign),haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd)) != null;
	} else {
		return true;
	}
};
tokentree_utils_TokenTreeCheckUtils.isTypeEnum = function(enumToken) {
	if(!enumToken.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdEnum))) {
		return false;
	}
	if(tokentree_utils_TokenTreeCheckUtils.isTypeEnumAbstract(enumToken)) {
		return false;
	}
	if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(enumToken),haxeparser_TokenDef.DblDot)),haxeparser_TokenDef.At) != null) {
		return false;
	}
	return true;
};
tokentree_utils_TokenTreeCheckUtils.isTypeMacroClass = function(classToken) {
	if(classToken.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdClass))) {
		return tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(classToken),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdMacro)) != null;
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.isBrOpenAnonTypeOrTypedef = function(token) {
	switch(tokentree_utils_TokenTreeCheckUtils.getBrOpenType(token)._hx_index) {
	case 0:
		return false;
	case 1:
		return true;
	case 2:
		return false;
	case 3:
		return true;
	case 4:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getName = function(token) {
	if(token == null) {
		return null;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 0:
		if(_g.k._hx_index == 22) {
			return "new";
		} else {
			return null;
		}
		break;
	case 1:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var ident = _g1.s;
			return ident;
		} else {
			return null;
		}
		break;
	default:
		return null;
	}
};
tokentree_utils_TokenTreeCheckUtils.getNameToken = function(token) {
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(token)) {
		return token;
	}
	var nameToken = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(token);
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	nameToken = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(nameToken,haxeparser_TokenDef.Question));
	if(tokentree_utils_TokenTreeCheckUtils.isNameToken(nameToken)) {
		return nameToken;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isNameToken = function(token) {
	if(token == null) {
		return false;
	}
	var _g = token.tok;
	switch(_g._hx_index) {
	case 0:
		if(_g.k._hx_index == 22) {
			return true;
		} else {
			return false;
		}
		break;
	case 1:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			return true;
		} else {
			return false;
		}
		break;
	default:
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getMetadata = function(declToken) {
	var ident = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.isCIdent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(declToken));
	if(ident == null || !ident.hasChildren()) {
		return [];
	}
	return ident.children.map(function(token) {
		return tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(token,haxeparser_TokenDef.At)),haxeparser_TokenDef.DblDot));
	}).filter(function(token1) {
		return token1 != null;
	});
};
tokentree_utils_TokenTreeCheckUtils.getDocComment = function(declToken) {
	var access = declToken;
	while(true) {
		access = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.previousSibling(access);
		if(access == null) {
			return null;
		}
		var _g = access.tok;
		switch(_g._hx_index) {
		case 6:
			var _g2 = _g.s;
			return access;
		case 7:
			var _g1 = _g.s;
			continue;
		default:
			return null;
		}
	}
};
tokentree_utils_TokenTreeCheckUtils.isModifier = function(keyword) {
	if(keyword == null) {
		return false;
	}
	var _g = keyword.tok;
	if(_g._hx_index == 0) {
		switch(_g.k._hx_index) {
		case 17:
			return true;
		case 18:
			return true;
		case 19:
			return true;
		case 25:
			return true;
		case 30:
			return true;
		case 32:
			return true;
		case 34:
			return true;
		case 40:
			return true;
		default:
			return false;
		}
	} else {
		return false;
	}
};
tokentree_utils_TokenTreeCheckUtils.getBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.UNKNOWN;
	}
	if(token.tokenTypeCache.brOpenType != null) {
		return token.tokenTypeCache.brOpenType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineBrOpenType(token);
	token.tokenTypeCache.brOpenType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineBrOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_BrOpenType.UNKNOWN;
	}
	if(token.parent == null || token.parent.tok == null) {
		return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
	}
	var _g = token.parent.tok;
	switch(_g._hx_index) {
	case 0:
		if(_g.k._hx_index == 10) {
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		}
		break;
	case 1:
		var _g3 = _g.c;
		if(_g3._hx_index == 3) {
			switch(_g3.s) {
			case "from":case "to":
				return tokentree_utils_BrOpenType.ANONTYPE;
			default:
				return tokentree_utils_BrOpenType.BLOCK;
			}
		} else {
			return tokentree_utils_BrOpenType.BLOCK;
		}
		break;
	case 5:
		switch(_g.op._hx_index) {
		case 4:
			if(tokentree_utils_TokenTreeCheckUtils.isInsideTypedef(token.parent)) {
				return tokentree_utils_BrOpenType.TYPEDEFDECL;
			}
			return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
		case 9:
			return tokentree_utils_BrOpenType.ANONTYPE;
		default:
			return tokentree_utils_BrOpenType.OBJECTDECL;
		}
		break;
	case 11:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.OBJECTDECL;
		}
		var parent = token.parent.parent;
		var _g1 = parent.tok;
		switch(_g1._hx_index) {
		case 0:
			switch(_g1.k._hx_index) {
			case 15:
				return tokentree_utils_BrOpenType.OBJECTDECL;
			case 16:
				return tokentree_utils_BrOpenType.OBJECTDECL;
			default:
				return tokentree_utils_BrOpenType.ANONTYPE;
			}
			break;
		case 1:
			var _g11 = _g1.c;
			switch(_g11._hx_index) {
			case 2:
				var _g31 = _g11.s;
				break;
			case 3:
				var _g2 = _g11.s;
				break;
			default:
				return tokentree_utils_BrOpenType.ANONTYPE;
			}
			break;
		default:
			return tokentree_utils_BrOpenType.ANONTYPE;
		}
		parent = parent.parent;
		var _g5 = parent.tok;
		switch(_g5._hx_index) {
		case 0:
			switch(_g5.k._hx_index) {
			case 0:
				return tokentree_utils_BrOpenType.ANONTYPE;
			case 2:
				return tokentree_utils_BrOpenType.ANONTYPE;
			default:
				return tokentree_utils_BrOpenType.OBJECTDECL;
			}
			break;
		case 5:
			if(_g5.op._hx_index == 9) {
				return tokentree_utils_BrOpenType.ANONTYPE;
			} else {
				return tokentree_utils_BrOpenType.OBJECTDECL;
			}
			break;
		case 16:
			return tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
		case 18:
			return tokentree_utils_BrOpenType.ANONTYPE;
		case 20:
			return tokentree_utils_BrOpenType.ANONTYPE;
		default:
			return tokentree_utils_BrOpenType.OBJECTDECL;
		}
		break;
	case 14:
		return tokentree_utils_BrOpenType.OBJECTDECL;
	case 18:
		var pOpenType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(token.parent);
		switch(pOpenType._hx_index) {
		case 0:
			return tokentree_utils_BrOpenType.OBJECTDECL;
		case 1:
			return tokentree_utils_BrOpenType.ANONTYPE;
		case 2:
			return tokentree_utils_BrOpenType.OBJECTDECL;
		case 3:
			return tokentree_utils_BrOpenType.UNKNOWN;
		case 4:
			return tokentree_utils_BrOpenType.UNKNOWN;
		case 5:
			return tokentree_utils_BrOpenType.OBJECTDECL;
		}
		break;
	case 20:
		if(tokentree_utils_TokenTreeCheckUtils.isTernary(token.parent)) {
			return tokentree_utils_BrOpenType.OBJECTDECL;
		}
		break;
	default:
	}
	return tokentree_utils_TokenTreeCheckUtils.determinBrChildren(token);
};
tokentree_utils_TokenTreeCheckUtils.determinBrChildren = function(token) {
	if(token.children == null || token.children.length <= 0) {
		var _g = token.parent.tok;
		if(_g._hx_index == 0) {
			var _g1 = _g.k;
			return tokentree_utils_BrOpenType.BLOCK;
		} else {
			return tokentree_utils_BrOpenType.OBJECTDECL;
		}
	}
	if(token.parent != null && token.parent.tok != null) {
		if(token.children.length == 1) {
			var _g2 = token.parent.tok;
			if(_g2._hx_index == 0) {
				var _g11 = _g2.k;
				return tokentree_utils_BrOpenType.BLOCK;
			} else {
				return tokentree_utils_BrOpenType.OBJECTDECL;
			}
		}
		if(token.children.length == 2 && token.getLastChild().is(haxeparser_TokenDef.Semicolon)) {
			var _g3 = token.parent.tok;
			if(_g3._hx_index == 0) {
				var _g12 = _g3.k;
				return tokentree_utils_BrOpenType.BLOCK;
			} else {
				return tokentree_utils_BrOpenType.OBJECTDECL;
			}
		}
	}
	if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Arrow) != null) {
		return tokentree_utils_BrOpenType.ANONTYPE;
	}
	if(token.nextSibling != null && token.nextSibling.is(haxeparser_TokenDef.Arrow)) {
		return tokentree_utils_BrOpenType.ANONTYPE;
	}
	var onlyComment = true;
	var _g4 = 0;
	var _g13 = token.children;
	while(_g4 < _g13.length) {
		var child = _g13[_g4];
		++_g4;
		var _g5 = child.tok;
		switch(_g5._hx_index) {
		case 1:
			var _g21 = _g5.c;
			switch(_g21._hx_index) {
			case 2:
				var _g41 = _g21.s;
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(child),haxeparser_TokenDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.BLOCK;
				}
				onlyComment = false;
				break;
			case 3:
				var _g31 = _g21.s;
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(child),haxeparser_TokenDef.DblDot) == null) {
					return tokentree_utils_BrOpenType.BLOCK;
				}
				onlyComment = false;
				break;
			default:
				return tokentree_utils_BrOpenType.BLOCK;
			}
			break;
		case 2:
			var _g14 = _g5.s;
			break;
		case 6:
			var _g6 = _g5.s;
			break;
		case 7:
			var _g51 = _g5.s;
			break;
		case 17:
			if(onlyComment) {
				if(token.parent != null && token.parent.tok != null) {
					var _g7 = token.parent.tok;
					if(_g7._hx_index == 0) {
						var _g15 = _g7.k;
						return tokentree_utils_BrOpenType.BLOCK;
					} else {
						return tokentree_utils_BrOpenType.OBJECTDECL;
					}
				} else {
					return tokentree_utils_BrOpenType.OBJECTDECL;
				}
			}
			return tokentree_utils_BrOpenType.OBJECTDECL;
		default:
			return tokentree_utils_BrOpenType.BLOCK;
		}
	}
	return tokentree_utils_BrOpenType.OBJECTDECL;
};
tokentree_utils_TokenTreeCheckUtils.getPOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_POpenType.EXPRESSION;
	}
	if(token.tokenTypeCache.pOpenType != null) {
		return token.tokenTypeCache.pOpenType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determinePOpenType(token);
	token.tokenTypeCache.pOpenType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determinePOpenType = function(token) {
	if(token == null) {
		return tokentree_utils_POpenType.EXPRESSION;
	}
	var parent = token.parent;
	if(parent == null || parent.tok == null) {
		return tokentree_utils_POpenType.EXPRESSION;
	}
	if(tokentree_utils_TokenTreeCheckUtils.hasAtParent(token)) {
		return tokentree_utils_POpenType.AT;
	}
	var lastChild = token.getLastChild();
	if(lastChild != null) {
		if(lastChild.tok._hx_index == 12) {
			return tokentree_utils_POpenType.PARAMETER;
		}
	}
	var _g = parent.tok;
	if(_g._hx_index == 5) {
		if(_g.op._hx_index == 9) {
			parent = parent.parent;
		}
	}
	var _g2 = parent.tok;
	switch(_g2._hx_index) {
	case 0:
		switch(_g2.k._hx_index) {
		case 0:
			return tokentree_utils_POpenType.PARAMETER;
		case 3:
			var firstChild = parent.getFirstChild();
			if(firstChild == null) {
				return tokentree_utils_POpenType.CONDITION;
			}
			if(firstChild.index == token.index) {
				return tokentree_utils_POpenType.CONDITION;
			}
			return tokentree_utils_POpenType.EXPRESSION;
		case 5:
			return tokentree_utils_POpenType.CONDITION;
		case 7:
			return tokentree_utils_POpenType.FORLOOP;
		case 21:
			return tokentree_utils_POpenType.CONDITION;
		case 22:
			return tokentree_utils_POpenType.PARAMETER;
		default:
		}
		break;
	case 1:
		var _g5 = _g2.c;
		if(_g5._hx_index == 3) {
			var _g6 = _g5.s;
			if(parent.parent == null || parent.parent.tok == null) {
				return tokentree_utils_POpenType.CALL;
			}
			var _g21 = parent.parent.tok;
			switch(_g21._hx_index) {
			case 0:
				switch(_g21.k._hx_index) {
				case 0:
					if(parent.previousSibling == null) {
						return tokentree_utils_POpenType.PARAMETER;
					}
					return tokentree_utils_POpenType.CALL;
				case 39:
					return tokentree_utils_POpenType.PARAMETER;
				default:
					return tokentree_utils_POpenType.CALL;
				}
				break;
			case 16:
				if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.parent(parent.parent)),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdEnum)) != null) {
					return tokentree_utils_POpenType.PARAMETER;
				}
				return tokentree_utils_POpenType.CALL;
			default:
				return tokentree_utils_POpenType.CALL;
			}
		}
		break;
	case 2:
		switch(_g2.s) {
		case "elseif":case "if":
			if(parent.getFirstChild() == token) {
				return tokentree_utils_POpenType.CONDITION;
			}
			return tokentree_utils_POpenType.EXPRESSION;
		default:
			return tokentree_utils_POpenType.EXPRESSION;
		}
		break;
	case 18:
		return tokentree_utils_POpenType.EXPRESSION;
	default:
	}
	if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(token,haxeparser_TokenDef.Arrow) != null) {
		return tokentree_utils_POpenType.PARAMETER;
	}
	return tokentree_utils_POpenType.EXPRESSION;
};
tokentree_utils_TokenTreeCheckUtils.hasAtParent = function(token) {
	var parent = token.parent;
	while(parent.tok != null) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.c;
			break;
		case 10:
			break;
		case 11:
			break;
		case 21:
			return true;
		default:
			return false;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isInsideTypedef = function(token) {
	if(token == null) {
		return false;
	}
	var parent = token;
	while(parent.parent != null) {
		if(parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTypedef))) {
			return true;
		}
		parent = parent.parent;
	}
	return false;
};
tokentree_utils_TokenTreeCheckUtils.isDeprecated = function(declToken) {
	return Lambda.exists(tokentree_utils_TokenTreeCheckUtils.getMetadata(declToken),function(meta) {
		var _g = meta.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				if(_g1.s == "deprecated") {
					return true;
				} else {
					return false;
				}
			} else {
				return false;
			}
		} else {
			return false;
		}
	});
};
tokentree_utils_TokenTreeCheckUtils.getArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ARROW_FUNCTION;
	}
	if(token.tokenTypeCache.arrowType != null) {
		return token.tokenTypeCache.arrowType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineArrowType(token);
	token.tokenTypeCache.arrowType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineArrowType = function(token) {
	if(token == null) {
		return tokentree_utils_ArrowType.ARROW_FUNCTION;
	}
	var child = token.getFirstChild();
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 0:
			if(_g.k._hx_index != 40) {
				return tokentree_utils_ArrowType.ARROW_FUNCTION;
			}
			break;
		case 1:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
			} else {
				return tokentree_utils_ArrowType.ARROW_FUNCTION;
			}
			break;
		case 5:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.ARROW_FUNCTION;
			}
			break;
		case 6:
			var _g6 = _g.s;
			break;
		case 7:
			var _g5 = _g.s;
			break;
		case 9:case 10:case 12:case 20:
			break;
		case 16:
			var brClose = child.getFirstChild();
			if(brClose.is(haxeparser_TokenDef.BrClose)) {
				return tokentree_utils_ArrowType.ARROW_FUNCTION;
			}
			var brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(child);
			switch(brType._hx_index) {
			case 0:
				return tokentree_utils_ArrowType.ARROW_FUNCTION;
			case 3:
				break;
			default:
			}
			child = child.nextSibling;
			continue;
		case 18:
			break;
		default:
			return tokentree_utils_ArrowType.ARROW_FUNCTION;
		}
		child = child.getFirstChild();
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ArrowType.ARROW_FUNCTION;
	}
	var resultType = tokentree_utils_TokenTreeCheckUtils.checkArrowParent(parent);
	if(resultType != null) {
		return resultType;
	}
	return tokentree_utils_TokenTreeCheckUtils.checkArrowChildren(parent);
};
tokentree_utils_TokenTreeCheckUtils.checkArrowChildren = function(parent) {
	var child = parent.getFirstChild();
	if(child == null) {
		return tokentree_utils_ArrowType.ARROW_FUNCTION;
	}
	var seenArrow = false;
	while(child != null) {
		var _g = child.tok;
		switch(_g._hx_index) {
		case 0:
			var _g4 = _g.k;
			return tokentree_utils_ArrowType.ARROW_FUNCTION;
		case 1:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				var _g3 = _g2.s;
			} else {
				return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE4;
			}
			break;
		case 5:
			if(_g.op._hx_index == 9) {
				child = child.nextSibling;
				continue;
			} else {
				return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE4;
			}
			break;
		case 6:
			var _g6 = _g.s;
			break;
		case 7:
			var _g5 = _g.s;
			break;
		case 9:case 10:
			break;
		case 11:case 16:
			break;
		case 12:
			seenArrow = true;
			break;
		case 18:
			var result = tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen(child);
			if(result != null) {
				return result;
			}
			child = child.nextSibling;
			continue;
		case 19:
			break;
		case 20:
			break;
		default:
			return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE4;
		}
		child = child.getFirstChild();
	}
	if(seenArrow) {
		return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE3;
	}
	return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE4;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowPOpen = function(token) {
	if(token.children == null || token.children.length <= 1) {
		return null;
	}
	if(token.parent.isCIdent()) {
		return tokentree_utils_ArrowType.ARROW_FUNCTION;
	}
	var childArrows = token.filter([haxeparser_TokenDef.Arrow],tokentree_TokenFilterMode.ALL);
	if(childArrows.length <= 0) {
		return tokentree_utils_ArrowType.ARROW_FUNCTION;
	}
	var childArrows1 = token.filter([haxeparser_TokenDef.DblDot],tokentree_TokenFilterMode.ALL);
	if(childArrows1.length > 0) {
		return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE4;
	}
	return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE3;
};
tokentree_utils_TokenTreeCheckUtils.checkArrowParent = function(parent) {
	if(parent == null) {
		return tokentree_utils_ArrowType.ARROW_FUNCTION;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 1:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			if(parent.parent.is(haxeparser_TokenDef.POpen)) {
				switch(tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent.parent)._hx_index) {
				case 1:
					return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE3;
				case 5:
					return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE3;
				default:
					return tokentree_utils_ArrowType.ARROW_FUNCTION;
				}
			}
		} else {
			return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE3;
		}
		break;
	case 18:
		break;
	default:
		return tokentree_utils_ArrowType.FUNCTION_TYPE_HAXE3;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.getColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.UNKNOWN;
	}
	if(token.tokenTypeCache.colonType != null) {
		return token.tokenTypeCache.colonType;
	}
	var type = tokentree_utils_TokenTreeCheckUtils.determineColonType(token);
	token.tokenTypeCache.colonType = type;
	return type;
};
tokentree_utils_TokenTreeCheckUtils.determineColonType = function(token) {
	if(token == null) {
		return tokentree_utils_ColonType.UNKNOWN;
	}
	if(tokentree_utils_TokenTreeCheckUtils.isTernary(token)) {
		return tokentree_utils_ColonType.TERNARY;
	}
	var parent = token.parent;
	if(parent == null) {
		return tokentree_utils_ColonType.UNKNOWN;
	}
	var _g = parent.tok;
	switch(_g._hx_index) {
	case 0:
		switch(_g.k._hx_index) {
		case 0:
			return tokentree_utils_ColonType.TYPE_HINT;
		case 15:case 16:
			return tokentree_utils_ColonType.SWITCH_CASE;
		case 22:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		case 23:
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		default:
		}
		break;
	case 1:
		var _g3 = _g.c;
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 5:
		if(_g.op._hx_index == 9) {
			return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
		}
		break;
	case 16:
		var brClose = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(parent,haxeparser_TokenDef.BrClose);
		if(brClose == null) {
			return tokentree_utils_ColonType.UNKNOWN;
		}
		if(brClose.pos.max <= token.pos.min) {
			return tokentree_utils_ColonType.TYPE_CHECK;
		}
		break;
	case 18:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(token);
	case 20:
		return tokentree_utils_TokenTreeCheckUtils.findColonParent(parent);
	case 21:
		return tokentree_utils_ColonType.AT;
	default:
	}
	return tokentree_utils_ColonType.UNKNOWN;
};
tokentree_utils_TokenTreeCheckUtils.findColonParent = function(token) {
	var parent = token;
	while(parent.tok != null) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:case 2:
				return tokentree_utils_ColonType.TYPE_HINT;
			case 41:
				return tokentree_utils_ColonType.TYPE_HINT;
			default:
			}
			break;
		case 1:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				if(_g2.s == "final") {
					return tokentree_utils_ColonType.TYPE_HINT;
				}
			}
			break;
		case 16:
			var brType = tokentree_utils_TokenTreeCheckUtils.getBrOpenType(parent);
			switch(brType._hx_index) {
			case 0:
				return tokentree_utils_ColonType.UNKNOWN;
			case 1:
				return tokentree_utils_ColonType.TYPE_HINT;
			case 2:
				return tokentree_utils_ColonType.OBJECT_LITERAL;
			case 3:
				return tokentree_utils_ColonType.TYPE_HINT;
			case 4:
				return tokentree_utils_ColonType.UNKNOWN;
			}
			break;
		case 18:
			var pClose = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(parent,haxeparser_TokenDef.PClose);
			if(pClose != null && pClose.pos.max <= token.pos.min) {
				return tokentree_utils_ColonType.TYPE_CHECK;
			}
			var pType = tokentree_utils_TokenTreeCheckUtils.getPOpenType(parent);
			switch(pType._hx_index) {
			case 0:
				return tokentree_utils_ColonType.OBJECT_LITERAL;
			case 1:
				return tokentree_utils_ColonType.TYPE_HINT;
			case 2:
				return tokentree_utils_ColonType.UNKNOWN;
			case 3:
				return tokentree_utils_ColonType.UNKNOWN;
			case 4:
				return tokentree_utils_ColonType.TYPE_CHECK;
			case 5:
				return tokentree_utils_ColonType.TYPE_CHECK;
			}
			break;
		default:
		}
		parent = parent.parent;
	}
	return tokentree_utils_ColonType.UNKNOWN;
};
tokentree_utils_TokenTreeCheckUtils.getLastToken = function(token) {
	if(token == null) {
		return null;
	}
	if(token.children == null) {
		return token;
	}
	if(token.children.length <= 0) {
		return token;
	}
	var lastChild = token.getLastChild();
	while(lastChild != null) {
		var newLast = lastChild.getLastChild();
		if(newLast == null) {
			return lastChild;
		}
		lastChild = newLast;
	}
	return null;
};
tokentree_utils_TokenTreeCheckUtils.isMetadata = function(token) {
	if(token == null || token.tok == null) {
		return false;
	}
	var parent = token.parent;
	while(parent != null && parent.tok != null) switch(parent.tok._hx_index) {
	case 11:
		parent = parent.parent;
		if(parent == null || parent.tok == null) {
			return false;
		}
		if(parent.tok._hx_index == 21) {
			return true;
		} else {
			return false;
		}
		break;
	case 21:
		return true;
	default:
		parent = parent.parent;
	}
	return false;
};
var tokentree_utils_BrOpenType = $hxEnums["tokentree.utils.BrOpenType"] = { __ename__ : true, __constructs__ : ["BLOCK","TYPEDEFDECL","OBJECTDECL","ANONTYPE","UNKNOWN"]
	,BLOCK: {_hx_index:0,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,TYPEDEFDECL: {_hx_index:1,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,OBJECTDECL: {_hx_index:2,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,ANONTYPE: {_hx_index:3,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
	,UNKNOWN: {_hx_index:4,__enum__:"tokentree.utils.BrOpenType",toString:$estr}
};
var tokentree_utils_POpenType = $hxEnums["tokentree.utils.POpenType"] = { __ename__ : true, __constructs__ : ["AT","PARAMETER","CALL","CONDITION","FORLOOP","EXPRESSION"]
	,AT: {_hx_index:0,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,PARAMETER: {_hx_index:1,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,CALL: {_hx_index:2,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,CONDITION: {_hx_index:3,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,FORLOOP: {_hx_index:4,__enum__:"tokentree.utils.POpenType",toString:$estr}
	,EXPRESSION: {_hx_index:5,__enum__:"tokentree.utils.POpenType",toString:$estr}
};
var tokentree_utils_ArrowType = $hxEnums["tokentree.utils.ArrowType"] = { __ename__ : true, __constructs__ : ["ARROW_FUNCTION","FUNCTION_TYPE_HAXE3","FUNCTION_TYPE_HAXE4"]
	,ARROW_FUNCTION: {_hx_index:0,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,FUNCTION_TYPE_HAXE3: {_hx_index:1,__enum__:"tokentree.utils.ArrowType",toString:$estr}
	,FUNCTION_TYPE_HAXE4: {_hx_index:2,__enum__:"tokentree.utils.ArrowType",toString:$estr}
};
var tokentree_utils_ColonType = $hxEnums["tokentree.utils.ColonType"] = { __ename__ : true, __constructs__ : ["SWITCH_CASE","TYPE_HINT","TYPE_CHECK","TERNARY","OBJECT_LITERAL","AT","UNKNOWN"]
	,SWITCH_CASE: {_hx_index:0,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TYPE_HINT: {_hx_index:1,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TYPE_CHECK: {_hx_index:2,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,TERNARY: {_hx_index:3,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,OBJECT_LITERAL: {_hx_index:4,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,AT: {_hx_index:5,__enum__:"tokentree.utils.ColonType",toString:$estr}
	,UNKNOWN: {_hx_index:6,__enum__:"tokentree.utils.ColonType",toString:$estr}
};
var tokentree_walk_WalkAbstract = function() { };
tokentree_walk_WalkAbstract.__name__ = true;
tokentree_walk_WalkAbstract.walkAbstract = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	if(stream.is(haxeparser_TokenDef.POpen)) {
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
	}
	var typeParent = name;
	var typeChild;
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 1:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				switch(_g1.s) {
				case "from":case "to":
					var fromToken = stream.consumeToken();
					name.addChild(fromToken);
					tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,fromToken);
					break;
				default:
					typeChild = stream.consumeToken();
					typeParent.addChild(typeChild);
					typeParent = typeChild;
				}
			} else {
				typeChild = stream.consumeToken();
				typeParent.addChild(typeChild);
				typeParent = typeChild;
			}
			break;
		case 6:
			var _g4 = _g.s;
			name.addChild(stream.consumeToken());
			break;
		case 7:
			var _g3 = _g.s;
			name.addChild(stream.consumeToken());
			break;
		case 16:
			break _hx_loop1;
		default:
			typeChild = stream.consumeToken();
			typeParent.addChild(typeChild);
			typeParent = typeChild;
		}
	}
	var block = stream.consumeTokenDef(haxeparser_TokenDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkAbstract.walkAbstractBody(stream,block);
	block.addChild(stream.consumeTokenDef(haxeparser_TokenDef.BrClose));
};
tokentree_walk_WalkAbstract.walkAbstractBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 1:
			var _g3 = _g.c;
			if(_g3._hx_index == 3) {
				if(_g3.s == "final") {
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
				} else {
					stream.consumeToTempStore();
				}
			} else {
				stream.consumeToTempStore();
			}
			break;
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkAbstract.walkAbstractBody);
			break;
		case 6:
			var _g6 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 7:
			var _g5 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 9:
			parent.addChild(stream.consumeToken());
			break;
		case 17:
			break _hx_loop1;
		case 21:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkArrayAccess = function() { };
tokentree_walk_WalkArrayAccess.__name__ = true;
tokentree_walk_WalkArrayAccess.walkArrayAccess = function(stream,parent) {
	var bkOpen = stream.consumeTokenDef(haxeparser_TokenDef.BkOpen);
	parent.addChild(bkOpen);
	stream.applyTempStore(bkOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,bkOpen);
				break;
			case 5:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkWhile.walkWhile(stream,bkOpen);
				break;
			case 7:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkFor.walkFor(stream,bkOpen);
				break;
			default:
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 5:
			if(_g.op._hx_index == 22) {
				var child = bkOpen.getLastChild();
				if(child == null) {
					child = bkOpen;
				}
				tokentree_walk_WalkStatement.walkStatement(stream,child);
			} else {
				stream.applyTempStore(bkOpen);
				tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
			}
			break;
		case 13:
			var comma = stream.consumeToken();
			var child1 = bkOpen.getLastChild();
			if(child1 == null) {
				child1 = bkOpen;
			}
			child1.addChild(comma);
			break;
		case 14:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,bkOpen);
			break;
		case 15:
			break _hx_loop1;
		case 16:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkBlock.walkBlock(stream,bkOpen);
			break;
		case 18:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkPOpen.walkPOpen(stream,bkOpen);
			break;
		case 21:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.applyTempStore(bkOpen);
			tokentree_walk_WalkStatement.walkStatement(stream,bkOpen);
		}
	}
	bkOpen.addChild(stream.consumeTokenDef(haxeparser_TokenDef.BkClose));
};
var tokentree_walk_WalkAt = function() { };
tokentree_walk_WalkAt.__name__ = true;
tokentree_walk_WalkAt.walkAt = function(stream) {
	var atTok = stream.consumeTokenDef(haxeparser_TokenDef.At);
	var parent = atTok;
	if(stream.is(haxeparser_TokenDef.DblDot)) {
		var dblDot = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
		atTok.addChild(dblDot);
		parent = dblDot;
	}
	tokentree_walk_WalkAt.walkIdent(stream,parent);
	return atTok;
};
tokentree_walk_WalkAt.walkIdent = function(stream,parent) {
	var ident;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 0:
		var _g3 = _g.k;
		ident = stream.consumeToken();
		break;
	case 1:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			ident = stream.consumeConstIdent();
		} else {
			return;
		}
		break;
	default:
		return;
	}
	parent.addChild(ident);
	switch(stream.token()._hx_index) {
	case 10:
		var child = stream.consumeToken();
		ident.addChild(child);
		tokentree_walk_WalkAt.walkIdent(stream,child);
		break;
	case 18:
		var pOpenPos = stream.getTokenPos();
		if(ident.pos.max == pOpenPos.min) {
			var tempStore = stream.getTempStore();
			stream.clearTempStore();
			tokentree_walk_WalkPOpen.walkPOpen(stream,ident);
			var _g4 = 0;
			while(_g4 < tempStore.length) {
				var temp = tempStore[_g4];
				++_g4;
				stream.addToTempStore(temp);
			}
		}
		break;
	default:
	}
};
tokentree_walk_WalkAt.walkAts = function(stream) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) if(stream.token()._hx_index == 21) {
		stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	}
};
var tokentree_walk_WalkBinopSub = function() { };
tokentree_walk_WalkBinopSub.__name__ = true;
tokentree_walk_WalkBinopSub.walkBinopSub = function(stream,parent) {
	var sub = stream.consumeOpSub();
	parent.addChild(sub);
	var _g = sub.tok;
	if(_g._hx_index == 1) {
		var _g1 = _g.c;
		tokentree_walk_WalkStatement.walkStatementContinue(stream,sub);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,sub);
	}
};
var tokentree_walk_WalkBlock = function() { };
tokentree_walk_WalkBlock.__name__ = true;
tokentree_walk_WalkBlock.walkBlock = function(stream,parent) {
	while(stream.is(haxeparser_TokenDef.At)) stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
	if(stream.is(haxeparser_TokenDef.BrOpen)) {
		var openTok = stream.consumeTokenDef(haxeparser_TokenDef.BrOpen);
		parent.addChild(openTok);
		stream.applyTempStore(openTok);
		tokentree_walk_WalkBlock.walkBlockContinue(stream,openTok);
	} else {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkBlock.walkBlockContinue = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkSwitchCases(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 13:
			var child = stream.consumeToken();
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				parent.addChild(child);
			} else {
				lastChild.addChild(child);
			}
			break;
		case 15:case 19:
			var child1 = stream.consumeToken();
			parent.addChild(child1);
			break;
		case 17:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
	tokentree_walk_WalkBlock.walkBlockEnd(stream,parent);
};
tokentree_walk_WalkBlock.walkBlockEnd = function(stream,parent) {
	parent.addChild(stream.consumeTokenDef(haxeparser_TokenDef.BrClose));
	if(stream.hasMore()) {
		var _g = stream.token();
		if(_g._hx_index == 5) {
			if(_g.op._hx_index == 7) {
				return;
			}
		}
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
		if(stream.hasMore()) {
			if(stream.token()._hx_index == 9) {
				var semicolon = stream.consumeToken();
				parent.addChild(semicolon);
			}
		}
	}
};
var tokentree_walk_WalkClass = function() { };
tokentree_walk_WalkClass.__name__ = true;
tokentree_walk_WalkClass.walkClass = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var name = typeTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 1:
		var _g1 = _g.c;
		if(_g1._hx_index == 3) {
			var _g2 = _g1.s;
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
			stream.applyTempStore(name);
		}
		break;
	case 3:
		var _g3 = _g.s;
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
		stream.applyTempStore(name);
		break;
	default:
	}
	tokentree_walk_WalkClass.walkClassExtends(stream,name);
	var block = stream.consumeTokenDef(haxeparser_TokenDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkClass.walkClassBody(stream,block);
	block.addChild(stream.consumeTokenDef(haxeparser_TokenDef.BrClose));
};
tokentree_walk_WalkClass.walkClassExtends = function(stream,name) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkExtends.walkExtends(stream,name);
		tokentree_walk_WalkImplements.walkImplements(stream,name);
		if(stream.isSharp()) {
			tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkClass.walkClassExtends);
		}
		tokentree_walk_WalkComment.walkComment(stream,name);
	}
};
tokentree_walk_WalkClass.walkClassBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,parent);
				break;
			default:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw new js__$Boot_HaxeError("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
				case 1:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
					break;
				}
			}
			break;
		case 1:
			var _g3 = _g.c;
			if(_g3._hx_index == 3) {
				if(_g3.s == "final") {
					tokentree_walk_WalkFinal.walkFinal(stream,parent);
				} else {
					switch(tokentree_TokenStream.MODE._hx_index) {
					case 0:
						throw new js__$Boot_HaxeError("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
					case 1:
						tokentree_walk_WalkStatement.walkStatement(stream,parent);
						break;
					}
				}
			} else {
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw new js__$Boot_HaxeError("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
				case 1:
					tokentree_walk_WalkStatement.walkStatement(stream,parent);
					break;
				}
			}
			break;
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkClass.walkClassBody);
			tokentree_walk_WalkClass.walkClassContinueAfterSharp(stream,parent);
			break;
		case 6:
			var _g6 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 7:
			var _g5 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 9:
			parent.addChild(stream.consumeToken());
			break;
		case 17:
			break _hx_loop1;
		case 21:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("invalid token tree structure - found:" + ("" + Std.string(stream.token())));
			case 1:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
				break;
			}
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw new js__$Boot_HaxeError("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(parent);
			break;
		}
	}
};
tokentree_walk_WalkClass.walkClassContinueAfterSharp = function(stream,parent) {
	var brOpen = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstChild(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastOf(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastChild(parent),haxeparser_TokenDef.Sharp("if")),haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFunction)))),haxeparser_TokenDef.BrOpen);
	if(brOpen == null) {
		return;
	}
	if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.is(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.lastChild(brOpen),haxeparser_TokenDef.BrClose) != null) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlockContinue(stream,parent);
};
var tokentree_walk_WalkComment = function() { };
tokentree_walk_WalkComment.__name__ = true;
tokentree_walk_WalkComment.walkComment = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 6:
			var _g2 = _g.s;
			var comment = stream.consumeToken();
			parent.addChild(comment);
			break;
		case 7:
			var _g1 = _g.s;
			var comment1 = stream.consumeToken();
			parent.addChild(comment1);
			break;
		default:
			return;
		}
	}
};
tokentree_walk_WalkComment.tryWalkComment = function(stream,parent,expect) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 6:
			var _g2 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 7:
			var _g1 = _g.s;
			comments.push(stream.consumeToken());
			break;
		default:
			if(stream.is(expect)) {
				var _g3 = 0;
				while(_g3 < comments.length) {
					var comment = comments[_g3];
					++_g3;
					parent.addChild(comment);
				}
				return;
			}
			stream.rewindTo(currentPos);
			return;
		}
	}
};
var tokentree_walk_WalkDoWhile = function() { };
tokentree_walk_WalkDoWhile.__name__ = true;
tokentree_walk_WalkDoWhile.walkDoWhile = function(stream,parent) {
	var doTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDo));
	parent.addChild(doTok);
	tokentree_walk_WalkComment.walkComment(stream,doTok);
	tokentree_walk_WalkBlock.walkBlock(stream,doTok);
	var whileTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdWhile));
	doTok.addChild(whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	if(stream.is(haxeparser_TokenDef.Semicolon)) {
		whileTok.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkEnum = function() { };
tokentree_walk_WalkEnum.__name__ = true;
tokentree_walk_WalkEnum.walkEnum = function(stream,parent) {
	var typeTok = stream.consumeToken();
	if(stream.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdAbstract))) {
		stream.addToTempStore(typeTok);
		tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
		return;
	}
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
var tokentree_walk_WalkExtends = function() { };
tokentree_walk_WalkExtends.__name__ = true;
tokentree_walk_WalkExtends.walkExtends = function(stream,parent) {
	if(!stream.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdExtends))) {
		return;
	}
	var parentType = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdExtends));
	parent.addChild(parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkExtends.walkExtends(stream,parentType);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkFieldDef = function() { };
tokentree_walk_WalkFieldDef.__name__ = true;
tokentree_walk_WalkFieldDef.walkFieldDef = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:case 2:
				var tok = stream.consumeToken();
				parent.addChild(tok);
				parent = tok;
				break;
			case 41:
				var tok1 = stream.consumeToken();
				parent.addChild(tok1);
				parent = tok1;
				break;
			default:
				break _hx_loop1;
			}
			break;
		case 1:
			var _g2 = _g.c;
			if(_g2._hx_index == 3) {
				if(_g2.s == "final") {
					var tok2 = stream.consumeToken();
					parent.addChild(tok2);
					parent = tok2;
				} else {
					break _hx_loop1;
				}
			} else {
				break _hx_loop1;
			}
			break;
		case 6:
			var _g5 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 7:
			var _g4 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 21:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			break _hx_loop1;
		}
	}
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	stream.applyTempStore(name);
	if(stream.is(haxeparser_TokenDef.DblDot)) {
		var dblDot = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
		name.addChild(dblDot);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,dblDot);
	}
	if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign))) {
		tokentree_walk_WalkStatement.walkStatement(stream,name);
	}
	switch(stream.token()._hx_index) {
	case 9:
		name.addChild(stream.consumeTokenDef(haxeparser_TokenDef.Semicolon));
		break;
	case 13:
		name.addChild(stream.consumeTokenDef(haxeparser_TokenDef.Comma));
		break;
	default:
	}
};
var tokentree_walk_WalkFile = function() { };
tokentree_walk_WalkFile.__name__ = true;
tokentree_walk_WalkFile.walkFile = function(stream,parent) {
	while(stream.hasMore()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 13:case 33:case 35:
				stream.applyTempStore(parent);
				tokentree_walk_WalkPackageImport.walkPackageImport(stream,parent);
				break;
			case 18:case 19:case 25:
				stream.consumeToTempStore();
				break;
			case 1:case 26:case 27:case 31:case 39:
				tokentree_walk_WalkType.walkType(stream,parent);
				break;
			case 41:
				stream.consumeToTempStore();
				break;
			default:
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
			}
			break;
		case 1:
			var _g3 = _g.c;
			if(_g3._hx_index == 2) {
				if(_g3.s == "final") {
					stream.consumeToTempStore();
				} else {
					tokentree_walk_WalkBlock.walkBlock(stream,parent);
				}
			} else {
				tokentree_walk_WalkBlock.walkBlock(stream,parent);
			}
			break;
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkFile.walkFile);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index == 16) {
				tokentree_walk_WalkBlock.walkBlock(stream,parent.children[parent.children.length - 1]);
			}
			break;
		case 6:
			var _g6 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 7:
			var _g5 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 9:case 13:case 15:case 17:case 19:
			parent.addChild(stream.consumeToken());
			break;
		case 21:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
		}
	}
	var tempStore = stream.getTempStore();
	var _g2 = 0;
	while(_g2 < tempStore.length) {
		var stored = tempStore[_g2];
		++_g2;
		var _g4 = stored.tok;
		switch(_g4._hx_index) {
		case 0:
			switch(_g4.k._hx_index) {
			case 18:case 19:case 25:
				switch(tokentree_TokenStream.MODE._hx_index) {
				case 0:
					throw new js__$Boot_HaxeError("invalid token tree structure - found:" + Std.string(stored));
				case 1:
					parent.addChild(stored);
					break;
				}
				break;
			default:
				parent.addChild(stored);
			}
			break;
		case 21:
			switch(tokentree_TokenStream.MODE._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError("invalid token tree structure - found:" + Std.string(stored));
			case 1:
				parent.addChild(stored);
				break;
			}
			break;
		default:
			parent.addChild(stored);
		}
	}
};
var tokentree_walk_WalkFinal = function() { };
tokentree_walk_WalkFinal.__name__ = true;
tokentree_walk_WalkFinal.walkFinal = function(stream,parent) {
	var name = null;
	var finalTok = stream.consumeToken();
	stream.addToTempStore(finalTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				return;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			default:
			}
			break;
		case 1:
			var _g1 = _g.c;
			if(_g1._hx_index == 3) {
				var _g2 = _g1.s;
				name = stream.consumeToken();
				break _hx_loop1;
			}
			break;
		case 6:
			var _g5 = _g.s;
			stream.consumeToTempStore();
			break;
		case 7:
			var _g4 = _g.s;
			stream.consumeToTempStore();
			break;
		case 20:
			var nameParent = stream.consumeToken();
			name = stream.consumeConstIdent();
			nameParent.addChild(name);
			name = nameParent;
			break _hx_loop1;
		default:
		}
	}
	parent.addChild(finalTok);
	var tempStore = stream.getTempStore();
	var _g3 = 0;
	while(_g3 < tempStore.length) {
		var stored = tempStore[_g3];
		++_g3;
		var _g6 = stored.tok;
		switch(_g6._hx_index) {
		case 0:
			if(_g6.k._hx_index != 41) {
				name.addChild(stored);
			}
			break;
		case 1:
			var _g11 = _g6.c;
			if(_g11._hx_index == 3) {
				if(_g11.s != "final") {
					name.addChild(stored);
				}
			} else {
				name.addChild(stored);
			}
			break;
		default:
			name.addChild(stored);
		}
	}
	stream.clearTempStore();
	finalTok.addChild(name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	if(stream.is(haxeparser_TokenDef.DblDot)) {
		var dblDot = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
		name.addChild(dblDot);
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
	}
	if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign))) {
		tokentree_walk_WalkStatement.walkStatement(stream,name);
	}
	if(stream.is(haxeparser_TokenDef.Semicolon)) {
		name.addChild(stream.consumeTokenDef(haxeparser_TokenDef.Semicolon));
	}
};
var tokentree_walk_WalkFor = function() { };
tokentree_walk_WalkFor.__name__ = true;
tokentree_walk_WalkFor.walkFor = function(stream,parent) {
	var forTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFor));
	parent.addChild(forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkFor.walkForPOpen(stream,forTok);
	tokentree_walk_WalkComment.walkComment(stream,forTok);
	tokentree_walk_WalkBlock.walkBlock(stream,forTok);
};
tokentree_walk_WalkFor.walkForPOpen = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(haxeparser_TokenDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkComment.walkComment(stream,pOpen);
	var identifier = null;
	var _g = stream.token();
	if(_g._hx_index == 3) {
		var _g1 = _g.s;
		tokentree_walk_WalkStatement.walkStatement(stream,pOpen);
		identifier = pOpen.getLastChild();
	} else {
		identifier = stream.consumeConstIdent();
		pOpen.addChild(identifier);
	}
	tokentree_walk_WalkComment.walkComment(stream,identifier);
	if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpArrow))) {
		var arrowTok = stream.consumeToken();
		identifier.addChild(arrowTok);
		var valueIdent = stream.consumeConstIdent();
		arrowTok.addChild(valueIdent);
	}
	var inTok = null;
	var _g2 = stream.token();
	switch(_g2._hx_index) {
	case 5:
		if(_g2.op._hx_index == 23) {
			inTok = stream.consumeToken();
			identifier.addChild(inTok);
			tokentree_walk_WalkComment.walkComment(stream,inTok);
			tokentree_walk_WalkStatement.walkStatement(stream,inTok);
			tokentree_walk_WalkComment.walkComment(stream,pOpen);
			pOpen.addChild(stream.consumeTokenDef(haxeparser_TokenDef.PClose));
			tokentree_walk_WalkComment.walkComment(stream,parent);
		}
		break;
	case 19:
		pOpen.addChild(stream.consumeTokenDef(haxeparser_TokenDef.PClose));
		tokentree_walk_WalkComment.walkComment(stream,parent);
		return;
	default:
	}
};
var tokentree_walk_WalkFunction = function() { };
tokentree_walk_WalkFunction.__name__ = true;
tokentree_walk_WalkFunction.walkFunction = function(stream,parent) {
	var funcTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdFunction));
	parent.addChild(funcTok);
	tokentree_walk_WalkComment.walkComment(stream,funcTok);
	var name = funcTok;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 0:
		if(_g.k._hx_index == 22) {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 5:
		if(_g.op._hx_index == 9) {
			tokentree_walk_WalkLtGt.walkLtGt(stream,funcTok);
			name = funcTok.getLastChild();
		} else {
			name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
		}
		break;
	case 18:
		break;
	default:
		name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,funcTok);
	}
	stream.applyTempStore(name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	tokentree_walk_WalkFunction.walkFunctionParameters(stream,name);
	tokentree_walk_WalkComment.walkComment(stream,name);
	if(stream.is(haxeparser_TokenDef.DblDot)) {
		var dblDot = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
		name.addChild(dblDot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDot);
	}
	tokentree_walk_WalkBlock.walkBlock(stream,name);
};
tokentree_walk_WalkFunction.walkFunctionParameters = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(haxeparser_TokenDef.POpen);
	parent.addChild(pOpen);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkComment.walkComment(stream,pOpen);
		if(stream.is(haxeparser_TokenDef.PClose)) {
			break;
		}
		tokentree_walk_WalkFieldDef.walkFieldDef(stream,pOpen);
	}
	pOpen.addChild(stream.consumeTokenDef(haxeparser_TokenDef.PClose));
};
var tokentree_walk_WalkIf = function() { };
tokentree_walk_WalkIf.__name__ = true;
tokentree_walk_WalkIf.walkIf = function(stream,parent) {
	var ifTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdIf));
	parent.addChild(ifTok);
	tokentree_walk_WalkStatement.walkStatement(stream,ifTok);
	if(stream.is(haxeparser_TokenDef.DblDot)) {
		return;
	}
	tokentree_walk_WalkBlock.walkBlock(stream,ifTok);
	tokentree_walk_WalkComment.tryWalkComment(stream,ifTok,haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse));
	if(stream.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse))) {
		var elseTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse));
		ifTok.addChild(elseTok);
		tokentree_walk_WalkBlock.walkBlock(stream,elseTok);
	}
};
var tokentree_walk_WalkImplements = function() { };
tokentree_walk_WalkImplements.__name__ = true;
tokentree_walk_WalkImplements.walkImplements = function(stream,parent) {
	if(!stream.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdImplements))) {
		return;
	}
	var interfacePart = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdImplements));
	parent.addChild(interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,interfacePart);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkImplements.walkImplements(stream,parent);
	tokentree_walk_WalkComment.walkComment(stream,parent);
};
var tokentree_walk_WalkInterface = function() { };
tokentree_walk_WalkInterface.__name__ = true;
tokentree_walk_WalkInterface.walkInterface = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	tokentree_walk_WalkInterface.walkInterfaceExtends(stream,name);
	var block = stream.consumeTokenDef(haxeparser_TokenDef.BrOpen);
	name.addChild(block);
	tokentree_walk_WalkInterface.walkInterfaceBody(stream,block);
	block.addChild(stream.consumeTokenDef(haxeparser_TokenDef.BrClose));
};
tokentree_walk_WalkInterface.walkInterfaceExtends = function(stream,name) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		tokentree_walk_WalkExtends.walkExtends(stream,name);
		tokentree_walk_WalkImplements.walkImplements(stream,name);
		if(stream.isSharp()) {
			tokentree_walk_WalkSharp.walkSharp(stream,name,tokentree_walk_WalkClass.walkClassExtends);
		}
		tokentree_walk_WalkComment.walkComment(stream,name);
	}
};
tokentree_walk_WalkInterface.walkInterfaceBody = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,parent);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,parent);
				break;
			default:
				stream.consumeToTempStore();
			}
			break;
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkInterface.walkInterfaceBody);
			break;
		case 6:
			var _g4 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 7:
			var _g3 = _g.s;
			parent.addChild(stream.consumeToken());
			break;
		case 9:
			parent.addChild(stream.consumeToken());
			break;
		case 17:
			break _hx_loop1;
		case 21:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			stream.consumeToTempStore();
		}
	}
	stream.applyTempStore(parent);
};
var tokentree_walk_WalkLtGt = function() { };
tokentree_walk_WalkLtGt.__name__ = true;
tokentree_walk_WalkLtGt.walkLtGt = function(stream,parent) {
	var ltTok = stream.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
	parent.addChild(ltTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 5:
			if(_g.op._hx_index == 7) {
				break _hx_loop1;
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			}
			break;
		case 11:
			var dblDot = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
			ltTok.addChild(dblDot);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			break;
		case 13:
			var comma = stream.consumeTokenDef(haxeparser_TokenDef.Comma);
			ltTok.addChild(comma);
			tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,ltTok);
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,ltTok);
		}
	}
	ltTok.addChild(stream.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt)));
};
var tokentree_walk_WalkNew = function() { };
tokentree_walk_WalkNew.__name__ = true;
tokentree_walk_WalkNew.walkNew = function(stream,parent) {
	var newTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdNew));
	parent.addChild(newTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,newTok);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		if(_g._hx_index == 5) {
			if(_g.op._hx_index == 7) {
				var gt = stream.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
				name.addChild(gt);
			}
		}
	}
	var _g1 = stream.token();
	switch(_g1._hx_index) {
	case 2:
		var _g11 = _g1.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		break;
	case 18:
		tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		break;
	default:
	}
	if(stream.is(haxeparser_TokenDef.Dot)) {
		tokentree_walk_WalkStatement.walkStatement(stream,name);
	}
};
var tokentree_walk_WalkPOpen = function() { };
tokentree_walk_WalkPOpen.__name__ = true;
tokentree_walk_WalkPOpen.walkPOpen = function(stream,parent) {
	var pOpen = stream.consumeTokenDef(haxeparser_TokenDef.POpen);
	parent.addChild(pOpen);
	tokentree_walk_WalkPOpen.walkPOpenParts(stream,pOpen);
	pOpen.addChild(stream.consumeTokenDef(haxeparser_TokenDef.PClose));
	return pOpen;
};
tokentree_walk_WalkPOpen.walkPOpenParts = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPOpen.walkPOpenParts);
			break;
		case 13:
			var comma = stream.consumeToken();
			var child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		case 14:
			tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
			break;
		case 16:
			tokentree_walk_WalkBlock.walkBlock(stream,parent);
			break;
		case 19:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
var tokentree_walk_WalkPackageImport = function() { };
tokentree_walk_WalkPackageImport.__name__ = true;
tokentree_walk_WalkPackageImport.walkPackageImport = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkPackageImport.walkPackageImport);
			break;
		case 9:
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			return;
		default:
			var newChild1 = stream.consumeToken();
			parent.addChild(newChild1);
			parent = newChild1;
		}
	}
};
var tokentree_walk_WalkQuestion = function() { };
tokentree_walk_WalkQuestion.__name__ = true;
tokentree_walk_WalkQuestion.walkQuestion = function(stream,parent) {
	var ternary = tokentree_walk_WalkQuestion.isTernary(parent);
	var question = stream.consumeTokenDef(haxeparser_TokenDef.Question);
	parent.addChild(question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	if(!ternary) {
		tokentree_walk_WalkStatement.walkStatement(stream,question);
		return;
	}
	tokentree_walk_WalkStatement.walkStatement(stream,question);
	tokentree_walk_WalkComment.walkComment(stream,question);
	var dblDotTok = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
	question.addChild(dblDotTok);
	tokentree_walk_WalkStatement.walkStatement(stream,dblDotTok);
};
tokentree_walk_WalkQuestion.isTernary = function(parent) {
	var lastChild = parent.getLastChild();
	if(lastChild == null) {
		var _g = parent.tok;
		if(_g._hx_index == 1) {
			var _g1 = _g.c;
			return true;
		} else {
			return false;
		}
	} else {
		var _g2 = lastChild.tok;
		switch(_g2._hx_index) {
		case 0:
			switch(_g2.k._hx_index) {
			case 0:
				return true;
			case 22:
				return true;
			case 23:case 28:case 40:
				return true;
			case 29:
				return true;
			case 36:case 37:case 38:
				return true;
			default:
				return false;
			}
			break;
		case 1:
			var _g3 = _g2.c;
			return true;
		case 3:
			var _g5 = _g2.s;
			return true;
		case 4:
			var _g21 = _g2.op;
			return true;
		case 5:
			switch(_g2.op._hx_index) {
			case 0:case 3:
				return true;
			default:
				return false;
			}
			break;
		case 11:
			return true;
		case 14:
			return true;
		case 16:
			return true;
		case 18:
			return true;
		case 19:
			return true;
		default:
			return false;
		}
	}
};
var tokentree_walk_WalkSharp = function() { };
tokentree_walk_WalkSharp.__name__ = true;
tokentree_walk_WalkSharp.walkSharp = function(stream,parent,walker) {
	var _g = stream.token();
	if(_g._hx_index == 2) {
		switch(_g.s) {
		case "else":
			tokentree_walk_WalkSharp.walkSharpElse(stream,parent);
			break;
		case "elseif":
			tokentree_walk_WalkSharp.walkSharpElseIf(stream,parent);
			break;
		case "end":
			tokentree_walk_WalkSharp.walkSharpEnd(stream,parent);
			break;
		case "error":
			var errorToken = stream.consumeToken();
			parent.addChild(errorToken);
			var _g1 = stream.token();
			if(_g1._hx_index == 1) {
				var _g11 = _g1.c;
				if(_g11._hx_index == 2) {
					var _g2 = _g11.s;
					errorToken.addChild(stream.consumeToken());
				}
			}
			break;
		case "if":
			tokentree_walk_WalkSharp.walkSharpIf(stream,parent,walker);
			break;
		default:
			parent.addChild(stream.consumeToken());
		}
	}
};
tokentree_walk_WalkSharp.walkSharpIf = function(stream,parent,walker) {
	var ifToken = stream.consumeToken();
	parent.addChild(ifToken);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	stream.pushSharpIf(ifToken);
	var newParent = ifToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) try {
		walker(stream,newParent);
		switch(stream.token()._hx_index) {
		case 13:case 17:case 19:
			var newChild = stream.consumeToken();
			newParent.addChild(newChild);
			break;
		default:
		}
	} catch( e ) {
		haxe_CallStack.lastException = e;
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		if(((e1) instanceof tokentree_walk_SharpElseException)) {
			newParent = e1.token;
		} else if(((e1) instanceof tokentree_walk_SharpEndException)) {
			var e2 = e1;
			stream.popSharpIf();
			return;
		} else {
			throw e;
		}
	}
};
tokentree_walk_WalkSharp.walkSharpElse = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	throw new js__$Boot_HaxeError(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpElseIf = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var ifToken = stream.consumeToken();
	sharpIfParent.addChild(ifToken);
	stream.applyTempStore(sharpIfParent);
	tokentree_walk_WalkSharp.walkSharpIfExpr(stream,ifToken);
	throw new js__$Boot_HaxeError(new tokentree_walk_SharpElseException(ifToken));
};
tokentree_walk_WalkSharp.walkSharpEnd = function(stream,parent) {
	var sharpIfParent = stream.peekSharpIf();
	var endToken = stream.consumeToken();
	stream.applyTempStore(sharpIfParent);
	sharpIfParent.addChild(endToken);
	throw new js__$Boot_HaxeError(new tokentree_walk_SharpEndException());
};
tokentree_walk_WalkSharp.walkSharpIfExpr = function(stream,parent) {
	var childToken;
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			var _g2 = _g.k;
			childToken = stream.consumeToken();
			parent.addChild(childToken);
			if(!stream.hasMore()) {
				return;
			}
			if(stream.token()._hx_index != 10) {
				return;
			}
			var pos = stream.getTokenPos();
			if(pos == null) {
				return;
			}
			if(pos.min == childToken.pos.max + 1) {
				continue;
			}
			var dot = stream.consumeToken();
			childToken.addChild(dot);
			tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot);
			return;
		case 1:
			var _g3 = _g.c;
			if(_g3._hx_index == 3) {
				var _g4 = _g3.s;
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				if(!stream.hasMore()) {
					return;
				}
				if(stream.token()._hx_index != 10) {
					return;
				}
				var pos1 = stream.getTokenPos();
				if(pos1 == null) {
					return;
				}
				if(pos1.min == childToken.pos.max + 1) {
					continue;
				}
				var dot1 = stream.consumeToken();
				childToken.addChild(dot1);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,dot1);
				return;
			} else {
				return;
			}
			break;
		case 4:
			if(_g.op._hx_index == 2) {
				childToken = stream.consumeToken();
				parent.addChild(childToken);
				tokentree_walk_WalkSharp.walkSharpIfExpr(stream,childToken);
				return;
			} else {
				return;
			}
			break;
		case 18:
			tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
			return;
		default:
			return;
		}
	}
};
var tokentree_walk_SharpElseException = function(token) {
	this.token = token;
};
tokentree_walk_SharpElseException.__name__ = true;
var tokentree_walk_SharpEndException = function() {
};
tokentree_walk_SharpEndException.__name__ = true;
var tokentree_walk_WalkStatement = function() { };
tokentree_walk_WalkStatement.__name__ = true;
tokentree_walk_WalkStatement.walkStatement = function(stream,parent) {
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	if(stream.is(haxeparser_TokenDef.Semicolon)) {
		var semicolon = stream.consumeToken();
		var lastChild = parent.getLastChild();
		if(lastChild == null) {
			lastChild = parent;
		}
		switch(lastChild.tok._hx_index) {
		case 15:case 17:case 19:
			lastChild = parent;
			break;
		default:
		}
		lastChild.addChild(semicolon);
	}
};
tokentree_walk_WalkStatement.walkStatementWithoutSemicolon = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var wantMore = true;
	tokentree_walk_WalkAt.walkAts(stream);
	var _g = stream.token();
	switch(_g._hx_index) {
	case 0:
		var _g5 = _g.k;
		if(tokentree_walk_WalkStatement.walkKeyword(stream,parent)) {
			wantMore = true;
		} else {
			return;
		}
		break;
	case 2:
		var _g4 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		tokentree_walk_WalkStatement.walkStatementContinueAfterSharp(stream,parent);
		return;
	case 3:
		var name = _g.s;
		var dollarTok = stream.consumeToken();
		parent.addChild(dollarTok);
		if(stream.is(haxeparser_TokenDef.DblDot)) {
			return;
		}
		tokentree_walk_WalkBlock.walkBlock(stream,dollarTok);
		return;
	case 4:
		var _g2 = _g.op;
		if(parent.isCIdentOrCString()) {
			var newChild = stream.consumeToken();
			parent.addChild(newChild);
			return;
		}
		break;
	case 5:
		switch(_g.op._hx_index) {
		case 3:
			tokentree_walk_WalkBinopSub.walkBinopSub(stream,parent);
			return;
		case 7:
			var gtTok = stream.consumeOpGt();
			parent.addChild(gtTok);
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,gtTok);
			return;
		case 9:
			if(stream.isTypedParam()) {
				tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
				if(stream.is(haxeparser_TokenDef.Arrow)) {
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
				}
				return;
			}
			wantMore = true;
			break;
		default:
			wantMore = true;
		}
		break;
	case 8:
		var _g3 = _g.s;
		wantMore = true;
		break;
	case 9:
		return;
	case 10:
		wantMore = true;
		break;
	case 11:
		if(parent.is(haxeparser_TokenDef.Dot)) {
			return;
		}
		if(tokentree_walk_WalkQuestion.isTernary(parent)) {
			tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
			return;
		}
		wantMore = true;
		break;
	case 12:
		wantMore = true;
		break;
	case 13:
		return;
	case 14:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
		return;
	case 16:
		tokentree_walk_WalkBlock.walkBlock(stream,parent);
		return;
	case 15:case 17:case 19:
		return;
	case 18:
		tokentree_walk_WalkStatement.walkPOpen(stream,parent);
		return;
	case 20:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		return;
	default:
		wantMore = false;
	}
	var newChild1 = stream.consumeToken();
	parent.addChild(newChild1);
	stream.applyTempStore(newChild1);
	tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild1);
	if(wantMore) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild1);
	}
	tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild1);
	tokentree_walk_WalkStatement.walkTrailingComment(stream,newChild1);
};
tokentree_walk_WalkStatement.walkTrailingComment = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	if(_g._hx_index == 7) {
		var _g1 = _g.s;
		var currentPos = stream.getStreamIndex();
		var commentTok = stream.consumeToken();
		if(!stream.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdElse))) {
			stream.rewindTo(currentPos);
			return;
		}
		parent.addChild(commentTok);
	}
};
tokentree_walk_WalkStatement.walkStatementContinue = function(stream,parent) {
	if(!stream.hasMore()) {
		return;
	}
	var _g = stream.token();
	switch(_g._hx_index) {
	case 4:
		var _g2 = _g.op;
		if(parent.isCIdentOrCString()) {
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 5:
		switch(_g.op._hx_index) {
		case 0:case 3:
			tokentree_walk_WalkStatement.walkOpAdd(stream,parent);
			break;
		case 14:case 15:
			tokentree_walk_WalkStatement.walkOpBool(stream,parent);
			break;
		default:
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		}
		break;
	case 6:
		var _g4 = _g.s;
		var nextTokDef = stream.peekNonCommentToken();
		if(nextTokDef == null) {
			return;
		}
		if(nextTokDef != null) {
			switch(nextTokDef._hx_index) {
			case 4:
				var _g1 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 5:
				var _g3 = nextTokDef.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 10:case 11:case 20:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 7:
		var _g31 = _g.s;
		var nextTokDef1 = stream.peekNonCommentToken();
		if(nextTokDef1 == null) {
			return;
		}
		if(nextTokDef1 != null) {
			switch(nextTokDef1._hx_index) {
			case 4:
				var _g11 = nextTokDef1.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 5:
				var _g5 = nextTokDef1.op;
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			case 10:case 11:case 20:
				tokentree_walk_WalkComment.walkComment(stream,parent);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
				break;
			default:
			}
		}
		break;
	case 9:
		return;
	case 10:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 11:
		tokentree_walk_WalkStatement.walkDblDot(stream,parent);
		break;
	case 12:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 14:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 18:
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
		break;
	case 20:
		tokentree_walk_WalkQuestion.walkQuestion(stream,parent);
		break;
	default:
	}
};
tokentree_walk_WalkStatement.walkKeyword = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 0) {
		switch(_g.k._hx_index) {
		case 0:
			tokentree_walk_WalkFunction.walkFunction(stream,parent);
			break;
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 2:
			tokentree_walk_WalkVar.walkVar(stream,parent);
			break;
		case 3:
			tokentree_walk_WalkIf.walkIf(stream,parent);
			break;
		case 5:
			if(!parent.is(haxeparser_TokenDef.BrOpen) && parent.parent.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdDo))) {
				return false;
			}
			tokentree_walk_WalkWhile.walkWhile(stream,parent);
			break;
		case 6:
			tokentree_walk_WalkDoWhile.walkDoWhile(stream,parent);
			break;
		case 7:
			tokentree_walk_WalkFor.walkFor(stream,parent);
			break;
		case 10:case 40:
			return true;
		case 14:
			tokentree_walk_WalkSwitch.walkSwitch(stream,parent);
			break;
		case 15:
			return false;
		case 16:
			if(parent.is(haxeparser_TokenDef.BrOpen)) {
				return false;
			}
			return true;
		case 20:
			tokentree_walk_WalkTry.walkTry(stream,parent);
			break;
		case 22:
			if(parent.is(haxeparser_TokenDef.Dot)) {
				var newChild = stream.consumeToken();
				parent.addChild(newChild);
				tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild);
			} else {
				tokentree_walk_WalkNew.walkNew(stream,parent);
			}
			break;
		case 23:
			var newChild1 = stream.consumeToken();
			parent.addChild(newChild1);
			tokentree_walk_WalkStatement.walkStatementContinue(stream,newChild1);
			return false;
		case 29:
			var newChild2 = stream.consumeToken();
			parent.addChild(newChild2);
			tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild2);
			return false;
		case 36:case 37:case 38:
			var newChild3 = stream.consumeToken();
			parent.addChild(newChild3);
			var _g1 = stream.token();
			switch(_g1._hx_index) {
			case 5:
				switch(_g1.op._hx_index) {
				case 14:case 15:
					tokentree_walk_WalkStatement.walkOpBool(stream,newChild3);
					break;
				default:
					tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,newChild3);
				}
				break;
			case 9:
				newChild3.addChild(stream.consumeToken());
				break;
			default:
			}
			return false;
		default:
			return true;
		}
	} else {
		return true;
	}
	return false;
};
tokentree_walk_WalkStatement.walkDblDot = function(stream,parent) {
	var question = tokentree_walk_WalkStatement.findQuestionParent(parent);
	if(question != null) {
		return;
	}
	var dblDotTok = stream.consumeToken();
	parent.addChild(dblDotTok);
	if(parent.isCIdentOrCString() && parent.parent.is(haxeparser_TokenDef.BrOpen)) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,dblDotTok);
		return;
	}
	if(stream.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdNew))) {
		tokentree_walk_WalkNew.walkNew(stream,dblDotTok);
		return;
	}
	if(!tokentree_walk_WalkStatement.walkKeyword(stream,dblDotTok)) {
		return;
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dblDotTok);
	if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign))) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
	if(stream.is(haxeparser_TokenDef.Arrow)) {
		tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,parent);
	}
};
tokentree_walk_WalkStatement.walkPOpen = function(stream,parent) {
	var pOpen = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	if(parent.tok == null) {
		return;
	}
	if(parent.isCIdent()) {
		tokentree_walk_WalkStatement.walkStatementContinue(stream,parent);
	} else {
		var _g = parent.tok;
		if(_g._hx_index == 0) {
			switch(_g.k._hx_index) {
			case 3:case 5:case 7:case 14:
				var _g1 = stream.token();
				switch(_g1._hx_index) {
				case 5:
					if(_g1.op._hx_index == 3) {
						return;
					}
					break;
				case 10:
					break;
				default:
					return;
				}
				break;
			default:
			}
		}
		tokentree_walk_WalkStatement.walkStatementContinue(stream,pOpen);
	}
};
tokentree_walk_WalkStatement.findQuestionParent = function(token) {
	var parent = token;
	while(parent != null && parent.tok != null) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 10:
				return parent;
			case 15:
				return parent;
			case 16:
				return parent;
			default:
			}
			break;
		case 5:
			var _g1 = _g.op;
			return parent;
		case 13:
			return null;
		case 16:
			if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(parent,haxeparser_TokenDef.BrClose) == null) {
				return null;
			}
			break;
		case 18:
			if(tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(parent,haxeparser_TokenDef.PClose) == null) {
				return null;
			}
			break;
		case 20:
			if(tokentree_walk_WalkQuestion.isTernary(parent)) {
				return parent;
			}
			return null;
		default:
		}
		parent = parent.parent;
	}
	return null;
};
tokentree_walk_WalkStatement.walkStatementContinueAfterSharp = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 0) {
		switch(_g.k._hx_index) {
		case 15:case 16:
			var lastChild = parent.getLastChild();
			if(lastChild == null) {
				lastChild = parent;
			}
			tokentree_walk_WalkSwitch.walkSwitchCases(stream,lastChild);
			break;
		default:
		}
	}
};
tokentree_walk_WalkStatement.walkOpBool = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != null) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			case 14:case 15:case 16:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 5:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 4:
				break _hx_loop1;
			case 14:case 15:
				token = parent.parent;
				break _hx_loop1;
			case 20:
				var _g2 = _g1.op;
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 12:case 20:
			break _hx_loop1;
		case 18:
			if(token.is(haxeparser_TokenDef.POpen)) {
				token = parent;
			}
			break _hx_loop1;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
tokentree_walk_WalkStatement.walkOpAdd = function(stream,token) {
	var parent = token.parent;
	_hx_loop1: while(parent.tok != null) {
		var _g = parent.tok;
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				break _hx_loop1;
			case 3:case 5:case 10:case 24:case 28:
				break _hx_loop1;
			default:
				token = parent;
				parent = parent.parent;
			}
			break;
		case 5:
			var _g1 = _g.op;
			switch(_g1._hx_index) {
			case 0:case 3:
				token = parent.parent;
				break _hx_loop1;
			case 1:case 2:
				token = parent;
				parent = parent.parent;
				break;
			case 4:
				break _hx_loop1;
			case 20:
				var _g2 = _g1.op;
				break _hx_loop1;
			default:
				break _hx_loop1;
			}
			break;
		case 8:
			var _g3 = _g.s;
			break _hx_loop1;
		case 11:
			break _hx_loop1;
		case 12:case 20:
			break _hx_loop1;
		case 14:case 16:
			break _hx_loop1;
		case 18:
			var pClose = tokentree__$TokenTreeAccessHelper_TokenTreeAccessHelper_$Impl_$.firstOf(parent,haxeparser_TokenDef.PClose);
			if(pClose == null) {
				token = parent;
				break _hx_loop1;
			}
			token = parent;
			parent = parent.parent;
			break;
		default:
			token = parent;
			parent = parent.parent;
		}
	}
	tokentree_walk_WalkStatement.walkStatementWithoutSemicolon(stream,token);
};
var tokentree_walk_WalkSwitch = function() { };
tokentree_walk_WalkSwitch.__name__ = true;
tokentree_walk_WalkSwitch.walkSwitch = function(stream,parent) {
	var switchTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdSwitch));
	parent.addChild(switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	tokentree_walk_WalkStatement.walkStatement(stream,switchTok);
	tokentree_walk_WalkComment.walkComment(stream,switchTok);
	var _g = stream.token();
	if(_g._hx_index == 2) {
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
	}
	if(stream.is(haxeparser_TokenDef.BrOpen)) {
		var brOpen = stream.consumeTokenDef(haxeparser_TokenDef.BrOpen);
		switchTok.addChild(brOpen);
		tokentree_walk_WalkSwitch.walkSwitchCases(stream,brOpen);
		brOpen.addChild(stream.consumeTokenDef(haxeparser_TokenDef.BrClose));
	}
};
tokentree_walk_WalkSwitch.walkSwitchCases = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 15:case 16:
				tokentree_walk_WalkSwitch.walkCase(stream,parent);
				break;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			break;
		case 6:
			var _g4 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 7:
			var _g3 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,parent);
			break;
		case 17:
			break _hx_loop1;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
tokentree_walk_WalkSwitch.walkCase = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var caseTok = stream.consumeToken();
	parent.addChild(caseTok);
	tokentree_walk_WalkSwitch.walkCaseExpr(stream,caseTok);
	var dblDot = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
	caseTok.addChild(dblDot);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 15:case 16:
				return;
			default:
				tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
			}
			break;
		case 2:
			var _g1 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkSwitch.walkSwitchCases);
			tokentree_walk_WalkSwitch.relocateSharpTree(parent,dblDot);
			break;
		case 6:
			var _g4 = _g.s;
			var _g2 = stream.peekNonCommentToken();
			if(_g2 != null) {
				if(_g2._hx_index == 0) {
					switch(_g2.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 7:
			var _g3 = _g.s;
			var _g5 = stream.peekNonCommentToken();
			if(_g5 != null) {
				if(_g5._hx_index == 0) {
					switch(_g5.k._hx_index) {
					case 15:case 16:
						return;
					default:
					}
				}
			}
			tokentree_walk_WalkComment.walkComment(stream,dblDot);
			break;
		case 16:
			tokentree_walk_WalkBlock.walkBlock(stream,dblDot);
			break;
		case 17:
			return;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,dblDot);
		}
	}
};
tokentree_walk_WalkSwitch.relocateSharpTree = function(parent,dblDot) {
	var sharp = parent.getLastChild();
	if(sharp.children.length < 2) {
		return;
	}
	var body = sharp.children[1];
	if(body.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdCase))) {
		return;
	}
	parent.children.pop();
	dblDot.addChild(sharp);
};
tokentree_walk_WalkSwitch.walkCaseExpr = function(stream,parent) {
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			if(_g.k._hx_index == 2) {
				var varTok = stream.consumeToken();
				parent.addChild(varTok);
				tokentree_walk_WalkStatement.walkStatement(stream,varTok);
			} else {
				tokentree_walk_WalkStatement.walkStatement(stream,parent);
			}
			break;
		case 13:
			var comma = stream.consumeTokenDef(haxeparser_TokenDef.Comma);
			var child = parent.getLastChild();
			if(child == null) {
				child = parent;
			}
			child.addChild(comma);
			break;
		case 9:case 11:case 15:case 17:case 19:
			return;
		default:
			tokentree_walk_WalkStatement.walkStatement(stream,parent);
		}
	}
};
var tokentree_walk_WalkTry = function() { };
tokentree_walk_WalkTry.__name__ = true;
tokentree_walk_WalkTry.walkTry = function(stream,parent) {
	var tryTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdTry));
	parent.addChild(tryTok);
	tokentree_walk_WalkBlock.walkBlock(stream,tryTok);
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			if(_g.k._hx_index == 21) {
				var _g1 = 0;
				while(_g1 < comments.length) {
					var comment = comments[_g1];
					++_g1;
					tryTok.addChild(comment);
				}
				comments = [];
				tokentree_walk_WalkTry.walkCatch(stream,tryTok);
				currentPos = stream.getStreamIndex();
			} else {
				stream.rewindTo(currentPos);
				return;
			}
			break;
		case 6:
			var _g3 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 7:
			var _g2 = _g.s;
			comments.push(stream.consumeToken());
			break;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
};
tokentree_walk_WalkTry.walkCatch = function(stream,parent) {
	var catchTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdCatch));
	parent.addChild(catchTok);
	tokentree_walk_WalkPOpen.walkPOpen(stream,catchTok);
	tokentree_walk_WalkComment.walkComment(stream,catchTok);
	tokentree_walk_WalkBlock.walkBlock(stream,catchTok);
};
var tokentree_walk_WalkType = function() { };
tokentree_walk_WalkType.__name__ = true;
tokentree_walk_WalkType.walkType = function(stream,parent) {
	var _g = stream.token();
	if(_g._hx_index == 0) {
		switch(_g.k._hx_index) {
		case 1:
			tokentree_walk_WalkClass.walkClass(stream,parent);
			break;
		case 26:
			tokentree_walk_WalkEnum.walkEnum(stream,parent);
			break;
		case 27:
			tokentree_walk_WalkInterface.walkInterface(stream,parent);
			break;
		case 31:
			tokentree_walk_WalkTypedef.walkTypedef(stream,parent);
			break;
		case 39:
			tokentree_walk_WalkAbstract.walkAbstract(stream,parent);
			break;
		default:
		}
	}
};
var tokentree_walk_WalkTypeNameDef = function() { };
tokentree_walk_WalkTypeNameDef.__name__ = true;
tokentree_walk_WalkTypeNameDef.walkTypeNameDef = function(stream,parent) {
	tokentree_walk_WalkComment.walkComment(stream,parent);
	tokentree_walk_WalkAt.walkAts(stream);
	if(stream.is(haxeparser_TokenDef.Question)) {
		var questTok = stream.consumeTokenDef(haxeparser_TokenDef.Question);
		parent.addChild(questTok);
		parent = questTok;
		tokentree_walk_WalkComment.walkComment(stream,parent);
	}
	var name;
	var bAdd = true;
	var _g = stream.token();
	switch(_g._hx_index) {
	case 0:
		switch(_g.k._hx_index) {
		case 22:case 25:case 40:
			name = stream.consumeToken();
			break;
		default:
			name = stream.consumeToken();
		}
		break;
	case 1:
		var _g3 = _g.c;
		name = stream.consumeConst();
		break;
	case 2:
		var _g1 = _g.s;
		tokentree_walk_WalkSharp.walkSharp(stream,parent,tokentree_walk_WalkStatement.walkStatement);
		if(!stream.hasMore()) {
			return parent.getFirstChild();
		}
		var _g2 = stream.token();
		if(_g2._hx_index == 1) {
			var _g11 = _g2.c;
			name = stream.consumeConst();
		} else {
			return parent.getFirstChild();
		}
		break;
	case 3:
		var _g4 = _g.s;
		name = stream.consumeToken();
		break;
	case 14:
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
		return parent.getFirstChild();
	case 16:
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
		return parent.getFirstChild();
	case 18:
		name = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
		if(stream.is(haxeparser_TokenDef.Question)) {
			tokentree_walk_WalkQuestion.walkQuestion(stream,name);
		}
		bAdd = false;
		break;
	default:
		name = stream.consumeToken();
	}
	stream.applyTempStore(name);
	if(bAdd) {
		parent.addChild(name);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue(stream,name);
	return name;
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefContinue = function(stream,parent) {
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
	if(stream.is(haxeparser_TokenDef.Dot)) {
		var dot = stream.consumeTokenDef(haxeparser_TokenDef.Dot);
		parent.addChild(dot);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,dot);
		return;
	}
	if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt))) {
		tokentree_walk_WalkLtGt.walkLtGt(stream,parent);
	}
	if(stream.is(haxeparser_TokenDef.Arrow)) {
		var arrow = stream.consumeTokenDef(haxeparser_TokenDef.Arrow);
		parent.addChild(arrow);
		tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,arrow);
		return;
	}
	if(stream.is(haxeparser_TokenDef.BkOpen)) {
		tokentree_walk_WalkArrayAccess.walkArrayAccess(stream,parent);
	}
	tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment(stream,parent);
};
tokentree_walk_WalkTypeNameDef.walkTypeNameDefComment = function(stream,parent) {
	var currentPos = stream.getStreamIndex();
	var progress = new tokentree_TokenStreamProgress(stream);
	var comments = [];
	while(stream.hasMore() && progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 5:
			var _g1 = _g.op;
			var _g2 = 0;
			while(_g2 < comments.length) {
				var comment = comments[_g2];
				++_g2;
				parent.addChild(comment);
			}
			return;
		case 6:
			var _g3 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 7:
			var _g21 = _g.s;
			comments.push(stream.consumeToken());
			break;
		case 9:case 10:case 11:case 13:case 14:case 16:case 18:
			var _g4 = 0;
			while(_g4 < comments.length) {
				var comment1 = comments[_g4];
				++_g4;
				parent.addChild(comment1);
			}
			return;
		default:
			stream.rewindTo(currentPos);
			return;
		}
	}
};
var tokentree_walk_WalkTypedef = function() { };
tokentree_walk_WalkTypedef.__name__ = true;
tokentree_walk_WalkTypedef.walkTypedef = function(stream,parent) {
	var typeTok = stream.consumeToken();
	parent.addChild(typeTok);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,typeTok);
	stream.applyTempStore(name);
	if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign))) {
		var assign = stream.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
		name.addChild(assign);
		name = assign;
	}
	tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,name);
};
var tokentree_walk_WalkTypedefBody = function() { };
tokentree_walk_WalkTypedefBody.__name__ = true;
tokentree_walk_WalkTypedefBody.walkTypedefBody = function(stream,parent) {
	if(stream.is(haxeparser_TokenDef.BrOpen)) {
		var openTok = stream.consumeTokenDef(haxeparser_TokenDef.BrOpen);
		parent.addChild(openTok);
		tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody(stream,openTok);
		openTok.addChild(stream.consumeTokenDef(haxeparser_TokenDef.BrClose));
	} else {
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,parent);
	}
	if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd))) {
		var and = stream.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd));
		parent.getLastChild().addChild(and);
		tokentree_walk_WalkTypedefBody.walkTypedefBody(stream,parent);
	}
	if(stream.is(haxeparser_TokenDef.Arrow)) {
		tokentree_walk_WalkStatement.walkStatement(stream,parent);
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody = function(stream,openTok) {
	var progress = new tokentree_TokenStreamProgress(stream);
	_hx_loop1: while(progress.streamHasChanged()) {
		var _g = stream.token();
		switch(_g._hx_index) {
		case 0:
			switch(_g.k._hx_index) {
			case 0:
				tokentree_walk_WalkFunction.walkFunction(stream,openTok);
				break;
			case 2:
				tokentree_walk_WalkVar.walkVar(stream,openTok);
				break;
			case 17:case 18:case 19:case 25:case 30:case 32:case 34:case 40:
				stream.consumeToTempStore();
				break;
			case 41:
				tokentree_walk_WalkFinal.walkFinal(stream,openTok);
				break;
			default:
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 1:
			var _g4 = _g.c;
			if(_g4._hx_index == 3) {
				if(_g4.s == "final") {
					tokentree_walk_WalkFinal.walkFinal(stream,openTok);
				} else {
					tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
				}
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 2:
			var _g2 = _g.s;
			tokentree_walk_WalkSharp.walkSharp(stream,openTok,tokentree_walk_WalkTypedefBody.walkTypedefCurlyBody);
			break;
		case 5:
			if(_g.op._hx_index == 7) {
				tokentree_walk_WalkTypedefBody.walkStructureExtension(stream,openTok);
			} else {
				tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
			}
			break;
		case 6:
			var _g7 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,openTok);
			break;
		case 7:
			var _g6 = _g.s;
			tokentree_walk_WalkComment.walkComment(stream,openTok);
			break;
		case 17:
			break _hx_loop1;
		case 21:
			stream.addToTempStore(tokentree_walk_WalkAt.walkAt(stream));
			break;
		default:
			tokentree_walk_WalkFieldDef.walkFieldDef(stream,openTok);
		}
	}
	var tempStore = stream.getTempStore();
	if(tempStore.length > 0) {
		switch(tokentree_TokenStream.MODE._hx_index) {
		case 0:
			throw new js__$Boot_HaxeError("invalid token tree structure - found:" + ("" + Std.string(tempStore)));
		case 1:
			stream.applyTempStore(openTok);
			break;
		}
	}
};
tokentree_walk_WalkTypedefBody.walkTypedefAlias = function(stream,parent) {
	var newParent;
	if(stream.is(haxeparser_TokenDef.POpen)) {
		newParent = tokentree_walk_WalkPOpen.walkPOpen(stream,parent);
	} else {
		newParent = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	}
	if(stream.is(haxeparser_TokenDef.Arrow)) {
		var arrowTok = stream.consumeTokenDef(haxeparser_TokenDef.Arrow);
		newParent.addChild(arrowTok);
		tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,arrowTok);
	}
	if(stream.is(haxeparser_TokenDef.Semicolon)) {
		newParent.addChild(stream.consumeTokenDef(haxeparser_TokenDef.Semicolon));
	}
};
tokentree_walk_WalkTypedefBody.walkStructureExtension = function(stream,parent) {
	var gt = stream.consumeTokenDef(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
	parent.addChild(gt);
	var name = tokentree_walk_WalkTypeNameDef.walkTypeNameDef(stream,parent);
	gt.addChild(name);
	if(stream.is(haxeparser_TokenDef.Comma)) {
		name.addChild(stream.consumeToken());
	}
};
var tokentree_walk_WalkVar = function() { };
tokentree_walk_WalkVar.__name__ = true;
tokentree_walk_WalkVar.walkVar = function(stream,parent) {
	var name = null;
	var varTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdVar));
	parent.addChild(varTok);
	tokentree_walk_WalkComment.walkComment(stream,parent);
	var progress = new tokentree_TokenStreamProgress(stream);
	while(progress.streamHasChanged()) {
		if(stream.is(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdVar))) {
			return;
		}
		tokentree_walk_WalkComment.walkComment(stream,parent);
		var nameParent = varTok;
		if(stream.is(haxeparser_TokenDef.Question)) {
			nameParent = stream.consumeToken();
			varTok.addChild(nameParent);
		}
		name = stream.consumeConstIdent();
		nameParent.addChild(name);
		stream.applyTempStore(name);
		tokentree_walk_WalkComment.walkComment(stream,name);
		if(stream.is(haxeparser_TokenDef.POpen)) {
			tokentree_walk_WalkPOpen.walkPOpen(stream,name);
		}
		if(stream.is(haxeparser_TokenDef.DblDot)) {
			var dblDot = stream.consumeTokenDef(haxeparser_TokenDef.DblDot);
			name.addChild(dblDot);
			tokentree_walk_WalkTypedefBody.walkTypedefAlias(stream,dblDot);
		}
		if(stream.is(haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign))) {
			tokentree_walk_WalkStatement.walkStatement(stream,name);
		}
		if(stream.is(haxeparser_TokenDef.Comma)) {
			var comma = stream.consumeTokenDef(haxeparser_TokenDef.Comma);
			name.addChild(comma);
			continue;
		}
		break;
	}
	if(stream.is(haxeparser_TokenDef.Semicolon)) {
		name.addChild(stream.consumeTokenDef(haxeparser_TokenDef.Semicolon));
	}
};
var tokentree_walk_WalkWhile = function() { };
tokentree_walk_WalkWhile.__name__ = true;
tokentree_walk_WalkWhile.walkWhile = function(stream,parent) {
	var whileTok = stream.consumeTokenDef(haxeparser_TokenDef.Kwd(haxeparser_Keyword.KwdWhile));
	parent.addChild(whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkStatement.walkStatement(stream,whileTok);
	tokentree_walk_WalkComment.walkComment(stream,whileTok);
	tokentree_walk_WalkBlock.walkBlock(stream,whileTok);
};
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
if(typeof $global.$haxeUID == "undefined") $global.$haxeUID = 0;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = "Date";
var __map_reserved = {};
js_Boot.__toStr = ({ }).toString;
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_lib__$ArrayBuffer_ArrayBufferCompat.sliceImpl;
}
formatter_FormatStats.totalFiles = 0;
formatter_FormatStats.successFiles = 0;
formatter_FormatStats.failedFiles = 0;
formatter_FormatStats.disabledFiles = 0;
formatter_FormatStats.totalLinesOrig = 0;
formatter_FormatStats.totalLinesFormatted = 0;
formatter_Formatter.FORMATTER_JSON = "hxformat.json";
formatter_codedata_CodeLines.FORMATTER_OFF = " @formatter:off";
formatter_codedata_CodeLines.FORMATTER_ON = " @formatter:on";
formatter_codedata_ParsedCode.BAD_OFFSET = "Bad offset";
formatter_codedata_TokenList.NEWLINE_TO_SPACE = "Newline -> Space";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.None = "none";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.Before = "before";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.NoneBefore = "noneBefore";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.OnlyBefore = "onlyBefore";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.After = "after";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.OnlyAfter = "onlyAfter";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.NoneAfter = "noneAfter";
formatter_config__$WhitespacePolicy_WhitespacePolicy_$Impl_$.Around = "around";
formatter_marker_MarkEmptyLines.FINAL = "final";
formatter_marker_MarkLineEnds.SHARP_IF = "if";
formatter_marker_MarkLineEnds.SHARP_ELSE_IF = "elseif";
formatter_marker_MarkLineEnds.SHARP_ELSE = "else";
formatter_marker_MarkLineEnds.SHARP_END = "end";
formatter_marker_MarkLineEnds.SHARP_ERROR = "error";
hxparse_LexEngine.MAX_CODE = 255;
hxparse_LexEngine.EMPTY = [];
hxparse_LexEngine.ALL_CHARS = [{ min : 0, max : 255}];
haxeparser_HaxeLexer.keywords = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	{
		var value = haxeparser_Keyword.KwdAbstract;
		if(__map_reserved["abstract"] != null) {
			_g.setReserved("abstract",value);
		} else {
			_g.h["abstract"] = value;
		}
	}
	{
		var value1 = haxeparser_Keyword.KwdBreak;
		if(__map_reserved["break"] != null) {
			_g.setReserved("break",value1);
		} else {
			_g.h["break"] = value1;
		}
	}
	{
		var value2 = haxeparser_Keyword.KwdCase;
		if(__map_reserved["case"] != null) {
			_g.setReserved("case",value2);
		} else {
			_g.h["case"] = value2;
		}
	}
	{
		var value3 = haxeparser_Keyword.KwdCast;
		if(__map_reserved["cast"] != null) {
			_g.setReserved("cast",value3);
		} else {
			_g.h["cast"] = value3;
		}
	}
	{
		var value4 = haxeparser_Keyword.KwdCatch;
		if(__map_reserved["catch"] != null) {
			_g.setReserved("catch",value4);
		} else {
			_g.h["catch"] = value4;
		}
	}
	{
		var value5 = haxeparser_Keyword.KwdClass;
		if(__map_reserved["class"] != null) {
			_g.setReserved("class",value5);
		} else {
			_g.h["class"] = value5;
		}
	}
	{
		var value6 = haxeparser_Keyword.KwdContinue;
		if(__map_reserved["continue"] != null) {
			_g.setReserved("continue",value6);
		} else {
			_g.h["continue"] = value6;
		}
	}
	{
		var value7 = haxeparser_Keyword.KwdDefault;
		if(__map_reserved["default"] != null) {
			_g.setReserved("default",value7);
		} else {
			_g.h["default"] = value7;
		}
	}
	{
		var value8 = haxeparser_Keyword.KwdDo;
		if(__map_reserved["do"] != null) {
			_g.setReserved("do",value8);
		} else {
			_g.h["do"] = value8;
		}
	}
	{
		var value9 = haxeparser_Keyword.KwdDynamic;
		if(__map_reserved["dynamic"] != null) {
			_g.setReserved("dynamic",value9);
		} else {
			_g.h["dynamic"] = value9;
		}
	}
	{
		var value10 = haxeparser_Keyword.KwdElse;
		if(__map_reserved["else"] != null) {
			_g.setReserved("else",value10);
		} else {
			_g.h["else"] = value10;
		}
	}
	{
		var value11 = haxeparser_Keyword.KwdEnum;
		if(__map_reserved["enum"] != null) {
			_g.setReserved("enum",value11);
		} else {
			_g.h["enum"] = value11;
		}
	}
	{
		var value12 = haxeparser_Keyword.KwdExtends;
		if(__map_reserved["extends"] != null) {
			_g.setReserved("extends",value12);
		} else {
			_g.h["extends"] = value12;
		}
	}
	{
		var value13 = haxeparser_Keyword.KwdExtern;
		if(__map_reserved["extern"] != null) {
			_g.setReserved("extern",value13);
		} else {
			_g.h["extern"] = value13;
		}
	}
	{
		var value14 = haxeparser_Keyword.KwdFalse;
		if(__map_reserved["false"] != null) {
			_g.setReserved("false",value14);
		} else {
			_g.h["false"] = value14;
		}
	}
	{
		var value15 = haxeparser_Keyword.KwdFinal;
		if(__map_reserved["final"] != null) {
			_g.setReserved("final",value15);
		} else {
			_g.h["final"] = value15;
		}
	}
	{
		var value16 = haxeparser_Keyword.KwdFor;
		if(__map_reserved["for"] != null) {
			_g.setReserved("for",value16);
		} else {
			_g.h["for"] = value16;
		}
	}
	{
		var value17 = haxeparser_Keyword.KwdFunction;
		if(__map_reserved["function"] != null) {
			_g.setReserved("function",value17);
		} else {
			_g.h["function"] = value17;
		}
	}
	{
		var value18 = haxeparser_Keyword.KwdIf;
		if(__map_reserved["if"] != null) {
			_g.setReserved("if",value18);
		} else {
			_g.h["if"] = value18;
		}
	}
	{
		var value19 = haxeparser_Keyword.KwdImplements;
		if(__map_reserved["implements"] != null) {
			_g.setReserved("implements",value19);
		} else {
			_g.h["implements"] = value19;
		}
	}
	{
		var value20 = haxeparser_Keyword.KwdImport;
		if(__map_reserved["import"] != null) {
			_g.setReserved("import",value20);
		} else {
			_g.h["import"] = value20;
		}
	}
	{
		var value21 = haxeparser_Keyword.KwdInline;
		if(__map_reserved["inline"] != null) {
			_g.setReserved("inline",value21);
		} else {
			_g.h["inline"] = value21;
		}
	}
	{
		var value22 = haxeparser_Keyword.KwdInterface;
		if(__map_reserved["interface"] != null) {
			_g.setReserved("interface",value22);
		} else {
			_g.h["interface"] = value22;
		}
	}
	{
		var value23 = haxeparser_Keyword.KwdMacro;
		if(__map_reserved["macro"] != null) {
			_g.setReserved("macro",value23);
		} else {
			_g.h["macro"] = value23;
		}
	}
	{
		var value24 = haxeparser_Keyword.KwdNew;
		if(__map_reserved["new"] != null) {
			_g.setReserved("new",value24);
		} else {
			_g.h["new"] = value24;
		}
	}
	{
		var value25 = haxeparser_Keyword.KwdNull;
		if(__map_reserved["null"] != null) {
			_g.setReserved("null",value25);
		} else {
			_g.h["null"] = value25;
		}
	}
	{
		var value26 = haxeparser_Keyword.KwdOverride;
		if(__map_reserved["override"] != null) {
			_g.setReserved("override",value26);
		} else {
			_g.h["override"] = value26;
		}
	}
	{
		var value27 = haxeparser_Keyword.KwdPackage;
		if(__map_reserved["package"] != null) {
			_g.setReserved("package",value27);
		} else {
			_g.h["package"] = value27;
		}
	}
	{
		var value28 = haxeparser_Keyword.KwdPrivate;
		if(__map_reserved["private"] != null) {
			_g.setReserved("private",value28);
		} else {
			_g.h["private"] = value28;
		}
	}
	{
		var value29 = haxeparser_Keyword.KwdPublic;
		if(__map_reserved["public"] != null) {
			_g.setReserved("public",value29);
		} else {
			_g.h["public"] = value29;
		}
	}
	{
		var value30 = haxeparser_Keyword.KwdReturn;
		if(__map_reserved["return"] != null) {
			_g.setReserved("return",value30);
		} else {
			_g.h["return"] = value30;
		}
	}
	{
		var value31 = haxeparser_Keyword.KwdStatic;
		if(__map_reserved["static"] != null) {
			_g.setReserved("static",value31);
		} else {
			_g.h["static"] = value31;
		}
	}
	{
		var value32 = haxeparser_Keyword.KwdSwitch;
		if(__map_reserved["switch"] != null) {
			_g.setReserved("switch",value32);
		} else {
			_g.h["switch"] = value32;
		}
	}
	{
		var value33 = haxeparser_Keyword.KwdThis;
		if(__map_reserved["this"] != null) {
			_g.setReserved("this",value33);
		} else {
			_g.h["this"] = value33;
		}
	}
	{
		var value34 = haxeparser_Keyword.KwdThrow;
		if(__map_reserved["throw"] != null) {
			_g.setReserved("throw",value34);
		} else {
			_g.h["throw"] = value34;
		}
	}
	{
		var value35 = haxeparser_Keyword.KwdTrue;
		if(__map_reserved["true"] != null) {
			_g.setReserved("true",value35);
		} else {
			_g.h["true"] = value35;
		}
	}
	{
		var value36 = haxeparser_Keyword.KwdTry;
		if(__map_reserved["try"] != null) {
			_g.setReserved("try",value36);
		} else {
			_g.h["try"] = value36;
		}
	}
	{
		var value37 = haxeparser_Keyword.KwdTypedef;
		if(__map_reserved["typedef"] != null) {
			_g.setReserved("typedef",value37);
		} else {
			_g.h["typedef"] = value37;
		}
	}
	{
		var value38 = haxeparser_Keyword.KwdUntyped;
		if(__map_reserved["untyped"] != null) {
			_g.setReserved("untyped",value38);
		} else {
			_g.h["untyped"] = value38;
		}
	}
	{
		var value39 = haxeparser_Keyword.KwdUsing;
		if(__map_reserved["using"] != null) {
			_g.setReserved("using",value39);
		} else {
			_g.h["using"] = value39;
		}
	}
	{
		var value40 = haxeparser_Keyword.KwdVar;
		if(__map_reserved["var"] != null) {
			_g.setReserved("var",value40);
		} else {
			_g.h["var"] = value40;
		}
	}
	{
		var value41 = haxeparser_Keyword.KwdWhile;
		if(__map_reserved["while"] != null) {
			_g.setReserved("while",value41);
		} else {
			_g.h["while"] = value41;
		}
	}
	$r = _g;
	return $r;
}(this));
haxeparser_HaxeLexer.buf = new StringBuf();
haxeparser_HaxeLexer.ident = "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*";
haxeparser_HaxeLexer.sharp_ident = "[a-z_][a-zA-Z0-9_]*(\\.[a-z_][a-zA-Z0-9_]*)*";
haxeparser_HaxeLexer.idtype = "_*[A-Z][a-zA-Z0-9_]*";
haxeparser_HaxeLexer.integer = "([1-9][0-9]*)|0";
haxeparser_HaxeLexer.tok = hxparse_Lexer.buildRuleset([{ rule : "", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Eof);
}},{ rule : "[\r\n\t ]+", func : function(lexer1) {
	return lexer1.token(haxeparser_HaxeLexer.tok);
}},{ rule : "0x[0-9a-fA-F]+", func : function(lexer2) {
	return haxeparser_HaxeLexer.mk(lexer2,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer2.current)));
}},{ rule : "([1-9][0-9]*)|0", func : function(lexer3) {
	return haxeparser_HaxeLexer.mk(lexer3,haxeparser_TokenDef.Const(haxe_macro_Constant.CInt(lexer3.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]+)", func : function(lexer4) {
	return haxeparser_HaxeLexer.mk(lexer4,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer4.current)));
}},{ rule : "\\.[0-9]+", func : function(lexer5) {
	return haxeparser_HaxeLexer.mk(lexer5,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer5.current)));
}},{ rule : "(([1-9][0-9]*)|0)([eE][\\+\\-]?[0-9]+)", func : function(lexer6) {
	return haxeparser_HaxeLexer.mk(lexer6,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer6.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.[0-9]*[eE][\\+\\-]?[0-9]+)", func : function(lexer7) {
	return haxeparser_HaxeLexer.mk(lexer7,haxeparser_TokenDef.Const(haxe_macro_Constant.CFloat(lexer7.current)));
}},{ rule : "(([1-9][0-9]*)|0)(\\.\\.\\.)", func : function(lexer8) {
	return haxeparser_HaxeLexer.mk(lexer8,haxeparser_TokenDef.IntInterval(HxOverrides.substr(lexer8.current,0,-3)));
}},{ rule : "//[^\n\r]*", func : function(lexer9) {
	return haxeparser_HaxeLexer.mk(lexer9,haxeparser_TokenDef.CommentLine(HxOverrides.substr(lexer9.current,2,null)));
}},{ rule : "+\\+", func : function(lexer10) {
	return haxeparser_HaxeLexer.mk(lexer10,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpIncrement));
}},{ rule : "--", func : function(lexer11) {
	return haxeparser_HaxeLexer.mk(lexer11,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpDecrement));
}},{ rule : "~", func : function(lexer12) {
	return haxeparser_HaxeLexer.mk(lexer12,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNegBits));
}},{ rule : "%=", func : function(lexer13) {
	return haxeparser_HaxeLexer.mk(lexer13,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMod)));
}},{ rule : "&=", func : function(lexer14) {
	return haxeparser_HaxeLexer.mk(lexer14,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAnd)));
}},{ rule : "|=", func : function(lexer15) {
	return haxeparser_HaxeLexer.mk(lexer15,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpOr)));
}},{ rule : "^=", func : function(lexer16) {
	return haxeparser_HaxeLexer.mk(lexer16,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpXor)));
}},{ rule : "+=", func : function(lexer17) {
	return haxeparser_HaxeLexer.mk(lexer17,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd)));
}},{ rule : "-=", func : function(lexer18) {
	return haxeparser_HaxeLexer.mk(lexer18,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpSub)));
}},{ rule : "*=", func : function(lexer19) {
	return haxeparser_HaxeLexer.mk(lexer19,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult)));
}},{ rule : "/=", func : function(lexer20) {
	return haxeparser_HaxeLexer.mk(lexer20,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpDiv)));
}},{ rule : "<<=", func : function(lexer21) {
	return haxeparser_HaxeLexer.mk(lexer21,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpShl)));
}},{ rule : "==", func : function(lexer22) {
	return haxeparser_HaxeLexer.mk(lexer22,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpEq));
}},{ rule : "!=", func : function(lexer23) {
	return haxeparser_HaxeLexer.mk(lexer23,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpNotEq));
}},{ rule : "<=", func : function(lexer24) {
	return haxeparser_HaxeLexer.mk(lexer24,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLte));
}},{ rule : "&&", func : function(lexer25) {
	return haxeparser_HaxeLexer.mk(lexer25,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolAnd));
}},{ rule : "|\\|", func : function(lexer26) {
	return haxeparser_HaxeLexer.mk(lexer26,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpBoolOr));
}},{ rule : "<<", func : function(lexer27) {
	return haxeparser_HaxeLexer.mk(lexer27,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpShl));
}},{ rule : "->", func : function(lexer28) {
	return haxeparser_HaxeLexer.mk(lexer28,haxeparser_TokenDef.Arrow);
}},{ rule : "\\.\\.\\.", func : function(lexer29) {
	return haxeparser_HaxeLexer.mk(lexer29,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpInterval));
}},{ rule : "=>", func : function(lexer30) {
	return haxeparser_HaxeLexer.mk(lexer30,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpArrow));
}},{ rule : "!", func : function(lexer31) {
	return haxeparser_HaxeLexer.mk(lexer31,haxeparser_TokenDef.Unop(haxe_macro_Unop.OpNot));
}},{ rule : "<", func : function(lexer32) {
	return haxeparser_HaxeLexer.mk(lexer32,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpLt));
}},{ rule : ">", func : function(lexer33) {
	return haxeparser_HaxeLexer.mk(lexer33,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpGt));
}},{ rule : ";", func : function(lexer34) {
	return haxeparser_HaxeLexer.mk(lexer34,haxeparser_TokenDef.Semicolon);
}},{ rule : ":", func : function(lexer35) {
	return haxeparser_HaxeLexer.mk(lexer35,haxeparser_TokenDef.DblDot);
}},{ rule : ",", func : function(lexer36) {
	return haxeparser_HaxeLexer.mk(lexer36,haxeparser_TokenDef.Comma);
}},{ rule : "\\.", func : function(lexer37) {
	return haxeparser_HaxeLexer.mk(lexer37,haxeparser_TokenDef.Dot);
}},{ rule : "%", func : function(lexer38) {
	return haxeparser_HaxeLexer.mk(lexer38,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMod));
}},{ rule : "&", func : function(lexer39) {
	return haxeparser_HaxeLexer.mk(lexer39,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAnd));
}},{ rule : "|", func : function(lexer40) {
	return haxeparser_HaxeLexer.mk(lexer40,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpOr));
}},{ rule : "^", func : function(lexer41) {
	return haxeparser_HaxeLexer.mk(lexer41,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpXor));
}},{ rule : "+", func : function(lexer42) {
	return haxeparser_HaxeLexer.mk(lexer42,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAdd));
}},{ rule : "*", func : function(lexer43) {
	return haxeparser_HaxeLexer.mk(lexer43,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpMult));
}},{ rule : "/", func : function(lexer44) {
	return haxeparser_HaxeLexer.mk(lexer44,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpDiv));
}},{ rule : "-", func : function(lexer45) {
	return haxeparser_HaxeLexer.mk(lexer45,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpSub));
}},{ rule : "=", func : function(lexer46) {
	return haxeparser_HaxeLexer.mk(lexer46,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpAssign));
}},{ rule : "in", func : function(lexer47) {
	return haxeparser_HaxeLexer.mk(lexer47,haxeparser_TokenDef.Binop(haxe_macro_Binop.OpIn));
}},{ rule : "[", func : function(lexer48) {
	return haxeparser_HaxeLexer.mk(lexer48,haxeparser_TokenDef.BkOpen);
}},{ rule : "]", func : function(lexer49) {
	return haxeparser_HaxeLexer.mk(lexer49,haxeparser_TokenDef.BkClose);
}},{ rule : "{", func : function(lexer50) {
	return haxeparser_HaxeLexer.mk(lexer50,haxeparser_TokenDef.BrOpen);
}},{ rule : "}", func : function(lexer51) {
	return haxeparser_HaxeLexer.mk(lexer51,haxeparser_TokenDef.BrClose);
}},{ rule : "\\(", func : function(lexer52) {
	return haxeparser_HaxeLexer.mk(lexer52,haxeparser_TokenDef.POpen);
}},{ rule : "\\)", func : function(lexer53) {
	return haxeparser_HaxeLexer.mk(lexer53,haxeparser_TokenDef.PClose);
}},{ rule : "?", func : function(lexer54) {
	return haxeparser_HaxeLexer.mk(lexer54,haxeparser_TokenDef.Question);
}},{ rule : "@", func : function(lexer55) {
	return haxeparser_HaxeLexer.mk(lexer55,haxeparser_TokenDef.At);
}},{ rule : "\"", func : function(lexer56) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin = new hxparse_Position(lexer56.source,lexer56.pos - lexer56.current.length,lexer56.pos);
	var pmax;
	try {
		pmax = lexer56.token(haxeparser_HaxeLexer.string);
	} catch( e ) {
		haxe_CallStack.lastException = e;
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		if(((e1) instanceof haxe_io_Eof)) {
			var e2 = e1;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw e;
		}
	}
	var token = haxeparser_HaxeLexer.mk(lexer56,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin)))));
	token.pos.min = pmin.pmin;
	return token;
}},{ rule : "'", func : function(lexer57) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin1 = new hxparse_Position(lexer57.source,lexer57.pos - lexer57.current.length,lexer57.pos);
	var pmax1;
	try {
		pmax1 = lexer57.token(haxeparser_HaxeLexer.string2);
	} catch( e3 ) {
		haxe_CallStack.lastException = e3;
		var e4 = ((e3) instanceof js__$Boot_HaxeError) ? e3.val : e3;
		if(((e4) instanceof haxe_io_Eof)) {
			var e5 = e4;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin1)));
		} else {
			throw e3;
		}
	}
	var token1 = haxeparser_HaxeLexer.mk(lexer57,haxeparser_TokenDef.Const(haxe_macro_Constant.CString(haxeparser_HaxeLexer.unescape(haxeparser_HaxeLexer.buf.b,haxeparser_HaxeLexer.mkPos(pmin1)))));
	token1.pos.min = pmin1.pmin;
	return token1;
}},{ rule : "~/", func : function(lexer58) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin2 = new hxparse_Position(lexer58.source,lexer58.pos - lexer58.current.length,lexer58.pos);
	var info;
	try {
		info = lexer58.token(haxeparser_HaxeLexer.regexp);
	} catch( e6 ) {
		haxe_CallStack.lastException = e6;
		var e7 = ((e6) instanceof js__$Boot_HaxeError) ? e6.val : e6;
		if(((e7) instanceof haxe_io_Eof)) {
			var e8 = e7;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedRegExp,haxeparser_HaxeLexer.mkPos(pmin2)));
		} else {
			throw e6;
		}
	}
	var token2 = haxeparser_HaxeLexer.mk(lexer58,haxeparser_TokenDef.Const(haxe_macro_Constant.CRegexp(haxeparser_HaxeLexer.buf.b,info.opt)));
	token2.pos.min = pmin2.pmin;
	return token2;
}},{ rule : "/\\*", func : function(lexer59) {
	haxeparser_HaxeLexer.buf = new StringBuf();
	var pmin3 = new hxparse_Position(lexer59.source,lexer59.pos - lexer59.current.length,lexer59.pos);
	var pmax2;
	try {
		pmax2 = lexer59.token(haxeparser_HaxeLexer.comment);
	} catch( e9 ) {
		haxe_CallStack.lastException = e9;
		var e10 = ((e9) instanceof js__$Boot_HaxeError) ? e9.val : e9;
		if(((e10) instanceof haxe_io_Eof)) {
			var e11 = e10;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin3)));
		} else {
			throw e9;
		}
	}
	var token3 = haxeparser_HaxeLexer.mk(lexer59,haxeparser_TokenDef.Comment(haxeparser_HaxeLexer.buf.b));
	token3.pos.min = pmin3.pmin;
	return token3;
}},{ rule : "(#)(_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*)", func : function(lexer60) {
	return haxeparser_HaxeLexer.mk(lexer60,haxeparser_TokenDef.Sharp(HxOverrides.substr(lexer60.current,1,null)));
}},{ rule : "$[_a-zA-Z0-9]*", func : function(lexer61) {
	return haxeparser_HaxeLexer.mk(lexer61,haxeparser_TokenDef.Dollar(HxOverrides.substr(lexer61.current,1,null)));
}},{ rule : "_*[a-z][a-zA-Z0-9_]*|_+|_+[0-9][_a-zA-Z0-9]*", func : function(lexer62) {
	var key = lexer62.current;
	var _this = haxeparser_HaxeLexer.keywords;
	var kwd = __map_reserved[key] != null ? _this.getReserved(key) : _this.h[key];
	if(kwd != null) {
		return haxeparser_HaxeLexer.mk(lexer62,haxeparser_TokenDef.Kwd(kwd));
	} else {
		return haxeparser_HaxeLexer.mk(lexer62,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer62.current)));
	}
}},{ rule : "_*[A-Z][a-zA-Z0-9_]*", func : function(lexer63) {
	return haxeparser_HaxeLexer.mk(lexer63,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer63.current)));
}}],"tok");
haxeparser_HaxeLexer.string = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\", func : function(lexer1) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer1.token(haxeparser_HaxeLexer.string);
}},{ rule : "\\\\\"", func : function(lexer2) {
	haxeparser_HaxeLexer.buf.b += "\"";
	return lexer2.token(haxeparser_HaxeLexer.string);
}},{ rule : "\"", func : function(lexer3) {
	return new hxparse_Position(lexer3.source,lexer3.pos - lexer3.current.length,lexer3.pos).pmax;
}},{ rule : "[^\\\\\"]+", func : function(lexer4) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer4.current);
	return lexer4.token(haxeparser_HaxeLexer.string);
}}],"string");
haxeparser_HaxeLexer.string2 = hxparse_Lexer.buildRuleset([{ rule : "\\\\\\\\", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "\\\\";
	return lexer.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\", func : function(lexer1) {
	haxeparser_HaxeLexer.buf.b += "\\";
	return lexer1.token(haxeparser_HaxeLexer.string2);
}},{ rule : "\\\\'", func : function(lexer2) {
	haxeparser_HaxeLexer.buf.b += "'";
	return lexer2.token(haxeparser_HaxeLexer.string2);
}},{ rule : "'", func : function(lexer3) {
	return new hxparse_Position(lexer3.source,lexer3.pos - lexer3.current.length,lexer3.pos).pmax;
}},{ rule : "($$)|(\\$)|$", func : function(lexer4) {
	haxeparser_HaxeLexer.buf.b += "$";
	return lexer4.token(haxeparser_HaxeLexer.string2);
}},{ rule : "${", func : function(lexer5) {
	var pmin = new hxparse_Position(lexer5.source,lexer5.pos - lexer5.current.length,lexer5.pos);
	haxeparser_HaxeLexer.buf.b += Std.string(lexer5.current);
	try {
		lexer5.token(haxeparser_HaxeLexer.codeString);
	} catch( e ) {
		haxe_CallStack.lastException = e;
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		if(((e1) instanceof haxe_io_Eof)) {
			var e2 = e1;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedCode,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw e;
		}
	}
	return lexer5.token(haxeparser_HaxeLexer.string2);
}},{ rule : "[^$\\\\']+", func : function(lexer6) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer6.current);
	return lexer6.token(haxeparser_HaxeLexer.string2);
}}],"string2");
haxeparser_HaxeLexer.codeString = hxparse_Lexer.buildRuleset([{ rule : "{|/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer.current);
	lexer.token(haxeparser_HaxeLexer.codeString);
	return;
}},{ rule : "}", func : function(lexer1) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer1.current);
	return;
}},{ rule : "\"", func : function(lexer2) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	var pmin = new hxparse_Position(lexer2.source,lexer2.pos - lexer2.current.length,lexer2.pos);
	try {
		lexer2.token(haxeparser_HaxeLexer.string);
	} catch( e ) {
		haxe_CallStack.lastException = e;
		var e1 = ((e) instanceof js__$Boot_HaxeError) ? e.val : e;
		if(((e1) instanceof haxe_io_Eof)) {
			var e2 = e1;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin)));
		} else {
			throw e;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(34);
	lexer2.token(haxeparser_HaxeLexer.codeString);
	return;
}},{ rule : "'", func : function(lexer3) {
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	var pmin1 = new hxparse_Position(lexer3.source,lexer3.pos - lexer3.current.length,lexer3.pos);
	try {
		lexer3.token(haxeparser_HaxeLexer.string2);
	} catch( e3 ) {
		haxe_CallStack.lastException = e3;
		var e4 = ((e3) instanceof js__$Boot_HaxeError) ? e3.val : e3;
		if(((e4) instanceof haxe_io_Eof)) {
			var e5 = e4;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnterminatedString,haxeparser_HaxeLexer.mkPos(pmin1)));
		} else {
			throw e3;
		}
	}
	haxeparser_HaxeLexer.buf.b += String.fromCodePoint(39);
	lexer3.token(haxeparser_HaxeLexer.codeString);
	return;
}},{ rule : "/\\*", func : function(lexer4) {
	var pmin2 = new hxparse_Position(lexer4.source,lexer4.pos - lexer4.current.length,lexer4.pos);
	try {
		lexer4.token(haxeparser_HaxeLexer.comment);
	} catch( e6 ) {
		haxe_CallStack.lastException = e6;
		var e7 = ((e6) instanceof js__$Boot_HaxeError) ? e6.val : e6;
		if(((e7) instanceof haxe_io_Eof)) {
			var e8 = e7;
			throw new js__$Boot_HaxeError(new haxeparser_LexerError(haxeparser_LexerErrorMsg.UnclosedComment,haxeparser_HaxeLexer.mkPos(pmin2)));
		} else {
			throw e6;
		}
	}
	lexer4.token(haxeparser_HaxeLexer.codeString);
	return;
}},{ rule : "//[^\n\r]*", func : function(lexer5) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer5.current);
	lexer5.token(haxeparser_HaxeLexer.codeString);
	return;
}},{ rule : "[^/\"'{}\n\r]+", func : function(lexer6) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer6.current);
	lexer6.token(haxeparser_HaxeLexer.codeString);
	return;
}},{ rule : "[\r\n\t ]+", func : function(lexer7) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer7.current);
	lexer7.token(haxeparser_HaxeLexer.codeString);
	return;
}}],"codeString");
haxeparser_HaxeLexer.comment = hxparse_Lexer.buildRuleset([{ rule : "*/", func : function(lexer) {
	return new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax;
}},{ rule : "*", func : function(lexer1) {
	haxeparser_HaxeLexer.buf.b += "*";
	return lexer1.token(haxeparser_HaxeLexer.comment);
}},{ rule : "[^\\*]+", func : function(lexer2) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer2.current);
	return lexer2.token(haxeparser_HaxeLexer.comment);
}}],"comment");
haxeparser_HaxeLexer.regexp = hxparse_Lexer.buildRuleset([{ rule : "\\\\/", func : function(lexer) {
	haxeparser_HaxeLexer.buf.b += "/";
	return lexer.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\r", func : function(lexer1) {
	haxeparser_HaxeLexer.buf.b += "\r";
	return lexer1.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\n", func : function(lexer2) {
	haxeparser_HaxeLexer.buf.b += "\n";
	return lexer2.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\t", func : function(lexer3) {
	haxeparser_HaxeLexer.buf.b += "\t";
	return lexer3.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[\\\\$\\.*+\\^|{}\\[\\]()?\\-0-9]", func : function(lexer4) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer4.current);
	return lexer4.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "\\\\[wWbBsSdDx]", func : function(lexer5) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer5.current);
	return lexer5.token(haxeparser_HaxeLexer.regexp);
}},{ rule : "/", func : function(lexer6) {
	return lexer6.token(haxeparser_HaxeLexer.regexp_options);
}},{ rule : "[^\\\\/\r\n]+", func : function(lexer7) {
	haxeparser_HaxeLexer.buf.b += Std.string(lexer7.current);
	return lexer7.token(haxeparser_HaxeLexer.regexp);
}}],"regexp");
haxeparser_HaxeLexer.regexp_options = hxparse_Lexer.buildRuleset([{ rule : "[gimsu]*", func : function(lexer) {
	return { pmax : new hxparse_Position(lexer.source,lexer.pos - lexer.current.length,lexer.pos).pmax, opt : lexer.current};
}}],"regexp_options");
haxeparser_HaxeLexer.sharp_token = hxparse_Lexer.buildRuleset([{ rule : "[a-z_][a-zA-Z0-9_]*(\\.[a-z_][a-zA-Z0-9_]*)*", func : function(lexer) {
	return haxeparser_HaxeLexer.mk(lexer,haxeparser_TokenDef.Const(haxe_macro_Constant.CIdent(lexer.current)));
}},{ rule : "[\r\n\t ]+", func : function(lexer1) {
	return lexer1.token(haxeparser_HaxeLexer.sharp_token);
}},{ rule : "[.]*", func : function(lexer2) {
	return lexer2.token(haxeparser_HaxeLexer.tok);
}}],"sharp_token");
haxeparser_HaxeLexer.generatedRulesets = [haxeparser_HaxeLexer.tok,haxeparser_HaxeLexer.string,haxeparser_HaxeLexer.string2,haxeparser_HaxeLexer.codeString,haxeparser_HaxeLexer.comment,haxeparser_HaxeLexer.regexp,haxeparser_HaxeLexer.regexp_options,haxeparser_HaxeLexer.sharp_token];
tokentree_TokenStream.NO_MORE_TOKENS = "no more tokens";
tokentree_TokenStream.MODE = tokentree_TokenStreamMode.STRICT;
tokentree_TokenTree.MAX_LEVEL = 9999;
formatter_Cli.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
