1) parse parsetree into
2) build structure
  a list of modules, each of whose contains:
   - imports
   - main decl
     * class/interface with function signatures
	 * function with its signature
	 * var with type?
   - module-local decls
3) load extern libs with signatures into the structure
4) type the function bodies and var init expressions
5) transform typed tree into a more haxe-friendly one
 - rewrite for
 - rewrite for...in
 - rewrite for..each
 - rewrite implicit to-bool coercion
 - rewrite potentially-undefined-to-basic-type coercion
 - rewrite E4X operators
 - rewrite module-level functions/vars into classes with statics
 - rewrite "untyped" field access to getProperty
6) output Haxe files


TODO:
 - rewrite switch (remove breaks, handle fall-through)
 - super() calls for autogenerated ctors for classes with parent ctors
 - hasOwnProperty for dicts (and dict API in general)
 - arithmetic binop type coercion
 - block-level `&&` chains
 - flash native @:getter @:setter for overloaded accessors
 - fix priority for `new something()[expr]`
 - implement class-wrapping for module-level vars/functions
 - rewrite Int.MIN_VALUE/MAX_VALUE, Array.sortOn (and related constants), String.match
 - rewrite x.toString() to Std.string(x)
 - rewrite `new Date()` to `Date.now()`, rewrite some getters to function calls
 - rewrite float.toFixed()
 - rewrite Function.apply
 - rewrite `new Array(size)`
 - handle Null<T> to T conversion in some cases (e.g. for var x:int = dict[inexistant])
 - rewrite `as` calls (Std.intance for classes, try cast or untyped cast for other stuff)
 - finish compat abstracts
 - go through TODOs in the code
 - get rid of rework Structure so it's less awkward to work with
